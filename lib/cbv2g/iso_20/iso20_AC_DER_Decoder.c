/* SPDX-License-Identifier: Apache-2.0 */
/*
 * Copyright (C) 2022 - 2023 chargebyte GmbH
 * Copyright (C) 2022 - 2023 Contributors to EVerest
 */

/*****************************************************
 *
 * @author
 * @version
 *
 * The Code is generated! Changes may be overwritten.
 *
 *****************************************************/

/**
  * @file iso20_AC_DER_Decoder.c
  * @brief Description goes here
  *
  **/
#include <stdint.h>

#include "cbv2g/common/exi_basetypes.h"
#include "cbv2g/common/exi_types_decoder.h"
#include "cbv2g/common/exi_basetypes_decoder.h"
#include "cbv2g/common/exi_error_codes.h"
#include "cbv2g/common/exi_header.h"
#include "cbv2g/iso_20/iso20_AC_DER_Datatypes.h"
#include "cbv2g/iso_20/iso20_AC_DER_Decoder.h"



static int decode_iso20_ac_der_TransformType(exi_bitstream_t* stream, struct iso20_ac_der_TransformType* TransformType);
static int decode_iso20_ac_der_TransformsType(exi_bitstream_t* stream, struct iso20_ac_der_TransformsType* TransformsType);
static int decode_iso20_ac_der_DSAKeyValueType(exi_bitstream_t* stream, struct iso20_ac_der_DSAKeyValueType* DSAKeyValueType);
static int decode_iso20_ac_der_X509IssuerSerialType(exi_bitstream_t* stream, struct iso20_ac_der_X509IssuerSerialType* X509IssuerSerialType);
static int decode_iso20_ac_der_DigestMethodType(exi_bitstream_t* stream, struct iso20_ac_der_DigestMethodType* DigestMethodType);
static int decode_iso20_ac_der_RSAKeyValueType(exi_bitstream_t* stream, struct iso20_ac_der_RSAKeyValueType* RSAKeyValueType);
static int decode_iso20_ac_der_CanonicalizationMethodType(exi_bitstream_t* stream, struct iso20_ac_der_CanonicalizationMethodType* CanonicalizationMethodType);
static int decode_iso20_ac_der_SignatureMethodType(exi_bitstream_t* stream, struct iso20_ac_der_SignatureMethodType* SignatureMethodType);
static int decode_iso20_ac_der_KeyValueType(exi_bitstream_t* stream, struct iso20_ac_der_KeyValueType* KeyValueType);
static int decode_iso20_ac_der_ReferenceType(exi_bitstream_t* stream, struct iso20_ac_der_ReferenceType* ReferenceType);
static int decode_iso20_ac_der_RetrievalMethodType(exi_bitstream_t* stream, struct iso20_ac_der_RetrievalMethodType* RetrievalMethodType);
static int decode_iso20_ac_der_X509DataType(exi_bitstream_t* stream, struct iso20_ac_der_X509DataType* X509DataType);
static int decode_iso20_ac_der_PGPDataType(exi_bitstream_t* stream, struct iso20_ac_der_PGPDataType* PGPDataType);
static int decode_iso20_ac_der_SPKIDataType(exi_bitstream_t* stream, struct iso20_ac_der_SPKIDataType* SPKIDataType);
static int decode_iso20_ac_der_SignedInfoType(exi_bitstream_t* stream, struct iso20_ac_der_SignedInfoType* SignedInfoType);
static int decode_iso20_ac_der_SignatureValueType(exi_bitstream_t* stream, struct iso20_ac_der_SignatureValueType* SignatureValueType);
static int decode_iso20_ac_der_KeyInfoType(exi_bitstream_t* stream, struct iso20_ac_der_KeyInfoType* KeyInfoType);
static int decode_iso20_ac_der_ObjectType(exi_bitstream_t* stream, struct iso20_ac_der_ObjectType* ObjectType);
static int decode_iso20_ac_der_RationalNumberType(exi_bitstream_t* stream, struct iso20_ac_der_RationalNumberType* RationalNumberType);
static int decode_iso20_ac_der_DataTupleType(exi_bitstream_t* stream, struct iso20_ac_der_DataTupleType* DataTupleType);
static int decode_iso20_ac_der_CurveDataPointsListType(exi_bitstream_t* stream, struct iso20_ac_der_CurveDataPointsListType* CurveDataPointsListType);
static int decode_iso20_ac_der_HysteresisControlType(exi_bitstream_t* stream, struct iso20_ac_der_HysteresisControlType* HysteresisControlType);
static int decode_iso20_ac_der_DERCurveType(exi_bitstream_t* stream, struct iso20_ac_der_DERCurveType* DERCurveType);
static int decode_iso20_ac_der_ConstantPowerFactorType(exi_bitstream_t* stream, struct iso20_ac_der_ConstantPowerFactorType* ConstantPowerFactorType);
static int decode_iso20_ac_der_FrequencyWattCurveType(exi_bitstream_t* stream, struct iso20_ac_der_FrequencyWattCurveType* FrequencyWattCurveType);
static int decode_iso20_ac_der_US_FrequencyDroopSettingsType(exi_bitstream_t* stream, struct iso20_ac_der_US_FrequencyDroopSettingsType* US_FrequencyDroopSettingsType);
static int decode_iso20_ac_der_EU_FrequencyDroopSettingsType(exi_bitstream_t* stream, struct iso20_ac_der_EU_FrequencyDroopSettingsType* EU_FrequencyDroopSettingsType);
static int decode_iso20_ac_der_ConstantVarType(exi_bitstream_t* stream, struct iso20_ac_der_ConstantVarType* ConstantVarType);
static int decode_iso20_ac_der_LimitMaxDischargePowerType(exi_bitstream_t* stream, struct iso20_ac_der_LimitMaxDischargePowerType* LimitMaxDischargePowerType);
static int decode_iso20_ac_der_DeadBandType(exi_bitstream_t* stream, struct iso20_ac_der_DeadBandType* DeadBandType);
static int decode_iso20_ac_der_VoltageTripType(exi_bitstream_t* stream, struct iso20_ac_der_VoltageTripType* VoltageTripType);
static int decode_iso20_ac_der_DetailedCostType(exi_bitstream_t* stream, struct iso20_ac_der_DetailedCostType* DetailedCostType);
static int decode_iso20_ac_der_ThreePhaseType(exi_bitstream_t* stream, struct iso20_ac_der_ThreePhaseType* ThreePhaseType);
static int decode_iso20_ac_der_FrequencyTripType(exi_bitstream_t* stream, struct iso20_ac_der_FrequencyTripType* FrequencyTripType);
static int decode_iso20_ac_der_SignatureType(exi_bitstream_t* stream, struct iso20_ac_der_SignatureType* SignatureType);
static int decode_iso20_ac_der_FaultRideThroughType(exi_bitstream_t* stream, struct iso20_ac_der_FaultRideThroughType* FaultRideThroughType);
static int decode_iso20_ac_der_EnterServiceType(exi_bitstream_t* stream, struct iso20_ac_der_EnterServiceType* EnterServiceType);
static int decode_iso20_ac_der_ReactivePowerSupportType(exi_bitstream_t* stream, struct iso20_ac_der_ReactivePowerSupportType* ReactivePowerSupportType);
static int decode_iso20_ac_der_DetailedTaxType(exi_bitstream_t* stream, struct iso20_ac_der_DetailedTaxType* DetailedTaxType);
static int decode_iso20_ac_der_US_FrequencyDroopType(exi_bitstream_t* stream, struct iso20_ac_der_US_FrequencyDroopType* US_FrequencyDroopType);
static int decode_iso20_ac_der_EU_FrequencyDroopType(exi_bitstream_t* stream, struct iso20_ac_der_EU_FrequencyDroopType* EU_FrequencyDroopType);
static int decode_iso20_ac_der_FrequencyDroopType(exi_bitstream_t* stream, struct iso20_ac_der_FrequencyDroopType* FrequencyDroopType);
static int decode_iso20_ac_der_ActivePowerSupportType(exi_bitstream_t* stream, struct iso20_ac_der_ActivePowerSupportType* ActivePowerSupportType);
static int decode_iso20_ac_der_MessageHeaderType(exi_bitstream_t* stream, struct iso20_ac_der_MessageHeaderType* MessageHeaderType);
static int decode_iso20_ac_der_SignaturePropertyType(exi_bitstream_t* stream, struct iso20_ac_der_SignaturePropertyType* SignaturePropertyType);
static int decode_iso20_ac_der_AC_CPDReqEnergyTransferModeType(exi_bitstream_t* stream, struct iso20_ac_der_AC_CPDReqEnergyTransferModeType* AC_CPDReqEnergyTransferModeType);
static int decode_iso20_ac_der_DisplayParametersType(exi_bitstream_t* stream, struct iso20_ac_der_DisplayParametersType* DisplayParametersType);
static int decode_iso20_ac_der_AC_CPDResEnergyTransferModeType(exi_bitstream_t* stream, struct iso20_ac_der_AC_CPDResEnergyTransferModeType* AC_CPDResEnergyTransferModeType);
static int decode_iso20_ac_der_EVSEStatusType(exi_bitstream_t* stream, struct iso20_ac_der_EVSEStatusType* EVSEStatusType);
static int decode_iso20_ac_der_Scheduled_AC_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_Scheduled_AC_CLReqControlModeType* Scheduled_AC_CLReqControlModeType);
static int decode_iso20_ac_der_Dynamic_AC_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_Dynamic_AC_CLReqControlModeType* Dynamic_AC_CLReqControlModeType);
static int decode_iso20_ac_der_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_CLReqControlModeType* CLReqControlModeType);
static int decode_iso20_ac_der_MeterInfoType(exi_bitstream_t* stream, struct iso20_ac_der_MeterInfoType* MeterInfoType);
static int decode_iso20_ac_der_ReceiptType(exi_bitstream_t* stream, struct iso20_ac_der_ReceiptType* ReceiptType);
static int decode_iso20_ac_der_Dynamic_AC_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_Dynamic_AC_CLResControlModeType* Dynamic_AC_CLResControlModeType);
static int decode_iso20_ac_der_Scheduled_AC_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_Scheduled_AC_CLResControlModeType* Scheduled_AC_CLResControlModeType);
static int decode_iso20_ac_der_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_CLResControlModeType* CLResControlModeType);
static int decode_iso20_ac_der_PhaseType(exi_bitstream_t* stream, struct iso20_ac_der_PhaseType* PhaseType);
static int decode_iso20_ac_der_EVApparentPowerLimitsType(exi_bitstream_t* stream, struct iso20_ac_der_EVApparentPowerLimitsType* EVApparentPowerLimitsType);
static int decode_iso20_ac_der_EVReactivePowerLimitsType(exi_bitstream_t* stream, struct iso20_ac_der_EVReactivePowerLimitsType* EVReactivePowerLimitsType);
static int decode_iso20_ac_der_EVExcitationLimitsType(exi_bitstream_t* stream, struct iso20_ac_der_EVExcitationLimitsType* EVExcitationLimitsType);
static int decode_iso20_ac_der_EVInverterDetailsType(exi_bitstream_t* stream, struct iso20_ac_der_EVInverterDetailsType* EVInverterDetailsType);
static int decode_iso20_ac_der_DERControlType(exi_bitstream_t* stream, struct iso20_ac_der_DERControlType* DERControlType);
static int decode_iso20_ac_der_GridLimitsType(exi_bitstream_t* stream, struct iso20_ac_der_GridLimitsType* GridLimitsType);
static int decode_iso20_ac_der_EVApparentPowerType(exi_bitstream_t* stream, struct iso20_ac_der_EVApparentPowerType* EVApparentPowerType);
static int decode_iso20_ac_der_EVReactivePowerType(exi_bitstream_t* stream, struct iso20_ac_der_EVReactivePowerType* EVReactivePowerType);
static int decode_iso20_ac_der_EVExcitationType(exi_bitstream_t* stream, struct iso20_ac_der_EVExcitationType* EVExcitationType);
static int decode_iso20_ac_der_EVSetPointsType(exi_bitstream_t* stream, struct iso20_ac_der_EVSetPointsType* EVSetPointsType);
static int decode_iso20_ac_der_DERGridSupportActiveInfoType(exi_bitstream_t* stream, struct iso20_ac_der_DERGridSupportActiveInfoType* DERGridSupportActiveInfoType);
static int decode_iso20_ac_der_BPT_AC_CPDReqEnergyTransferModeType(exi_bitstream_t* stream, struct iso20_ac_der_BPT_AC_CPDReqEnergyTransferModeType* BPT_AC_CPDReqEnergyTransferModeType);
static int decode_iso20_ac_der_BPT_AC_CPDResEnergyTransferModeType(exi_bitstream_t* stream, struct iso20_ac_der_BPT_AC_CPDResEnergyTransferModeType* BPT_AC_CPDResEnergyTransferModeType);
static int decode_iso20_ac_der_DER_AC_CPDReqEnergyTransferModeType(exi_bitstream_t* stream, struct iso20_ac_der_DER_AC_CPDReqEnergyTransferModeType* DER_AC_CPDReqEnergyTransferModeType);
static int decode_iso20_ac_der_AC_ChargeParameterDiscoveryReqType(exi_bitstream_t* stream, struct iso20_ac_der_AC_ChargeParameterDiscoveryReqType* AC_ChargeParameterDiscoveryReqType);
static int decode_iso20_ac_der_BPT_Scheduled_AC_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_BPT_Scheduled_AC_CLReqControlModeType* BPT_Scheduled_AC_CLReqControlModeType);
static int decode_iso20_ac_der_BPT_Scheduled_AC_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_BPT_Scheduled_AC_CLResControlModeType* BPT_Scheduled_AC_CLResControlModeType);
static int decode_iso20_ac_der_BPT_Dynamic_AC_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_BPT_Dynamic_AC_CLReqControlModeType* BPT_Dynamic_AC_CLReqControlModeType);
static int decode_iso20_ac_der_BPT_Dynamic_AC_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_BPT_Dynamic_AC_CLResControlModeType* BPT_Dynamic_AC_CLResControlModeType);
static int decode_iso20_ac_der_DER_AC_CPDResEnergyTransferModeType(exi_bitstream_t* stream, struct iso20_ac_der_DER_AC_CPDResEnergyTransferModeType* DER_AC_CPDResEnergyTransferModeType);
static int decode_iso20_ac_der_AC_ChargeParameterDiscoveryResType(exi_bitstream_t* stream, struct iso20_ac_der_AC_ChargeParameterDiscoveryResType* AC_ChargeParameterDiscoveryResType);
static int decode_iso20_ac_der_DER_Scheduled_AC_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_DER_Scheduled_AC_CLReqControlModeType* DER_Scheduled_AC_CLReqControlModeType);
static int decode_iso20_ac_der_DER_Scheduled_AC_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_DER_Scheduled_AC_CLResControlModeType* DER_Scheduled_AC_CLResControlModeType);
static int decode_iso20_ac_der_DER_Dynamic_AC_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_DER_Dynamic_AC_CLReqControlModeType* DER_Dynamic_AC_CLReqControlModeType);
static int decode_iso20_ac_der_AC_ChargeLoopReqType(exi_bitstream_t* stream, struct iso20_ac_der_AC_ChargeLoopReqType* AC_ChargeLoopReqType);
static int decode_iso20_ac_der_DER_Dynamic_AC_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_DER_Dynamic_AC_CLResControlModeType* DER_Dynamic_AC_CLResControlModeType);
static int decode_iso20_ac_der_AC_ChargeLoopResType(exi_bitstream_t* stream, struct iso20_ac_der_AC_ChargeLoopResType* AC_ChargeLoopResType);
static int decode_iso20_ac_der_ManifestType(exi_bitstream_t* stream, struct iso20_ac_der_ManifestType* ManifestType);
static int decode_iso20_ac_der_SignaturePropertiesType(exi_bitstream_t* stream, struct iso20_ac_der_SignaturePropertiesType* SignaturePropertiesType);

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Transform; type={http://www.w3.org/2000/09/xmldsig#}TransformType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: Algorithm, anyURI (1, 1); ANY, anyType (0, 1); XPath, string (0, 1);
static int decode_iso20_ac_der_TransformType(exi_bitstream_t* stream, struct iso20_ac_der_TransformType* TransformType) {
    int grammar_id = 0;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_TransformType(TransformType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 0:
            // Grammar: ID=0; read/write bits=1; START (Algorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Algorithm, anyURI (anyURI)); next=1
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &TransformType->Algorithm.charactersLen);
                    if (error == 0)
                    {
                        if (TransformType->Algorithm.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            TransformType->Algorithm.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, TransformType->Algorithm.charactersLen, TransformType->Algorithm.characters, iso20_ac_der_Algorithm_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 1;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 1:
            // Grammar: ID=1; read/write bits=3; START (XPath), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (XPath, string (string)); next=2
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &TransformType->XPath.charactersLen);
                            if (error == 0)
                            {
                                if (TransformType->XPath.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    TransformType->XPath.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, TransformType->XPath.charactersLen, TransformType->XPath.characters, iso20_ac_der_XPath_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                TransformType->XPath_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 3:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &TransformType->ANY.bytesLen, &TransformType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        TransformType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Transforms; type={http://www.w3.org/2000/09/xmldsig#}TransformsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Transform, TransformType (1, 1) (original max unbounded);
static int decode_iso20_ac_der_TransformsType(exi_bitstream_t* stream, struct iso20_ac_der_TransformsType* TransformsType) {
    int grammar_id = 4;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_TransformsType(TransformsType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 4:
            // Grammar: ID=4; read/write bits=1; START (Transform)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Transform, TransformType (TransformType)); next=5
                    // decode: element
                    error = decode_iso20_ac_der_TransformType(stream, &TransformsType->Transform);
                    if (error == 0)
                    {
                        grammar_id = 5;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 5:
            // Grammar: ID=5; read/write bits=2; START (Transform), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Transform, TransformType (TransformType)); next=2
                    // decode: element
                    // This element should not occur a further time, its representation was reduced to a single element
                    error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}DSAKeyValue; type={http://www.w3.org/2000/09/xmldsig#}DSAKeyValueType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: P, CryptoBinary (0, 1) (was 1, 1) (seq. ['P', 'Q']); Q, CryptoBinary (0, 1) (was 1, 1) (seq. ['P', 'Q']); G, CryptoBinary (0, 1); Y, CryptoBinary (1, 1); J, CryptoBinary (0, 1); Seed, CryptoBinary (0, 1) (was 1, 1) (seq. ['Seed', 'PgenCounter']); PgenCounter, CryptoBinary (0, 1) (was 1, 1) (seq. ['Seed', 'PgenCounter']);
static int decode_iso20_ac_der_DSAKeyValueType(exi_bitstream_t* stream, struct iso20_ac_der_DSAKeyValueType* DSAKeyValueType) {
    int grammar_id = 6;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DSAKeyValueType(DSAKeyValueType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 6:
            // Grammar: ID=6; read/write bits=2; START (P), START (G), START (Y)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (P, CryptoBinary (base64Binary)); next=7
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->P.bytesLen, &DSAKeyValueType->P.bytes[0], iso20_ac_der_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        DSAKeyValueType->P_isUsed = 1u;
                        grammar_id = 7;
                    }
                    break;
                case 1:
                    // Event: START (G, CryptoBinary (base64Binary)); next=9
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->G.bytesLen, &DSAKeyValueType->G.bytes[0], iso20_ac_der_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        DSAKeyValueType->G_isUsed = 1u;
                        grammar_id = 9;
                    }
                    break;
                case 2:
                    // Event: START (Y, CryptoBinary (base64Binary)); next=10
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Y.bytesLen, &DSAKeyValueType->Y.bytes[0], iso20_ac_der_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        grammar_id = 10;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 7:
            // Grammar: ID=7; read/write bits=1; START (Q)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Q, CryptoBinary (base64Binary)); next=8
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Q.bytesLen, &DSAKeyValueType->Q.bytes[0], iso20_ac_der_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        DSAKeyValueType->Q_isUsed = 1u;
                        grammar_id = 8;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 8:
            // Grammar: ID=8; read/write bits=2; START (G), START (Y)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (G, CryptoBinary (base64Binary)); next=9
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->G.bytesLen, &DSAKeyValueType->G.bytes[0], iso20_ac_der_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        DSAKeyValueType->G_isUsed = 1u;
                        grammar_id = 9;
                    }
                    break;
                case 1:
                    // Event: START (Y, CryptoBinary (base64Binary)); next=10
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Y.bytesLen, &DSAKeyValueType->Y.bytes[0], iso20_ac_der_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        grammar_id = 10;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 9:
            // Grammar: ID=9; read/write bits=1; START (Y)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Y, CryptoBinary (base64Binary)); next=10
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Y.bytesLen, &DSAKeyValueType->Y.bytes[0], iso20_ac_der_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        grammar_id = 10;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 10:
            // Grammar: ID=10; read/write bits=2; START (J), START (Seed), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (J, CryptoBinary (base64Binary)); next=11
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->J.bytesLen, &DSAKeyValueType->J.bytes[0], iso20_ac_der_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        DSAKeyValueType->J_isUsed = 1u;
                        grammar_id = 11;
                    }
                    break;
                case 1:
                    // Event: START (Seed, CryptoBinary (base64Binary)); next=12
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Seed.bytesLen, &DSAKeyValueType->Seed.bytes[0], iso20_ac_der_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        DSAKeyValueType->Seed_isUsed = 1u;
                        grammar_id = 12;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 11:
            // Grammar: ID=11; read/write bits=2; START (Seed), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Seed, CryptoBinary (base64Binary)); next=12
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Seed.bytesLen, &DSAKeyValueType->Seed.bytes[0], iso20_ac_der_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        DSAKeyValueType->Seed_isUsed = 1u;
                        grammar_id = 12;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 12:
            // Grammar: ID=12; read/write bits=2; START (PgenCounter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PgenCounter, CryptoBinary (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->PgenCounter.bytesLen, &DSAKeyValueType->PgenCounter.bytes[0], iso20_ac_der_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        DSAKeyValueType->PgenCounter_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial; type={http://www.w3.org/2000/09/xmldsig#}X509IssuerSerialType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: X509IssuerName, string (1, 1); X509SerialNumber, integer (1, 1);
static int decode_iso20_ac_der_X509IssuerSerialType(exi_bitstream_t* stream, struct iso20_ac_der_X509IssuerSerialType* X509IssuerSerialType) {
    int grammar_id = 13;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_X509IssuerSerialType(X509IssuerSerialType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 13:
            // Grammar: ID=13; read/write bits=1; START (X509IssuerName)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (X509IssuerName, string (string)); next=14
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &X509IssuerSerialType->X509IssuerName.charactersLen);
                            if (error == 0)
                            {
                                if (X509IssuerSerialType->X509IssuerName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    X509IssuerSerialType->X509IssuerName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, X509IssuerSerialType->X509IssuerName.charactersLen, X509IssuerSerialType->X509IssuerName.characters, iso20_ac_der_X509IssuerName_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 14;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 14:
            // Grammar: ID=14; read/write bits=1; START (X509SerialNumber)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (X509SerialNumber, integer (decimal)); next=2
                    // decode: signed
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_signed(stream, &X509IssuerSerialType->X509SerialNumber);
                        if (error == 0)
                        {
                            grammar_id = 2;
                        }
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}DigestMethod; type={http://www.w3.org/2000/09/xmldsig#}DigestMethodType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Algorithm, anyURI (1, 1); ANY, anyType (0, 1);
static int decode_iso20_ac_der_DigestMethodType(exi_bitstream_t* stream, struct iso20_ac_der_DigestMethodType* DigestMethodType) {
    int grammar_id = 15;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DigestMethodType(DigestMethodType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 15:
            // Grammar: ID=15; read/write bits=1; START (Algorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Algorithm, anyURI (anyURI)); next=16
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &DigestMethodType->Algorithm.charactersLen);
                    if (error == 0)
                    {
                        if (DigestMethodType->Algorithm.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            DigestMethodType->Algorithm.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, DigestMethodType->Algorithm.charactersLen, DigestMethodType->Algorithm.characters, iso20_ac_der_Algorithm_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 16;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 16:
            // Grammar: ID=16; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 2:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DigestMethodType->ANY.bytesLen, &DigestMethodType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        DigestMethodType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}RSAKeyValue; type={http://www.w3.org/2000/09/xmldsig#}RSAKeyValueType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Modulus, CryptoBinary (1, 1); Exponent, CryptoBinary (1, 1);
static int decode_iso20_ac_der_RSAKeyValueType(exi_bitstream_t* stream, struct iso20_ac_der_RSAKeyValueType* RSAKeyValueType) {
    int grammar_id = 17;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_RSAKeyValueType(RSAKeyValueType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 17:
            // Grammar: ID=17; read/write bits=1; START (Modulus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Modulus, CryptoBinary (base64Binary)); next=18
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &RSAKeyValueType->Modulus.bytesLen, &RSAKeyValueType->Modulus.bytes[0], iso20_ac_der_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        grammar_id = 18;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 18:
            // Grammar: ID=18; read/write bits=1; START (Exponent)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Exponent, CryptoBinary (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &RSAKeyValueType->Exponent.bytesLen, &RSAKeyValueType->Exponent.bytes[0], iso20_ac_der_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod; type={http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethodType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Algorithm, anyURI (1, 1); ANY, anyType (0, 1);
static int decode_iso20_ac_der_CanonicalizationMethodType(exi_bitstream_t* stream, struct iso20_ac_der_CanonicalizationMethodType* CanonicalizationMethodType) {
    int grammar_id = 19;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_CanonicalizationMethodType(CanonicalizationMethodType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 19:
            // Grammar: ID=19; read/write bits=1; START (Algorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Algorithm, anyURI (anyURI)); next=20
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &CanonicalizationMethodType->Algorithm.charactersLen);
                    if (error == 0)
                    {
                        if (CanonicalizationMethodType->Algorithm.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            CanonicalizationMethodType->Algorithm.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, CanonicalizationMethodType->Algorithm.charactersLen, CanonicalizationMethodType->Algorithm.characters, iso20_ac_der_Algorithm_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 20;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 20:
            // Grammar: ID=20; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 2:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &CanonicalizationMethodType->ANY.bytesLen, &CanonicalizationMethodType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        CanonicalizationMethodType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureMethod; type={http://www.w3.org/2000/09/xmldsig#}SignatureMethodType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Algorithm, anyURI (1, 1); HMACOutputLength, HMACOutputLengthType (0, 1); ANY, anyType (0, 1);
static int decode_iso20_ac_der_SignatureMethodType(exi_bitstream_t* stream, struct iso20_ac_der_SignatureMethodType* SignatureMethodType) {
    int grammar_id = 21;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_SignatureMethodType(SignatureMethodType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 21:
            // Grammar: ID=21; read/write bits=1; START (Algorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Algorithm, anyURI (anyURI)); next=22
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureMethodType->Algorithm.charactersLen);
                    if (error == 0)
                    {
                        if (SignatureMethodType->Algorithm.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignatureMethodType->Algorithm.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignatureMethodType->Algorithm.charactersLen, SignatureMethodType->Algorithm.characters, iso20_ac_der_Algorithm_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 22;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 22:
            // Grammar: ID=22; read/write bits=3; START (HMACOutputLength), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (HMACOutputLength, HMACOutputLengthType (integer)); next=23
                    // decode: signed
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_signed(stream, &SignatureMethodType->HMACOutputLength);
                        if (error == 0)
                        {
                            SignatureMethodType->HMACOutputLength_isUsed = 1u;
                            grammar_id = 23;
                        }
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    }
                    break;
                case 1:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 3:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SignatureMethodType->ANY.bytesLen, &SignatureMethodType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        SignatureMethodType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 23:
            // Grammar: ID=23; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 2:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SignatureMethodType->ANY.bytesLen, &SignatureMethodType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        SignatureMethodType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}KeyValue; type={http://www.w3.org/2000/09/xmldsig#}KeyValueType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: DSAKeyValue, DSAKeyValueType (0, 1); RSAKeyValue, RSAKeyValueType (0, 1); ANY, anyType (0, 1);
static int decode_iso20_ac_der_KeyValueType(exi_bitstream_t* stream, struct iso20_ac_der_KeyValueType* KeyValueType) {
    int grammar_id = 24;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_KeyValueType(KeyValueType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 24:
            // Grammar: ID=24; read/write bits=2; START (DSAKeyValue), START (RSAKeyValue), START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DSAKeyValue, DSAKeyValueType (DSAKeyValueType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DSAKeyValueType(stream, &KeyValueType->DSAKeyValue);
                    if (error == 0)
                    {
                        KeyValueType->DSAKeyValue_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: START (RSAKeyValue, RSAKeyValueType (RSAKeyValueType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RSAKeyValueType(stream, &KeyValueType->RSAKeyValue);
                    if (error == 0)
                    {
                        KeyValueType->RSAKeyValue_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &KeyValueType->ANY.bytesLen, &KeyValueType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        KeyValueType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Reference; type={http://www.w3.org/2000/09/xmldsig#}ReferenceType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); Type, anyURI (0, 1); URI, anyURI (0, 1); Transforms, TransformsType (0, 1); DigestMethod, DigestMethodType (1, 1); DigestValue, DigestValueType (1, 1);
static int decode_iso20_ac_der_ReferenceType(exi_bitstream_t* stream, struct iso20_ac_der_ReferenceType* ReferenceType) {
    int grammar_id = 25;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_ReferenceType(ReferenceType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 25:
            // Grammar: ID=25; read/write bits=3; START (Id), START (Type), START (URI), START (Transforms), START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Id, ID (NCName)); next=26
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->Id.charactersLen, ReferenceType->Id.characters, iso20_ac_der_Id_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->Id_isUsed = 1u;
                    grammar_id = 26;
                    break;
                case 1:
                    // Event: START (Type, anyURI (anyURI)); next=27
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->Type.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->Type.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->Type.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->Type.charactersLen, ReferenceType->Type.characters, iso20_ac_der_Type_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->Type_isUsed = 1u;
                    grammar_id = 27;
                    break;
                case 2:
                    // Event: START (URI, anyURI (anyURI)); next=28
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->URI.charactersLen, ReferenceType->URI.characters, iso20_ac_der_URI_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->URI_isUsed = 1u;
                    grammar_id = 28;
                    break;
                case 3:
                    // Event: START (Transforms, TransformsType (TransformsType)); next=29
                    // decode: element
                    error = decode_iso20_ac_der_TransformsType(stream, &ReferenceType->Transforms);
                    if (error == 0)
                    {
                        ReferenceType->Transforms_isUsed = 1u;
                        grammar_id = 29;
                    }
                    break;
                case 4:
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=30
                    // decode: element
                    error = decode_iso20_ac_der_DigestMethodType(stream, &ReferenceType->DigestMethod);
                    if (error == 0)
                    {
                        grammar_id = 30;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 26:
            // Grammar: ID=26; read/write bits=3; START (Type), START (URI), START (Transforms), START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Type, anyURI (anyURI)); next=27
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->Type.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->Type.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->Type.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->Type.charactersLen, ReferenceType->Type.characters, iso20_ac_der_Type_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->Type_isUsed = 1u;
                    grammar_id = 27;
                    break;
                case 1:
                    // Event: START (URI, anyURI (anyURI)); next=28
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->URI.charactersLen, ReferenceType->URI.characters, iso20_ac_der_URI_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->URI_isUsed = 1u;
                    grammar_id = 28;
                    break;
                case 2:
                    // Event: START (Transforms, TransformsType (TransformsType)); next=29
                    // decode: element
                    error = decode_iso20_ac_der_TransformsType(stream, &ReferenceType->Transforms);
                    if (error == 0)
                    {
                        ReferenceType->Transforms_isUsed = 1u;
                        grammar_id = 29;
                    }
                    break;
                case 3:
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=30
                    // decode: element
                    error = decode_iso20_ac_der_DigestMethodType(stream, &ReferenceType->DigestMethod);
                    if (error == 0)
                    {
                        grammar_id = 30;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 27:
            // Grammar: ID=27; read/write bits=2; START (URI), START (Transforms), START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (URI, anyURI (anyURI)); next=28
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->URI.charactersLen, ReferenceType->URI.characters, iso20_ac_der_URI_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->URI_isUsed = 1u;
                    grammar_id = 28;
                    break;
                case 1:
                    // Event: START (Transforms, TransformsType (TransformsType)); next=29
                    // decode: element
                    error = decode_iso20_ac_der_TransformsType(stream, &ReferenceType->Transforms);
                    if (error == 0)
                    {
                        ReferenceType->Transforms_isUsed = 1u;
                        grammar_id = 29;
                    }
                    break;
                case 2:
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=30
                    // decode: element
                    error = decode_iso20_ac_der_DigestMethodType(stream, &ReferenceType->DigestMethod);
                    if (error == 0)
                    {
                        grammar_id = 30;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 28:
            // Grammar: ID=28; read/write bits=2; START (Transforms), START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Transforms, TransformsType (TransformsType)); next=29
                    // decode: element
                    error = decode_iso20_ac_der_TransformsType(stream, &ReferenceType->Transforms);
                    if (error == 0)
                    {
                        ReferenceType->Transforms_isUsed = 1u;
                        grammar_id = 29;
                    }
                    break;
                case 1:
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=30
                    // decode: element
                    error = decode_iso20_ac_der_DigestMethodType(stream, &ReferenceType->DigestMethod);
                    if (error == 0)
                    {
                        grammar_id = 30;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 29:
            // Grammar: ID=29; read/write bits=1; START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=30
                    // decode: element
                    error = decode_iso20_ac_der_DigestMethodType(stream, &ReferenceType->DigestMethod);
                    if (error == 0)
                    {
                        grammar_id = 30;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 30:
            // Grammar: ID=30; read/write bits=1; START (DigestValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DigestValue, DigestValueType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ReferenceType->DigestValue.bytesLen, &ReferenceType->DigestValue.bytes[0], iso20_ac_der_DigestValueType_BYTES_SIZE);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}RetrievalMethod; type={http://www.w3.org/2000/09/xmldsig#}RetrievalMethodType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Type, anyURI (0, 1); URI, anyURI (0, 1); Transforms, TransformsType (0, 1);
static int decode_iso20_ac_der_RetrievalMethodType(exi_bitstream_t* stream, struct iso20_ac_der_RetrievalMethodType* RetrievalMethodType) {
    int grammar_id = 31;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_RetrievalMethodType(RetrievalMethodType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 31:
            // Grammar: ID=31; read/write bits=3; START (Type), START (URI), START (Transforms), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Type, anyURI (anyURI)); next=32
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &RetrievalMethodType->Type.charactersLen);
                    if (error == 0)
                    {
                        if (RetrievalMethodType->Type.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            RetrievalMethodType->Type.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, RetrievalMethodType->Type.charactersLen, RetrievalMethodType->Type.characters, iso20_ac_der_Type_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    RetrievalMethodType->Type_isUsed = 1u;
                    grammar_id = 32;
                    break;
                case 1:
                    // Event: START (URI, anyURI (anyURI)); next=33
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &RetrievalMethodType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (RetrievalMethodType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            RetrievalMethodType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, RetrievalMethodType->URI.charactersLen, RetrievalMethodType->URI.characters, iso20_ac_der_URI_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    RetrievalMethodType->URI_isUsed = 1u;
                    grammar_id = 33;
                    break;
                case 2:
                    // Event: START (Transforms, TransformsType (TransformsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_TransformsType(stream, &RetrievalMethodType->Transforms);
                    if (error == 0)
                    {
                        RetrievalMethodType->Transforms_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 32:
            // Grammar: ID=32; read/write bits=2; START (URI), START (Transforms), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (URI, anyURI (anyURI)); next=33
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &RetrievalMethodType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (RetrievalMethodType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            RetrievalMethodType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, RetrievalMethodType->URI.charactersLen, RetrievalMethodType->URI.characters, iso20_ac_der_URI_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    RetrievalMethodType->URI_isUsed = 1u;
                    grammar_id = 33;
                    break;
                case 1:
                    // Event: START (Transforms, TransformsType (TransformsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_TransformsType(stream, &RetrievalMethodType->Transforms);
                    if (error == 0)
                    {
                        RetrievalMethodType->Transforms_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 33:
            // Grammar: ID=33; read/write bits=2; START (Transforms), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Transforms, TransformsType (TransformsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_TransformsType(stream, &RetrievalMethodType->Transforms);
                    if (error == 0)
                    {
                        RetrievalMethodType->Transforms_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}X509Data; type={http://www.w3.org/2000/09/xmldsig#}X509DataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: X509IssuerSerial, X509IssuerSerialType (0, 1); X509SKI, base64Binary (0, 1); X509SubjectName, string (0, 1); X509Certificate, base64Binary (0, 1); X509CRL, base64Binary (0, 1); ANY, anyType (0, 1);
static int decode_iso20_ac_der_X509DataType(exi_bitstream_t* stream, struct iso20_ac_der_X509DataType* X509DataType) {
    int grammar_id = 34;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_X509DataType(X509DataType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 34:
            // Grammar: ID=34; read/write bits=3; START (X509IssuerSerial), START (X509SKI), START (X509SubjectName), START (X509Certificate), START (X509CRL), START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (X509IssuerSerial, X509IssuerSerialType (X509IssuerSerialType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_X509IssuerSerialType(stream, &X509DataType->X509IssuerSerial);
                    if (error == 0)
                    {
                        X509DataType->X509IssuerSerial_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: START (X509SKI, base64Binary (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &X509DataType->X509SKI.bytesLen, &X509DataType->X509SKI.bytes[0], iso20_ac_der_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        X509DataType->X509SKI_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: START (X509SubjectName, string (string)); next=2
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &X509DataType->X509SubjectName.charactersLen);
                            if (error == 0)
                            {
                                if (X509DataType->X509SubjectName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    X509DataType->X509SubjectName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, X509DataType->X509SubjectName.charactersLen, X509DataType->X509SubjectName.characters, iso20_ac_der_X509SubjectName_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                X509DataType->X509SubjectName_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 3:
                    // Event: START (X509Certificate, base64Binary (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &X509DataType->X509Certificate.bytesLen, &X509DataType->X509Certificate.bytes[0], iso20_ac_der_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        X509DataType->X509Certificate_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: START (X509CRL, base64Binary (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &X509DataType->X509CRL.bytesLen, &X509DataType->X509CRL.bytes[0], iso20_ac_der_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        X509DataType->X509CRL_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &X509DataType->ANY.bytesLen, &X509DataType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        X509DataType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}PGPData; type={http://www.w3.org/2000/09/xmldsig#}PGPDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False; choice=True; sequence=True (2;
// Particle: PGPKeyID, base64Binary (1, 1); PGPKeyPacket, base64Binary (0, 1); ANY, anyType (0, 1); PGPKeyPacket, base64Binary (1, 1); ANY, anyType (0, 1);
static int decode_iso20_ac_der_PGPDataType(exi_bitstream_t* stream, struct iso20_ac_der_PGPDataType* PGPDataType) {
    int grammar_id = 35;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_PGPDataType(PGPDataType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 35:
            // Grammar: ID=35; read/write bits=2; START (PGPKeyID), START (PGPKeyPacket)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PGPKeyID, base64Binary (base64Binary)); next=36
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.PGPKeyID.bytesLen, &PGPDataType->choice_1.PGPKeyID.bytes[0], iso20_ac_der_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        grammar_id = 36;
                    }
                    break;
                case 1:
                    // Event: START (PGPKeyPacket, base64Binary (base64Binary)); next=37
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.PGPKeyPacket.bytesLen, &PGPDataType->choice_1.PGPKeyPacket.bytes[0], iso20_ac_der_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        PGPDataType->choice_1.PGPKeyPacket_isUsed = 1u;
                        grammar_id = 37;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 36:
            // Grammar: ID=36; read/write bits=3; START (PGPKeyPacket), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PGPKeyPacket, base64Binary (base64Binary)); next=37
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.PGPKeyPacket.bytesLen, &PGPDataType->choice_1.PGPKeyPacket.bytes[0], iso20_ac_der_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        PGPDataType->choice_1.PGPKeyPacket_isUsed = 1u;
                        grammar_id = 37;
                    }
                    break;
                case 1:
                    // Event: START (ANY, anyType (base64Binary)); next=38
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 3:
                    // Event: START (ANY, anyType (base64Binary)); next=38
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.ANY.bytesLen, &PGPDataType->choice_1.ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        PGPDataType->choice_1.ANY_isUsed = 1u;
                        grammar_id = 38;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 37:
            // Grammar: ID=37; read/write bits=3; START (ANY), END Element, END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ANY, anyType (base64Binary)); next=38
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 3:
                    // Event: START (ANY, anyType (base64Binary)); next=38
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.ANY.bytesLen, &PGPDataType->choice_1.ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        PGPDataType->choice_1.ANY_isUsed = 1u;
                        grammar_id = 38;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 38:
            // Grammar: ID=38; read/write bits=1; START (PGPKeyPacket)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PGPKeyPacket, base64Binary (base64Binary)); next=39
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_2.PGPKeyPacket.bytesLen, &PGPDataType->choice_2.PGPKeyPacket.bytes[0], iso20_ac_der_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        grammar_id = 39;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 39:
            // Grammar: ID=39; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ANY, anyType (base64Binary)); next=38
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 2:
                    // Event: START (ANY, anyType (base64Binary)); next=38
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_2.ANY.bytesLen, &PGPDataType->choice_2.ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        PGPDataType->choice_2.ANY_isUsed = 1u;
                        grammar_id = 38;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SPKIData; type={http://www.w3.org/2000/09/xmldsig#}SPKIDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SPKISexp, base64Binary (1, 1); ANY, anyType (0, 1);
static int decode_iso20_ac_der_SPKIDataType(exi_bitstream_t* stream, struct iso20_ac_der_SPKIDataType* SPKIDataType) {
    int grammar_id = 40;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_SPKIDataType(SPKIDataType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 40:
            // Grammar: ID=40; read/write bits=1; START (SPKISexp)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (SPKISexp, base64Binary (base64Binary)); next=41
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SPKIDataType->SPKISexp.bytesLen, &SPKIDataType->SPKISexp.bytes[0], iso20_ac_der_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        grammar_id = 41;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 41:
            // Grammar: ID=41; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 2:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SPKIDataType->ANY.bytesLen, &SPKIDataType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        SPKIDataType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignedInfo; type={http://www.w3.org/2000/09/xmldsig#}SignedInfoType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); CanonicalizationMethod, CanonicalizationMethodType (1, 1); SignatureMethod, SignatureMethodType (1, 1); Reference, ReferenceType (1, 4) (original max unbounded);
static int decode_iso20_ac_der_SignedInfoType(exi_bitstream_t* stream, struct iso20_ac_der_SignedInfoType* SignedInfoType) {
    int grammar_id = 42;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_SignedInfoType(SignedInfoType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 42:
            // Grammar: ID=42; read/write bits=2; START (Id), START (CanonicalizationMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Id, ID (NCName)); next=43
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignedInfoType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignedInfoType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignedInfoType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignedInfoType->Id.charactersLen, SignedInfoType->Id.characters, iso20_ac_der_Id_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SignedInfoType->Id_isUsed = 1u;
                    grammar_id = 43;
                    break;
                case 1:
                    // Event: START (CanonicalizationMethod, CanonicalizationMethodType (CanonicalizationMethodType)); next=44
                    // decode: element
                    error = decode_iso20_ac_der_CanonicalizationMethodType(stream, &SignedInfoType->CanonicalizationMethod);
                    if (error == 0)
                    {
                        grammar_id = 44;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 43:
            // Grammar: ID=43; read/write bits=1; START (CanonicalizationMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (CanonicalizationMethod, CanonicalizationMethodType (CanonicalizationMethodType)); next=44
                    // decode: element
                    error = decode_iso20_ac_der_CanonicalizationMethodType(stream, &SignedInfoType->CanonicalizationMethod);
                    if (error == 0)
                    {
                        grammar_id = 44;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 44:
            // Grammar: ID=44; read/write bits=1; START (SignatureMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (SignatureMethod, SignatureMethodType (SignatureMethodType)); next=45
                    // decode: element
                    error = decode_iso20_ac_der_SignatureMethodType(stream, &SignedInfoType->SignatureMethod);
                    if (error == 0)
                    {
                        grammar_id = 45;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 45:
            // Grammar: ID=45; read/write bits=1; START (Reference)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Reference, ReferenceType (ReferenceType)); next=46
                    // decode: element array
                    if (SignedInfoType->Reference.arrayLen < iso20_ac_der_ReferenceType_4_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_ReferenceType(stream, &SignedInfoType->Reference.array[SignedInfoType->Reference.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_ReferenceType_4_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 46;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 46:
            // Grammar: ID=46; read/write bits=2; LOOP (Reference), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: LOOP (Reference, ReferenceType (ReferenceType)); next=46
                    // decode: element array
                    if (SignedInfoType->Reference.arrayLen < iso20_ac_der_ReferenceType_4_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_ReferenceType(stream, &SignedInfoType->Reference.array[SignedInfoType->Reference.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_ReferenceType_4_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 46;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureValue; type={http://www.w3.org/2000/09/xmldsig#}SignatureValueType; base type=base64Binary; content type=simple;
//          abstract=False; final=False; derivation=extension;
// Particle: Id, ID (0, 1); CONTENT, SignatureValueType (1, 1);
static int decode_iso20_ac_der_SignatureValueType(exi_bitstream_t* stream, struct iso20_ac_der_SignatureValueType* SignatureValueType) {
    int grammar_id = 47;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_SignatureValueType(SignatureValueType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 47:
            // Grammar: ID=47; read/write bits=2; START (Id), START (CONTENT)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Id, ID (NCName)); next=48
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureValueType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignatureValueType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignatureValueType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignatureValueType->Id.charactersLen, SignatureValueType->Id.characters, iso20_ac_der_Id_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SignatureValueType->Id_isUsed = 1u;
                    grammar_id = 48;
                    break;
                case 1:
                    // Event: START (CONTENT, SignatureValueType (base64Binary)); next=2
                    // decode exi type: base64Binary (simple)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureValueType->CONTENT.bytesLen);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_bytes(stream, SignatureValueType->CONTENT.bytesLen, &SignatureValueType->CONTENT.bytes[0], iso20_ac_der_SignatureValueType_BYTES_SIZE);
                        if (error == 0)
                        {
                            grammar_id = 2;
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 48:
            // Grammar: ID=48; read/write bits=1; START (CONTENT)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (CONTENT, SignatureValueType (base64Binary)); next=2
                    // decode exi type: base64Binary (simple)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureValueType->CONTENT.bytesLen);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_bytes(stream, SignatureValueType->CONTENT.bytesLen, &SignatureValueType->CONTENT.bytes[0], iso20_ac_der_SignatureValueType_BYTES_SIZE);
                        if (error == 0)
                        {
                            grammar_id = 2;
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}KeyInfo; type={http://www.w3.org/2000/09/xmldsig#}KeyInfoType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: Id, ID (0, 1); KeyName, string (0, 1); KeyValue, KeyValueType (0, 1); RetrievalMethod, RetrievalMethodType (0, 1); X509Data, X509DataType (0, 1); PGPData, PGPDataType (0, 1); SPKIData, SPKIDataType (0, 1); MgmtData, string (0, 1); ANY, anyType (0, 1);
static int decode_iso20_ac_der_KeyInfoType(exi_bitstream_t* stream, struct iso20_ac_der_KeyInfoType* KeyInfoType) {
    int grammar_id = 49;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_KeyInfoType(KeyInfoType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 49:
            // Grammar: ID=49; read/write bits=4; START (Id), START (KeyName), START (KeyValue), START (RetrievalMethod), START (X509Data), START (PGPData), START (SPKIData), START (MgmtData), START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Id, ID (NCName)); next=50
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (KeyInfoType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            KeyInfoType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, KeyInfoType->Id.charactersLen, KeyInfoType->Id.characters, iso20_ac_der_Id_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    KeyInfoType->Id_isUsed = 1u;
                    grammar_id = 50;
                    break;
                case 1:
                    // Event: START (KeyName, string (string)); next=2
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->KeyName.charactersLen);
                            if (error == 0)
                            {
                                if (KeyInfoType->KeyName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    KeyInfoType->KeyName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, KeyInfoType->KeyName.charactersLen, KeyInfoType->KeyName.characters, iso20_ac_der_KeyName_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                KeyInfoType->KeyName_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (KeyValue, KeyValueType (KeyValueType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_KeyValueType(stream, &KeyInfoType->KeyValue);
                    if (error == 0)
                    {
                        KeyInfoType->KeyValue_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: START (RetrievalMethod, RetrievalMethodType (RetrievalMethodType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RetrievalMethodType(stream, &KeyInfoType->RetrievalMethod);
                    if (error == 0)
                    {
                        KeyInfoType->RetrievalMethod_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: START (X509Data, X509DataType (X509DataType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_X509DataType(stream, &KeyInfoType->X509Data);
                    if (error == 0)
                    {
                        KeyInfoType->X509Data_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: START (PGPData, PGPDataType (PGPDataType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_PGPDataType(stream, &KeyInfoType->PGPData);
                    if (error == 0)
                    {
                        KeyInfoType->PGPData_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: START (SPKIData, SPKIDataType (SPKIDataType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_SPKIDataType(stream, &KeyInfoType->SPKIData);
                    if (error == 0)
                    {
                        KeyInfoType->SPKIData_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: START (MgmtData, string (string)); next=2
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->MgmtData.charactersLen);
                            if (error == 0)
                            {
                                if (KeyInfoType->MgmtData.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    KeyInfoType->MgmtData.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, KeyInfoType->MgmtData.charactersLen, KeyInfoType->MgmtData.characters, iso20_ac_der_MgmtData_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                KeyInfoType->MgmtData_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 8:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &KeyInfoType->ANY.bytesLen, &KeyInfoType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        KeyInfoType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 50:
            // Grammar: ID=50; read/write bits=4; START (KeyName), START (KeyValue), START (RetrievalMethod), START (X509Data), START (PGPData), START (SPKIData), START (MgmtData), START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (KeyName, string (string)); next=2
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->KeyName.charactersLen);
                            if (error == 0)
                            {
                                if (KeyInfoType->KeyName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    KeyInfoType->KeyName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, KeyInfoType->KeyName.charactersLen, KeyInfoType->KeyName.characters, iso20_ac_der_KeyName_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                KeyInfoType->KeyName_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (KeyValue, KeyValueType (KeyValueType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_KeyValueType(stream, &KeyInfoType->KeyValue);
                    if (error == 0)
                    {
                        KeyInfoType->KeyValue_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: START (RetrievalMethod, RetrievalMethodType (RetrievalMethodType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RetrievalMethodType(stream, &KeyInfoType->RetrievalMethod);
                    if (error == 0)
                    {
                        KeyInfoType->RetrievalMethod_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: START (X509Data, X509DataType (X509DataType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_X509DataType(stream, &KeyInfoType->X509Data);
                    if (error == 0)
                    {
                        KeyInfoType->X509Data_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: START (PGPData, PGPDataType (PGPDataType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_PGPDataType(stream, &KeyInfoType->PGPData);
                    if (error == 0)
                    {
                        KeyInfoType->PGPData_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: START (SPKIData, SPKIDataType (SPKIDataType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_SPKIDataType(stream, &KeyInfoType->SPKIData);
                    if (error == 0)
                    {
                        KeyInfoType->SPKIData_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: START (MgmtData, string (string)); next=2
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->MgmtData.charactersLen);
                            if (error == 0)
                            {
                                if (KeyInfoType->MgmtData.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    KeyInfoType->MgmtData.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, KeyInfoType->MgmtData.charactersLen, KeyInfoType->MgmtData.characters, iso20_ac_der_MgmtData_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                KeyInfoType->MgmtData_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 7:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &KeyInfoType->ANY.bytesLen, &KeyInfoType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        KeyInfoType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Object; type={http://www.w3.org/2000/09/xmldsig#}ObjectType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Encoding, anyURI (0, 1); Id, ID (0, 1); MimeType, string (0, 1); ANY, anyType (0, 1) (old 1, 1);
static int decode_iso20_ac_der_ObjectType(exi_bitstream_t* stream, struct iso20_ac_der_ObjectType* ObjectType) {
    int grammar_id = 51;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_ObjectType(ObjectType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 51:
            // Grammar: ID=51; read/write bits=3; START (Encoding), START (Id), START (MimeType), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Encoding, anyURI (anyURI)); next=52
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->Encoding.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->Encoding.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->Encoding.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->Encoding.charactersLen, ObjectType->Encoding.characters, iso20_ac_der_Encoding_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->Encoding_isUsed = 1u;
                    grammar_id = 52;
                    break;
                case 1:
                    // Event: START (Id, ID (NCName)); next=53
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->Id.charactersLen, ObjectType->Id.characters, iso20_ac_der_Id_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->Id_isUsed = 1u;
                    grammar_id = 53;
                    break;
                case 2:
                    // Event: START (MimeType, string (string)); next=54
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->MimeType.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->MimeType.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->MimeType.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->MimeType.charactersLen, ObjectType->MimeType.characters, iso20_ac_der_MimeType_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->MimeType_isUsed = 1u;
                    grammar_id = 54;
                    break;
                case 3:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 5:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ObjectType->ANY.bytesLen, &ObjectType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        ObjectType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 52:
            // Grammar: ID=52; read/write bits=3; START (Id), START (MimeType), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Id, ID (NCName)); next=53
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->Id.charactersLen, ObjectType->Id.characters, iso20_ac_der_Id_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->Id_isUsed = 1u;
                    grammar_id = 53;
                    break;
                case 1:
                    // Event: START (MimeType, string (string)); next=54
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->MimeType.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->MimeType.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->MimeType.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->MimeType.charactersLen, ObjectType->MimeType.characters, iso20_ac_der_MimeType_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->MimeType_isUsed = 1u;
                    grammar_id = 54;
                    break;
                case 2:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 4:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ObjectType->ANY.bytesLen, &ObjectType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        ObjectType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 53:
            // Grammar: ID=53; read/write bits=3; START (MimeType), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MimeType, string (string)); next=54
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->MimeType.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->MimeType.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->MimeType.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->MimeType.charactersLen, ObjectType->MimeType.characters, iso20_ac_der_MimeType_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->MimeType_isUsed = 1u;
                    grammar_id = 54;
                    break;
                case 1:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 3:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ObjectType->ANY.bytesLen, &ObjectType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        ObjectType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 54:
            // Grammar: ID=54; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                case 2:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ObjectType->ANY.bytesLen, &ObjectType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        ObjectType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}EVMaximumChargePower; type={urn:iso:std:iso:15118:-20:CommonTypes}RationalNumberType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Exponent, byte (1, 1); Value, short (1, 1);
static int decode_iso20_ac_der_RationalNumberType(exi_bitstream_t* stream, struct iso20_ac_der_RationalNumberType* RationalNumberType) {
    int grammar_id = 55;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_RationalNumberType(RationalNumberType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 55:
            // Grammar: ID=55; read/write bits=1; START (Exponent)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Exponent, byte (short)); next=56
                    // decode: byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                // type has min_value = -128
                                RationalNumberType->Exponent = (int8_t)(value + -128);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 56;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 56:
            // Grammar: ID=56; read/write bits=1; START (Value)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Value, short (int)); next=2
                    // decode: short
                    error = decode_exi_type_integer16(stream, &RationalNumberType->Value);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}CurveDataPoint; type={urn:iso:std:iso:15118:-20:AC}DataTupleType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: x, RationalNumberType (1, 1); y, RationalNumberType (1, 1);
static int decode_iso20_ac_der_DataTupleType(exi_bitstream_t* stream, struct iso20_ac_der_DataTupleType* DataTupleType) {
    int grammar_id = 57;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DataTupleType(DataTupleType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 57:
            // Grammar: ID=57; read/write bits=1; START (x)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (x, RationalNumberType (RationalNumberType)); next=58
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DataTupleType->x);
                    if (error == 0)
                    {
                        grammar_id = 58;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 58:
            // Grammar: ID=58; read/write bits=1; START (y)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (y, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DataTupleType->y);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}CurveDataPoints; type={urn:iso:std:iso:15118:-20:AC}CurveDataPointsListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: CurveDataPoint, DataTupleType (2, 10);
static int decode_iso20_ac_der_CurveDataPointsListType(exi_bitstream_t* stream, struct iso20_ac_der_CurveDataPointsListType* CurveDataPointsListType) {
    int grammar_id = 59;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_CurveDataPointsListType(CurveDataPointsListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 59:
            // Grammar: ID=59; read/write bits=2; START (CurveDataPoint), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (CurveDataPoint, DataTupleType (DataTupleType)); next=60
                    // decode: element array
                    if (CurveDataPointsListType->CurveDataPoint.arrayLen < iso20_ac_der_DataTupleType_10_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_DataTupleType(stream, &CurveDataPointsListType->CurveDataPoint.array[CurveDataPointsListType->CurveDataPoint.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_DataTupleType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 60;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 60:
            // Grammar: ID=60; read/write bits=1; LOOP (CurveDataPoint)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: LOOP (CurveDataPoint, DataTupleType (DataTupleType)); next=60
                    // decode: element array
                    if (CurveDataPointsListType->CurveDataPoint.arrayLen < iso20_ac_der_DataTupleType_10_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_DataTupleType(stream, &CurveDataPointsListType->CurveDataPoint.array[CurveDataPointsListType->CurveDataPoint.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_DataTupleType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (CurveDataPointsListType->CurveDataPoint.arrayLen < 10)
                    {
                        grammar_id = 60;
                    }
                    else
                    {
                        grammar_id = -1;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}HysteresisControl; type={urn:iso:std:iso:15118:-20:AC}HysteresisControlType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Fstop, RationalNumberType (1, 1); PowerUpRamp, unsignedShort (1, 1); IntentionalDelayFstop, RationalNumberType (0, 1);
static int decode_iso20_ac_der_HysteresisControlType(exi_bitstream_t* stream, struct iso20_ac_der_HysteresisControlType* HysteresisControlType) {
    int grammar_id = 61;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_HysteresisControlType(HysteresisControlType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 61:
            // Grammar: ID=61; read/write bits=1; START (Fstop)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Fstop, RationalNumberType (RationalNumberType)); next=62
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &HysteresisControlType->Fstop);
                    if (error == 0)
                    {
                        grammar_id = 62;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 62:
            // Grammar: ID=62; read/write bits=1; START (PowerUpRamp)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PowerUpRamp, unsignedShort (unsignedInt)); next=63
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &HysteresisControlType->PowerUpRamp);
                    if (error == 0)
                    {
                        grammar_id = 63;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 63:
            // Grammar: ID=63; read/write bits=2; START (IntentionalDelayFstop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (IntentionalDelayFstop, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &HysteresisControlType->IntentionalDelayFstop);
                    if (error == 0)
                    {
                        HysteresisControlType->IntentionalDelayFstop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}OverVoltageMustTripCurve; type={urn:iso:std:iso:15118:-20:AC}DERCurveType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Enable, boolean (0, 1); Priority, unsignedShort (0, 1); xUnit, curveDataPointsUnitType (1, 1); yUnit, curveDataPointsUnitType (1, 1); CurveDataPoints, CurveDataPointsListType (1, 1); LockInValue, lockValueUnitType (0, 1); LockOutValue, lockValueUnitType (0, 1); OpenLoopResponseTime, RationalNumberType (0, 1); TimeConstantPT1, int (0, 1); IntentionalDelay, RationalNumberType (0, 1);
static int decode_iso20_ac_der_DERCurveType(exi_bitstream_t* stream, struct iso20_ac_der_DERCurveType* DERCurveType) {
    int grammar_id = 64;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DERCurveType(DERCurveType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 64:
            // Grammar: ID=64; read/write bits=2; START (Enable), START (Priority), START (xUnit)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Enable, boolean (boolean)); next=65
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DERCurveType->Enable = value;
                                DERCurveType->Enable_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 65;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=66
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &DERCurveType->Priority);
                    if (error == 0)
                    {
                        DERCurveType->Priority_isUsed = 1u;
                        grammar_id = 66;
                    }
                    break;
                case 2:
                    // Event: START (xUnit, curveDataPointsUnitType (string)); next=67
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                DERCurveType->xUnit = (iso20_ac_der_curveDataPointsUnitType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 67;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 65:
            // Grammar: ID=65; read/write bits=2; START (Priority), START (xUnit)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=66
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &DERCurveType->Priority);
                    if (error == 0)
                    {
                        DERCurveType->Priority_isUsed = 1u;
                        grammar_id = 66;
                    }
                    break;
                case 1:
                    // Event: START (xUnit, curveDataPointsUnitType (string)); next=67
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                DERCurveType->xUnit = (iso20_ac_der_curveDataPointsUnitType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 67;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 66:
            // Grammar: ID=66; read/write bits=1; START (xUnit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (xUnit, curveDataPointsUnitType (string)); next=67
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                DERCurveType->xUnit = (iso20_ac_der_curveDataPointsUnitType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 67;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 67:
            // Grammar: ID=67; read/write bits=1; START (yUnit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (yUnit, curveDataPointsUnitType (string)); next=68
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                DERCurveType->yUnit = (iso20_ac_der_curveDataPointsUnitType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 68;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 68:
            // Grammar: ID=68; read/write bits=1; START (CurveDataPoints)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (CurveDataPoints, CurveDataPointsListType (CurveDataPointsListType)); next=69
                    // decode: element
                    error = decode_iso20_ac_der_CurveDataPointsListType(stream, &DERCurveType->CurveDataPoints);
                    if (error == 0)
                    {
                        grammar_id = 69;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 69:
            // Grammar: ID=69; read/write bits=3; START (LockInValue), START (LockOutValue), START (OpenLoopResponseTime), START (TimeConstantPT1), START (IntentionalDelay), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (LockInValue, lockValueUnitType (string)); next=70
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                            if (error == 0)
                            {
                                DERCurveType->LockInValue = (iso20_ac_der_lockValueUnitType)value;
                                DERCurveType->LockInValue_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 70;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (LockOutValue, lockValueUnitType (string)); next=71
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                            if (error == 0)
                            {
                                DERCurveType->LockOutValue = (iso20_ac_der_lockValueUnitType)value;
                                DERCurveType->LockOutValue_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 71;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (OpenLoopResponseTime, RationalNumberType (RationalNumberType)); next=72
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERCurveType->OpenLoopResponseTime);
                    if (error == 0)
                    {
                        DERCurveType->OpenLoopResponseTime_isUsed = 1u;
                        grammar_id = 72;
                    }
                    break;
                case 3:
                    // Event: START (TimeConstantPT1, int (long)); next=73
                    // decode: int
                    error = decode_exi_type_integer32(stream, &DERCurveType->TimeConstantPT1);
                    if (error == 0)
                    {
                        DERCurveType->TimeConstantPT1_isUsed = 1u;
                        grammar_id = 73;
                    }
                    break;
                case 4:
                    // Event: START (IntentionalDelay, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERCurveType->IntentionalDelay);
                    if (error == 0)
                    {
                        DERCurveType->IntentionalDelay_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 70:
            // Grammar: ID=70; read/write bits=3; START (LockOutValue), START (OpenLoopResponseTime), START (TimeConstantPT1), START (IntentionalDelay), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (LockOutValue, lockValueUnitType (string)); next=71
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                            if (error == 0)
                            {
                                DERCurveType->LockOutValue = (iso20_ac_der_lockValueUnitType)value;
                                DERCurveType->LockOutValue_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 71;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (OpenLoopResponseTime, RationalNumberType (RationalNumberType)); next=72
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERCurveType->OpenLoopResponseTime);
                    if (error == 0)
                    {
                        DERCurveType->OpenLoopResponseTime_isUsed = 1u;
                        grammar_id = 72;
                    }
                    break;
                case 2:
                    // Event: START (TimeConstantPT1, int (long)); next=73
                    // decode: int
                    error = decode_exi_type_integer32(stream, &DERCurveType->TimeConstantPT1);
                    if (error == 0)
                    {
                        DERCurveType->TimeConstantPT1_isUsed = 1u;
                        grammar_id = 73;
                    }
                    break;
                case 3:
                    // Event: START (IntentionalDelay, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERCurveType->IntentionalDelay);
                    if (error == 0)
                    {
                        DERCurveType->IntentionalDelay_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 71:
            // Grammar: ID=71; read/write bits=3; START (OpenLoopResponseTime), START (TimeConstantPT1), START (IntentionalDelay), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OpenLoopResponseTime, RationalNumberType (RationalNumberType)); next=72
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERCurveType->OpenLoopResponseTime);
                    if (error == 0)
                    {
                        DERCurveType->OpenLoopResponseTime_isUsed = 1u;
                        grammar_id = 72;
                    }
                    break;
                case 1:
                    // Event: START (TimeConstantPT1, int (long)); next=73
                    // decode: int
                    error = decode_exi_type_integer32(stream, &DERCurveType->TimeConstantPT1);
                    if (error == 0)
                    {
                        DERCurveType->TimeConstantPT1_isUsed = 1u;
                        grammar_id = 73;
                    }
                    break;
                case 2:
                    // Event: START (IntentionalDelay, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERCurveType->IntentionalDelay);
                    if (error == 0)
                    {
                        DERCurveType->IntentionalDelay_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 72:
            // Grammar: ID=72; read/write bits=2; START (TimeConstantPT1), START (IntentionalDelay), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (TimeConstantPT1, int (long)); next=73
                    // decode: int
                    error = decode_exi_type_integer32(stream, &DERCurveType->TimeConstantPT1);
                    if (error == 0)
                    {
                        DERCurveType->TimeConstantPT1_isUsed = 1u;
                        grammar_id = 73;
                    }
                    break;
                case 1:
                    // Event: START (IntentionalDelay, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERCurveType->IntentionalDelay);
                    if (error == 0)
                    {
                        DERCurveType->IntentionalDelay_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 73:
            // Grammar: ID=73; read/write bits=2; START (IntentionalDelay), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (IntentionalDelay, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERCurveType->IntentionalDelay);
                    if (error == 0)
                    {
                        DERCurveType->IntentionalDelay_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}ConstantPowerFactor; type={urn:iso:std:iso:15118:-20:AC}ConstantPowerFactorType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Enable, boolean (0, 1); Priority, unsignedShort (0, 1); PowerFactorValue, RationalNumberType (1, 1); PowerFactorExcitation, powerFactorExcitationType (1, 1);
static int decode_iso20_ac_der_ConstantPowerFactorType(exi_bitstream_t* stream, struct iso20_ac_der_ConstantPowerFactorType* ConstantPowerFactorType) {
    int grammar_id = 74;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_ConstantPowerFactorType(ConstantPowerFactorType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 74:
            // Grammar: ID=74; read/write bits=2; START (Enable), START (Priority), START (PowerFactorValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Enable, boolean (boolean)); next=75
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ConstantPowerFactorType->Enable = value;
                                ConstantPowerFactorType->Enable_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 75;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=76
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &ConstantPowerFactorType->Priority);
                    if (error == 0)
                    {
                        ConstantPowerFactorType->Priority_isUsed = 1u;
                        grammar_id = 76;
                    }
                    break;
                case 2:
                    // Event: START (PowerFactorValue, RationalNumberType (RationalNumberType)); next=77
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &ConstantPowerFactorType->PowerFactorValue);
                    if (error == 0)
                    {
                        grammar_id = 77;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 75:
            // Grammar: ID=75; read/write bits=2; START (Priority), START (PowerFactorValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=76
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &ConstantPowerFactorType->Priority);
                    if (error == 0)
                    {
                        ConstantPowerFactorType->Priority_isUsed = 1u;
                        grammar_id = 76;
                    }
                    break;
                case 1:
                    // Event: START (PowerFactorValue, RationalNumberType (RationalNumberType)); next=77
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &ConstantPowerFactorType->PowerFactorValue);
                    if (error == 0)
                    {
                        grammar_id = 77;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 76:
            // Grammar: ID=76; read/write bits=1; START (PowerFactorValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PowerFactorValue, RationalNumberType (RationalNumberType)); next=77
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &ConstantPowerFactorType->PowerFactorValue);
                    if (error == 0)
                    {
                        grammar_id = 77;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 77:
            // Grammar: ID=77; read/write bits=1; START (PowerFactorExcitation)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PowerFactorExcitation, powerFactorExcitationType (string)); next=2
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ConstantPowerFactorType->PowerFactorExcitation = (iso20_ac_der_powerFactorExcitationType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}FrequencyWatt; type={urn:iso:std:iso:15118:-20:AC}FrequencyWattCurveType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Enable, boolean (0, 1); Priority, unsignedShort (0, 1); xUnit, curveDataPointsUnitType (1, 1); yUnit, curveDataPointsUnitType (1, 1); CurveDataPoints, CurveDataPointsListType (1, 1); OpenLoopResponseTime, RationalNumberType (0, 1); HysteresisHigh, RationalNumberType (0, 1); HysteresisLow, RationalNumberType (0, 1); HysteresisDelay, RationalNumberType (0, 1); HysteresisGradient, RationalNumberType (0, 1);
static int decode_iso20_ac_der_FrequencyWattCurveType(exi_bitstream_t* stream, struct iso20_ac_der_FrequencyWattCurveType* FrequencyWattCurveType) {
    int grammar_id = 78;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_FrequencyWattCurveType(FrequencyWattCurveType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 78:
            // Grammar: ID=78; read/write bits=2; START (Enable), START (Priority), START (xUnit)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Enable, boolean (boolean)); next=79
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                FrequencyWattCurveType->Enable = value;
                                FrequencyWattCurveType->Enable_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 79;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=80
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &FrequencyWattCurveType->Priority);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->Priority_isUsed = 1u;
                        grammar_id = 80;
                    }
                    break;
                case 2:
                    // Event: START (xUnit, curveDataPointsUnitType (string)); next=81
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                FrequencyWattCurveType->xUnit = (iso20_ac_der_curveDataPointsUnitType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 81;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 79:
            // Grammar: ID=79; read/write bits=2; START (Priority), START (xUnit)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=80
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &FrequencyWattCurveType->Priority);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->Priority_isUsed = 1u;
                        grammar_id = 80;
                    }
                    break;
                case 1:
                    // Event: START (xUnit, curveDataPointsUnitType (string)); next=81
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                FrequencyWattCurveType->xUnit = (iso20_ac_der_curveDataPointsUnitType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 81;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 80:
            // Grammar: ID=80; read/write bits=1; START (xUnit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (xUnit, curveDataPointsUnitType (string)); next=81
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                FrequencyWattCurveType->xUnit = (iso20_ac_der_curveDataPointsUnitType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 81;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 81:
            // Grammar: ID=81; read/write bits=1; START (yUnit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (yUnit, curveDataPointsUnitType (string)); next=82
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                FrequencyWattCurveType->yUnit = (iso20_ac_der_curveDataPointsUnitType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 82;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 82:
            // Grammar: ID=82; read/write bits=1; START (CurveDataPoints)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (CurveDataPoints, CurveDataPointsListType (CurveDataPointsListType)); next=83
                    // decode: element
                    error = decode_iso20_ac_der_CurveDataPointsListType(stream, &FrequencyWattCurveType->CurveDataPoints);
                    if (error == 0)
                    {
                        grammar_id = 83;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 83:
            // Grammar: ID=83; read/write bits=3; START (OpenLoopResponseTime), START (HysteresisHigh), START (HysteresisLow), START (HysteresisDelay), START (HysteresisGradient), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OpenLoopResponseTime, RationalNumberType (RationalNumberType)); next=84
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->OpenLoopResponseTime);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->OpenLoopResponseTime_isUsed = 1u;
                        grammar_id = 84;
                    }
                    break;
                case 1:
                    // Event: START (HysteresisHigh, RationalNumberType (RationalNumberType)); next=85
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisHigh);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisHigh_isUsed = 1u;
                        grammar_id = 85;
                    }
                    break;
                case 2:
                    // Event: START (HysteresisLow, RationalNumberType (RationalNumberType)); next=86
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisLow);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisLow_isUsed = 1u;
                        grammar_id = 86;
                    }
                    break;
                case 3:
                    // Event: START (HysteresisDelay, RationalNumberType (RationalNumberType)); next=87
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisDelay);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisDelay_isUsed = 1u;
                        grammar_id = 87;
                    }
                    break;
                case 4:
                    // Event: START (HysteresisGradient, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisGradient);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisGradient_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 84:
            // Grammar: ID=84; read/write bits=3; START (HysteresisHigh), START (HysteresisLow), START (HysteresisDelay), START (HysteresisGradient), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (HysteresisHigh, RationalNumberType (RationalNumberType)); next=85
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisHigh);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisHigh_isUsed = 1u;
                        grammar_id = 85;
                    }
                    break;
                case 1:
                    // Event: START (HysteresisLow, RationalNumberType (RationalNumberType)); next=86
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisLow);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisLow_isUsed = 1u;
                        grammar_id = 86;
                    }
                    break;
                case 2:
                    // Event: START (HysteresisDelay, RationalNumberType (RationalNumberType)); next=87
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisDelay);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisDelay_isUsed = 1u;
                        grammar_id = 87;
                    }
                    break;
                case 3:
                    // Event: START (HysteresisGradient, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisGradient);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisGradient_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 85:
            // Grammar: ID=85; read/write bits=3; START (HysteresisLow), START (HysteresisDelay), START (HysteresisGradient), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (HysteresisLow, RationalNumberType (RationalNumberType)); next=86
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisLow);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisLow_isUsed = 1u;
                        grammar_id = 86;
                    }
                    break;
                case 1:
                    // Event: START (HysteresisDelay, RationalNumberType (RationalNumberType)); next=87
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisDelay);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisDelay_isUsed = 1u;
                        grammar_id = 87;
                    }
                    break;
                case 2:
                    // Event: START (HysteresisGradient, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisGradient);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisGradient_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 86:
            // Grammar: ID=86; read/write bits=2; START (HysteresisDelay), START (HysteresisGradient), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (HysteresisDelay, RationalNumberType (RationalNumberType)); next=87
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisDelay);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisDelay_isUsed = 1u;
                        grammar_id = 87;
                    }
                    break;
                case 1:
                    // Event: START (HysteresisGradient, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisGradient);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisGradient_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 87:
            // Grammar: ID=87; read/write bits=2; START (HysteresisGradient), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (HysteresisGradient, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FrequencyWattCurveType->HysteresisGradient);
                    if (error == 0)
                    {
                        FrequencyWattCurveType->HysteresisGradient_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}OverFrequencyDroop; type={urn:iso:std:iso:15118:-20:AC}US_FrequencyDroopSettingsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: db, RationalNumberType (1, 1); k, RationalNumberType (1, 1); PowerReference, powerReferenceType (1, 1); OpenLoopResponseTime, RationalNumberType (0, 1);
static int decode_iso20_ac_der_US_FrequencyDroopSettingsType(exi_bitstream_t* stream, struct iso20_ac_der_US_FrequencyDroopSettingsType* US_FrequencyDroopSettingsType) {
    int grammar_id = 88;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_US_FrequencyDroopSettingsType(US_FrequencyDroopSettingsType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 88:
            // Grammar: ID=88; read/write bits=1; START (db)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (db, RationalNumberType (RationalNumberType)); next=89
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &US_FrequencyDroopSettingsType->db);
                    if (error == 0)
                    {
                        grammar_id = 89;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 89:
            // Grammar: ID=89; read/write bits=1; START (k)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (k, RationalNumberType (RationalNumberType)); next=90
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &US_FrequencyDroopSettingsType->k);
                    if (error == 0)
                    {
                        grammar_id = 90;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 90:
            // Grammar: ID=90; read/write bits=1; START (PowerReference)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PowerReference, powerReferenceType (string)); next=91
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                US_FrequencyDroopSettingsType->PowerReference = (iso20_ac_der_powerReferenceType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 91;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 91:
            // Grammar: ID=91; read/write bits=2; START (OpenLoopResponseTime), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OpenLoopResponseTime, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &US_FrequencyDroopSettingsType->OpenLoopResponseTime);
                    if (error == 0)
                    {
                        US_FrequencyDroopSettingsType->OpenLoopResponseTime_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}OverFrequencyDroop; type={urn:iso:std:iso:15118:-20:AC}EU_FrequencyDroopSettingsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Fstart, RationalNumberType (1, 1); s, RationalNumberType (1, 1); DeactivationTime, RationalNumberType (0, 1); IntentionalDelayPowerControl, RationalNumberType (0, 1); PowerReference, powerReferenceType (1, 1); HysteresisControl, HysteresisControlType (0, 1); MaxReactionTime, RationalNumberType (0, 1);
static int decode_iso20_ac_der_EU_FrequencyDroopSettingsType(exi_bitstream_t* stream, struct iso20_ac_der_EU_FrequencyDroopSettingsType* EU_FrequencyDroopSettingsType) {
    int grammar_id = 92;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_EU_FrequencyDroopSettingsType(EU_FrequencyDroopSettingsType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 92:
            // Grammar: ID=92; read/write bits=1; START (Fstart)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Fstart, RationalNumberType (RationalNumberType)); next=93
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EU_FrequencyDroopSettingsType->Fstart);
                    if (error == 0)
                    {
                        grammar_id = 93;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 93:
            // Grammar: ID=93; read/write bits=1; START (s)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (s, RationalNumberType (RationalNumberType)); next=94
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EU_FrequencyDroopSettingsType->s);
                    if (error == 0)
                    {
                        grammar_id = 94;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 94:
            // Grammar: ID=94; read/write bits=2; START (DeactivationTime), START (IntentionalDelayPowerControl), START (PowerReference)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DeactivationTime, RationalNumberType (RationalNumberType)); next=95
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EU_FrequencyDroopSettingsType->DeactivationTime);
                    if (error == 0)
                    {
                        EU_FrequencyDroopSettingsType->DeactivationTime_isUsed = 1u;
                        grammar_id = 95;
                    }
                    break;
                case 1:
                    // Event: START (IntentionalDelayPowerControl, RationalNumberType (RationalNumberType)); next=96
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EU_FrequencyDroopSettingsType->IntentionalDelayPowerControl);
                    if (error == 0)
                    {
                        EU_FrequencyDroopSettingsType->IntentionalDelayPowerControl_isUsed = 1u;
                        grammar_id = 96;
                    }
                    break;
                case 2:
                    // Event: START (PowerReference, powerReferenceType (string)); next=97
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                EU_FrequencyDroopSettingsType->PowerReference = (iso20_ac_der_powerReferenceType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 97;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 95:
            // Grammar: ID=95; read/write bits=2; START (IntentionalDelayPowerControl), START (PowerReference)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (IntentionalDelayPowerControl, RationalNumberType (RationalNumberType)); next=96
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EU_FrequencyDroopSettingsType->IntentionalDelayPowerControl);
                    if (error == 0)
                    {
                        EU_FrequencyDroopSettingsType->IntentionalDelayPowerControl_isUsed = 1u;
                        grammar_id = 96;
                    }
                    break;
                case 1:
                    // Event: START (PowerReference, powerReferenceType (string)); next=97
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                EU_FrequencyDroopSettingsType->PowerReference = (iso20_ac_der_powerReferenceType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 97;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 96:
            // Grammar: ID=96; read/write bits=1; START (PowerReference)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PowerReference, powerReferenceType (string)); next=97
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                EU_FrequencyDroopSettingsType->PowerReference = (iso20_ac_der_powerReferenceType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 97;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 97:
            // Grammar: ID=97; read/write bits=2; START (HysteresisControl), START (MaxReactionTime), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (HysteresisControl, HysteresisControlType (HysteresisControlType)); next=98
                    // decode: element
                    error = decode_iso20_ac_der_HysteresisControlType(stream, &EU_FrequencyDroopSettingsType->HysteresisControl);
                    if (error == 0)
                    {
                        EU_FrequencyDroopSettingsType->HysteresisControl_isUsed = 1u;
                        grammar_id = 98;
                    }
                    break;
                case 1:
                    // Event: START (MaxReactionTime, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EU_FrequencyDroopSettingsType->MaxReactionTime);
                    if (error == 0)
                    {
                        EU_FrequencyDroopSettingsType->MaxReactionTime_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 98:
            // Grammar: ID=98; read/write bits=2; START (MaxReactionTime), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MaxReactionTime, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EU_FrequencyDroopSettingsType->MaxReactionTime);
                    if (error == 0)
                    {
                        EU_FrequencyDroopSettingsType->MaxReactionTime_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}ConstantVar; type={urn:iso:std:iso:15118:-20:AC}ConstantVarType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Enable, boolean (0, 1); Priority, unsignedShort (0, 1); Setpoint, RationalNumberType (1, 1); Unit, curveDataPointsUnitType (1, 1);
static int decode_iso20_ac_der_ConstantVarType(exi_bitstream_t* stream, struct iso20_ac_der_ConstantVarType* ConstantVarType) {
    int grammar_id = 99;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_ConstantVarType(ConstantVarType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 99:
            // Grammar: ID=99; read/write bits=2; START (Enable), START (Priority), START (Setpoint)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Enable, boolean (boolean)); next=100
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ConstantVarType->Enable = value;
                                ConstantVarType->Enable_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 100;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=101
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &ConstantVarType->Priority);
                    if (error == 0)
                    {
                        ConstantVarType->Priority_isUsed = 1u;
                        grammar_id = 101;
                    }
                    break;
                case 2:
                    // Event: START (Setpoint, RationalNumberType (RationalNumberType)); next=102
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &ConstantVarType->Setpoint);
                    if (error == 0)
                    {
                        grammar_id = 102;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 100:
            // Grammar: ID=100; read/write bits=2; START (Priority), START (Setpoint)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=101
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &ConstantVarType->Priority);
                    if (error == 0)
                    {
                        ConstantVarType->Priority_isUsed = 1u;
                        grammar_id = 101;
                    }
                    break;
                case 1:
                    // Event: START (Setpoint, RationalNumberType (RationalNumberType)); next=102
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &ConstantVarType->Setpoint);
                    if (error == 0)
                    {
                        grammar_id = 102;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 101:
            // Grammar: ID=101; read/write bits=1; START (Setpoint)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Setpoint, RationalNumberType (RationalNumberType)); next=102
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &ConstantVarType->Setpoint);
                    if (error == 0)
                    {
                        grammar_id = 102;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 102:
            // Grammar: ID=102; read/write bits=1; START (Unit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Unit, curveDataPointsUnitType (string)); next=2
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                ConstantVarType->Unit = (iso20_ac_der_curveDataPointsUnitType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}LimitMaxDischargePower; type={urn:iso:std:iso:15118:-20:AC}LimitMaxDischargePowerType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Enable, boolean (0, 1); Priority, unsignedShort (0, 1); PercentageValue, unsignedShort (1, 1); PowerMonitoringMustTripCurve, DERCurveType (0, 1);
static int decode_iso20_ac_der_LimitMaxDischargePowerType(exi_bitstream_t* stream, struct iso20_ac_der_LimitMaxDischargePowerType* LimitMaxDischargePowerType) {
    int grammar_id = 103;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_LimitMaxDischargePowerType(LimitMaxDischargePowerType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 103:
            // Grammar: ID=103; read/write bits=2; START (Enable), START (Priority), START (PercentageValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Enable, boolean (boolean)); next=104
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                LimitMaxDischargePowerType->Enable = value;
                                LimitMaxDischargePowerType->Enable_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 104;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=105
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &LimitMaxDischargePowerType->Priority);
                    if (error == 0)
                    {
                        LimitMaxDischargePowerType->Priority_isUsed = 1u;
                        grammar_id = 105;
                    }
                    break;
                case 2:
                    // Event: START (PercentageValue, unsignedShort (unsignedInt)); next=106
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &LimitMaxDischargePowerType->PercentageValue);
                    if (error == 0)
                    {
                        grammar_id = 106;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 104:
            // Grammar: ID=104; read/write bits=2; START (Priority), START (PercentageValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=105
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &LimitMaxDischargePowerType->Priority);
                    if (error == 0)
                    {
                        LimitMaxDischargePowerType->Priority_isUsed = 1u;
                        grammar_id = 105;
                    }
                    break;
                case 1:
                    // Event: START (PercentageValue, unsignedShort (unsignedInt)); next=106
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &LimitMaxDischargePowerType->PercentageValue);
                    if (error == 0)
                    {
                        grammar_id = 106;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 105:
            // Grammar: ID=105; read/write bits=1; START (PercentageValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PercentageValue, unsignedShort (unsignedInt)); next=106
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &LimitMaxDischargePowerType->PercentageValue);
                    if (error == 0)
                    {
                        grammar_id = 106;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 106:
            // Grammar: ID=106; read/write bits=2; START (PowerMonitoringMustTripCurve), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PowerMonitoringMustTripCurve, DERCurveType (DERCurveType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &LimitMaxDischargePowerType->PowerMonitoringMustTripCurve);
                    if (error == 0)
                    {
                        LimitMaxDischargePowerType->PowerMonitoringMustTripCurve_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}DeadBand; type={urn:iso:std:iso:15118:-20:AC}DeadBandType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: MidLow, RationalNumberType (1, 1); MidHigh, RationalNumberType (1, 1); Low, RationalNumberType (0, 1); High, RationalNumberType (0, 1);
static int decode_iso20_ac_der_DeadBandType(exi_bitstream_t* stream, struct iso20_ac_der_DeadBandType* DeadBandType) {
    int grammar_id = 107;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DeadBandType(DeadBandType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 107:
            // Grammar: ID=107; read/write bits=1; START (MidLow)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MidLow, RationalNumberType (RationalNumberType)); next=108
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DeadBandType->MidLow);
                    if (error == 0)
                    {
                        grammar_id = 108;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 108:
            // Grammar: ID=108; read/write bits=1; START (MidHigh)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MidHigh, RationalNumberType (RationalNumberType)); next=109
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DeadBandType->MidHigh);
                    if (error == 0)
                    {
                        grammar_id = 109;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 109:
            // Grammar: ID=109; read/write bits=2; START (Low), START (High), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Low, RationalNumberType (RationalNumberType)); next=110
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DeadBandType->Low);
                    if (error == 0)
                    {
                        DeadBandType->Low_isUsed = 1u;
                        grammar_id = 110;
                    }
                    break;
                case 1:
                    // Event: START (High, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DeadBandType->High);
                    if (error == 0)
                    {
                        DeadBandType->High_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 110:
            // Grammar: ID=110; read/write bits=2; START (High), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (High, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DeadBandType->High);
                    if (error == 0)
                    {
                        DeadBandType->High_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}VoltageTrip; type={urn:iso:std:iso:15118:-20:AC}VoltageTripType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: OverVoltageMustTripCurve, DERCurveType (1, 1); UnderVoltageMustTripCurve, DERCurveType (1, 1); OverVoltageMomentaryCessationTripCurve, DERCurveType (1, 1); UnderVoltageMomentaryCessationTripCurve, DERCurveType (1, 1); OverVoltageMayTripCurve, DERCurveType (0, 1); UnderVoltageMayTripCurve, DERCurveType (0, 1); OverVoltageMeanValue10min, RationalNumberType (0, 1); OverVoltage10MinMeanTripDelay, RationalNumberType (0, 1); PowerDuringCessation, powerDuringCessationType (0, 1);
static int decode_iso20_ac_der_VoltageTripType(exi_bitstream_t* stream, struct iso20_ac_der_VoltageTripType* VoltageTripType) {
    int grammar_id = 111;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_VoltageTripType(VoltageTripType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 111:
            // Grammar: ID=111; read/write bits=1; START (OverVoltageMustTripCurve)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OverVoltageMustTripCurve, DERCurveType (DERCurveType)); next=112
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &VoltageTripType->OverVoltageMustTripCurve);
                    if (error == 0)
                    {
                        grammar_id = 112;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 112:
            // Grammar: ID=112; read/write bits=1; START (UnderVoltageMustTripCurve)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (UnderVoltageMustTripCurve, DERCurveType (DERCurveType)); next=113
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &VoltageTripType->UnderVoltageMustTripCurve);
                    if (error == 0)
                    {
                        grammar_id = 113;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 113:
            // Grammar: ID=113; read/write bits=1; START (OverVoltageMomentaryCessationTripCurve)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OverVoltageMomentaryCessationTripCurve, DERCurveType (DERCurveType)); next=114
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &VoltageTripType->OverVoltageMomentaryCessationTripCurve);
                    if (error == 0)
                    {
                        grammar_id = 114;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 114:
            // Grammar: ID=114; read/write bits=1; START (UnderVoltageMomentaryCessationTripCurve)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (UnderVoltageMomentaryCessationTripCurve, DERCurveType (DERCurveType)); next=115
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &VoltageTripType->UnderVoltageMomentaryCessationTripCurve);
                    if (error == 0)
                    {
                        grammar_id = 115;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 115:
            // Grammar: ID=115; read/write bits=3; START (OverVoltageMayTripCurve), START (UnderVoltageMayTripCurve), START (OverVoltageMeanValue10min), START (OverVoltage10MinMeanTripDelay), START (PowerDuringCessation), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OverVoltageMayTripCurve, DERCurveType (DERCurveType)); next=116
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &VoltageTripType->OverVoltageMayTripCurve);
                    if (error == 0)
                    {
                        VoltageTripType->OverVoltageMayTripCurve_isUsed = 1u;
                        grammar_id = 116;
                    }
                    break;
                case 1:
                    // Event: START (UnderVoltageMayTripCurve, DERCurveType (DERCurveType)); next=117
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &VoltageTripType->UnderVoltageMayTripCurve);
                    if (error == 0)
                    {
                        VoltageTripType->UnderVoltageMayTripCurve_isUsed = 1u;
                        grammar_id = 117;
                    }
                    break;
                case 2:
                    // Event: START (OverVoltageMeanValue10min, RationalNumberType (RationalNumberType)); next=118
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &VoltageTripType->OverVoltageMeanValue10min);
                    if (error == 0)
                    {
                        VoltageTripType->OverVoltageMeanValue10min_isUsed = 1u;
                        grammar_id = 118;
                    }
                    break;
                case 3:
                    // Event: START (OverVoltage10MinMeanTripDelay, RationalNumberType (RationalNumberType)); next=119
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &VoltageTripType->OverVoltage10MinMeanTripDelay);
                    if (error == 0)
                    {
                        VoltageTripType->OverVoltage10MinMeanTripDelay_isUsed = 1u;
                        grammar_id = 119;
                    }
                    break;
                case 4:
                    // Event: START (PowerDuringCessation, powerDuringCessationType (string)); next=2
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                VoltageTripType->PowerDuringCessation = (iso20_ac_der_powerDuringCessationType)value;
                                VoltageTripType->PowerDuringCessation_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 116:
            // Grammar: ID=116; read/write bits=3; START (UnderVoltageMayTripCurve), START (OverVoltageMeanValue10min), START (OverVoltage10MinMeanTripDelay), START (PowerDuringCessation), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (UnderVoltageMayTripCurve, DERCurveType (DERCurveType)); next=117
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &VoltageTripType->UnderVoltageMayTripCurve);
                    if (error == 0)
                    {
                        VoltageTripType->UnderVoltageMayTripCurve_isUsed = 1u;
                        grammar_id = 117;
                    }
                    break;
                case 1:
                    // Event: START (OverVoltageMeanValue10min, RationalNumberType (RationalNumberType)); next=118
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &VoltageTripType->OverVoltageMeanValue10min);
                    if (error == 0)
                    {
                        VoltageTripType->OverVoltageMeanValue10min_isUsed = 1u;
                        grammar_id = 118;
                    }
                    break;
                case 2:
                    // Event: START (OverVoltage10MinMeanTripDelay, RationalNumberType (RationalNumberType)); next=119
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &VoltageTripType->OverVoltage10MinMeanTripDelay);
                    if (error == 0)
                    {
                        VoltageTripType->OverVoltage10MinMeanTripDelay_isUsed = 1u;
                        grammar_id = 119;
                    }
                    break;
                case 3:
                    // Event: START (PowerDuringCessation, powerDuringCessationType (string)); next=2
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                VoltageTripType->PowerDuringCessation = (iso20_ac_der_powerDuringCessationType)value;
                                VoltageTripType->PowerDuringCessation_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 117:
            // Grammar: ID=117; read/write bits=3; START (OverVoltageMeanValue10min), START (OverVoltage10MinMeanTripDelay), START (PowerDuringCessation), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OverVoltageMeanValue10min, RationalNumberType (RationalNumberType)); next=118
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &VoltageTripType->OverVoltageMeanValue10min);
                    if (error == 0)
                    {
                        VoltageTripType->OverVoltageMeanValue10min_isUsed = 1u;
                        grammar_id = 118;
                    }
                    break;
                case 1:
                    // Event: START (OverVoltage10MinMeanTripDelay, RationalNumberType (RationalNumberType)); next=119
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &VoltageTripType->OverVoltage10MinMeanTripDelay);
                    if (error == 0)
                    {
                        VoltageTripType->OverVoltage10MinMeanTripDelay_isUsed = 1u;
                        grammar_id = 119;
                    }
                    break;
                case 2:
                    // Event: START (PowerDuringCessation, powerDuringCessationType (string)); next=2
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                VoltageTripType->PowerDuringCessation = (iso20_ac_der_powerDuringCessationType)value;
                                VoltageTripType->PowerDuringCessation_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 118:
            // Grammar: ID=118; read/write bits=2; START (OverVoltage10MinMeanTripDelay), START (PowerDuringCessation), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OverVoltage10MinMeanTripDelay, RationalNumberType (RationalNumberType)); next=119
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &VoltageTripType->OverVoltage10MinMeanTripDelay);
                    if (error == 0)
                    {
                        VoltageTripType->OverVoltage10MinMeanTripDelay_isUsed = 1u;
                        grammar_id = 119;
                    }
                    break;
                case 1:
                    // Event: START (PowerDuringCessation, powerDuringCessationType (string)); next=2
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                VoltageTripType->PowerDuringCessation = (iso20_ac_der_powerDuringCessationType)value;
                                VoltageTripType->PowerDuringCessation_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 119:
            // Grammar: ID=119; read/write bits=2; START (PowerDuringCessation), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PowerDuringCessation, powerDuringCessationType (string)); next=2
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                VoltageTripType->PowerDuringCessation = (iso20_ac_der_powerDuringCessationType)value;
                                VoltageTripType->PowerDuringCessation_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}EnergyCosts; type={urn:iso:std:iso:15118:-20:CommonTypes}DetailedCostType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Amount, RationalNumberType (1, 1); CostPerUnit, RationalNumberType (1, 1);
static int decode_iso20_ac_der_DetailedCostType(exi_bitstream_t* stream, struct iso20_ac_der_DetailedCostType* DetailedCostType) {
    int grammar_id = 120;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DetailedCostType(DetailedCostType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 120:
            // Grammar: ID=120; read/write bits=1; START (Amount)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Amount, RationalNumberType (RationalNumberType)); next=121
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DetailedCostType->Amount);
                    if (error == 0)
                    {
                        grammar_id = 121;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 121:
            // Grammar: ID=121; read/write bits=1; START (CostPerUnit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (CostPerUnit, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DetailedCostType->CostPerUnit);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}ThreePhase; type={urn:iso:std:iso:15118:-20:AC}ThreePhaseType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: PhaseL1, RationalNumberType (1, 1); PhaseL2, RationalNumberType (1, 1); PhaseL3, RationalNumberType (1, 1);
static int decode_iso20_ac_der_ThreePhaseType(exi_bitstream_t* stream, struct iso20_ac_der_ThreePhaseType* ThreePhaseType) {
    int grammar_id = 122;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_ThreePhaseType(ThreePhaseType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 122:
            // Grammar: ID=122; read/write bits=1; START (PhaseL1)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PhaseL1, RationalNumberType (RationalNumberType)); next=123
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &ThreePhaseType->PhaseL1);
                    if (error == 0)
                    {
                        grammar_id = 123;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 123:
            // Grammar: ID=123; read/write bits=1; START (PhaseL2)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PhaseL2, RationalNumberType (RationalNumberType)); next=124
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &ThreePhaseType->PhaseL2);
                    if (error == 0)
                    {
                        grammar_id = 124;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 124:
            // Grammar: ID=124; read/write bits=1; START (PhaseL3)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PhaseL3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &ThreePhaseType->PhaseL3);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}FrequencyTrip; type={urn:iso:std:iso:15118:-20:AC}FrequencyTripType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: OverFrequencyMustTripCurve, DERCurveType (1, 1); UnderFrequencyMustTripCurve, DERCurveType (1, 1); OverFrequencyMayTripCurve, DERCurveType (0, 1); UnderFrequencyMayTripCurve, DERCurveType (0, 1);
static int decode_iso20_ac_der_FrequencyTripType(exi_bitstream_t* stream, struct iso20_ac_der_FrequencyTripType* FrequencyTripType) {
    int grammar_id = 125;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_FrequencyTripType(FrequencyTripType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 125:
            // Grammar: ID=125; read/write bits=1; START (OverFrequencyMustTripCurve)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OverFrequencyMustTripCurve, DERCurveType (DERCurveType)); next=126
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &FrequencyTripType->OverFrequencyMustTripCurve);
                    if (error == 0)
                    {
                        grammar_id = 126;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 126:
            // Grammar: ID=126; read/write bits=1; START (UnderFrequencyMustTripCurve)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (UnderFrequencyMustTripCurve, DERCurveType (DERCurveType)); next=127
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &FrequencyTripType->UnderFrequencyMustTripCurve);
                    if (error == 0)
                    {
                        grammar_id = 127;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 127:
            // Grammar: ID=127; read/write bits=2; START (OverFrequencyMayTripCurve), START (UnderFrequencyMayTripCurve), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OverFrequencyMayTripCurve, DERCurveType (DERCurveType)); next=128
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &FrequencyTripType->OverFrequencyMayTripCurve);
                    if (error == 0)
                    {
                        FrequencyTripType->OverFrequencyMayTripCurve_isUsed = 1u;
                        grammar_id = 128;
                    }
                    break;
                case 1:
                    // Event: START (UnderFrequencyMayTripCurve, DERCurveType (DERCurveType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &FrequencyTripType->UnderFrequencyMayTripCurve);
                    if (error == 0)
                    {
                        FrequencyTripType->UnderFrequencyMayTripCurve_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 128:
            // Grammar: ID=128; read/write bits=2; START (UnderFrequencyMayTripCurve), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (UnderFrequencyMayTripCurve, DERCurveType (DERCurveType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &FrequencyTripType->UnderFrequencyMayTripCurve);
                    if (error == 0)
                    {
                        FrequencyTripType->UnderFrequencyMayTripCurve_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Signature; type={http://www.w3.org/2000/09/xmldsig#}SignatureType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); SignedInfo, SignedInfoType (1, 1); SignatureValue, SignatureValueType (1, 1); KeyInfo, KeyInfoType (0, 1); Object, ObjectType (0, 1) (original max unbounded);
static int decode_iso20_ac_der_SignatureType(exi_bitstream_t* stream, struct iso20_ac_der_SignatureType* SignatureType) {
    int grammar_id = 129;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_SignatureType(SignatureType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 129:
            // Grammar: ID=129; read/write bits=2; START (Id), START (SignedInfo)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Id, ID (NCName)); next=130
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignatureType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignatureType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignatureType->Id.charactersLen, SignatureType->Id.characters, iso20_ac_der_Id_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SignatureType->Id_isUsed = 1u;
                    grammar_id = 130;
                    break;
                case 1:
                    // Event: START (SignedInfo, SignedInfoType (SignedInfoType)); next=131
                    // decode: element
                    error = decode_iso20_ac_der_SignedInfoType(stream, &SignatureType->SignedInfo);
                    if (error == 0)
                    {
                        grammar_id = 131;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 130:
            // Grammar: ID=130; read/write bits=1; START (SignedInfo)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (SignedInfo, SignedInfoType (SignedInfoType)); next=131
                    // decode: element
                    error = decode_iso20_ac_der_SignedInfoType(stream, &SignatureType->SignedInfo);
                    if (error == 0)
                    {
                        grammar_id = 131;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 131:
            // Grammar: ID=131; read/write bits=1; START (SignatureValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (SignatureValue, SignatureValueType (base64Binary)); next=132
                    // decode: element
                    error = decode_iso20_ac_der_SignatureValueType(stream, &SignatureType->SignatureValue);
                    if (error == 0)
                    {
                        grammar_id = 132;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 132:
            // Grammar: ID=132; read/write bits=2; START (KeyInfo), START (Object), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (KeyInfo, KeyInfoType (KeyInfoType)); next=134
                    // decode: element
                    error = decode_iso20_ac_der_KeyInfoType(stream, &SignatureType->KeyInfo);
                    if (error == 0)
                    {
                        SignatureType->KeyInfo_isUsed = 1u;
                        grammar_id = 134;
                    }
                    break;
                case 1:
                    // Event: START (Object, ObjectType (ObjectType)); next=133
                    // decode: element
                    error = decode_iso20_ac_der_ObjectType(stream, &SignatureType->Object);
                    if (error == 0)
                    {
                        SignatureType->Object_isUsed = 1u;
                        grammar_id = 133;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 133:
            // Grammar: ID=133; read/write bits=2; START (Object), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Object, ObjectType (ObjectType)); next=2
                    // decode: element
                    // This element should not occur a further time, its representation was reduced to a single element
                    error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 134:
            // Grammar: ID=134; read/write bits=2; START (Object), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Object, ObjectType (ObjectType)); next=135
                    // decode: element
                    error = decode_iso20_ac_der_ObjectType(stream, &SignatureType->Object);
                    if (error == 0)
                    {
                        SignatureType->Object_isUsed = 1u;
                        grammar_id = 135;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 135:
            // Grammar: ID=135; read/write bits=2; START (Object), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Object, ObjectType (ObjectType)); next=2
                    // decode: element
                    // This element should not occur a further time, its representation was reduced to a single element
                    error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}FaultRideThrough; type={urn:iso:std:iso:15118:-20:AC}FaultRideThroughType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: OverVoltageRideThroughPositiveCurveKFactor, RationalNumberType (0, 1); OverVoltageRideThroughNegativeCurveKFactor, RationalNumberType (0, 1); UnderVoltageRideThroughPositiveCurveKFactor, RationalNumberType (0, 1); UnderVoltageRideThroughNegativeCurveKFactor, RationalNumberType (0, 1); DeadBand, DeadBandType (0, 1);
static int decode_iso20_ac_der_FaultRideThroughType(exi_bitstream_t* stream, struct iso20_ac_der_FaultRideThroughType* FaultRideThroughType) {
    int grammar_id = 136;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_FaultRideThroughType(FaultRideThroughType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 136:
            // Grammar: ID=136; read/write bits=3; START (OverVoltageRideThroughPositiveCurveKFactor), START (OverVoltageRideThroughNegativeCurveKFactor), START (UnderVoltageRideThroughPositiveCurveKFactor), START (UnderVoltageRideThroughNegativeCurveKFactor), START (DeadBand), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OverVoltageRideThroughPositiveCurveKFactor, RationalNumberType (RationalNumberType)); next=137
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FaultRideThroughType->OverVoltageRideThroughPositiveCurveKFactor);
                    if (error == 0)
                    {
                        FaultRideThroughType->OverVoltageRideThroughPositiveCurveKFactor_isUsed = 1u;
                        grammar_id = 137;
                    }
                    break;
                case 1:
                    // Event: START (OverVoltageRideThroughNegativeCurveKFactor, RationalNumberType (RationalNumberType)); next=138
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FaultRideThroughType->OverVoltageRideThroughNegativeCurveKFactor);
                    if (error == 0)
                    {
                        FaultRideThroughType->OverVoltageRideThroughNegativeCurveKFactor_isUsed = 1u;
                        grammar_id = 138;
                    }
                    break;
                case 2:
                    // Event: START (UnderVoltageRideThroughPositiveCurveKFactor, RationalNumberType (RationalNumberType)); next=139
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FaultRideThroughType->UnderVoltageRideThroughPositiveCurveKFactor);
                    if (error == 0)
                    {
                        FaultRideThroughType->UnderVoltageRideThroughPositiveCurveKFactor_isUsed = 1u;
                        grammar_id = 139;
                    }
                    break;
                case 3:
                    // Event: START (UnderVoltageRideThroughNegativeCurveKFactor, RationalNumberType (RationalNumberType)); next=140
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FaultRideThroughType->UnderVoltageRideThroughNegativeCurveKFactor);
                    if (error == 0)
                    {
                        FaultRideThroughType->UnderVoltageRideThroughNegativeCurveKFactor_isUsed = 1u;
                        grammar_id = 140;
                    }
                    break;
                case 4:
                    // Event: START (DeadBand, DeadBandType (DeadBandType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DeadBandType(stream, &FaultRideThroughType->DeadBand);
                    if (error == 0)
                    {
                        FaultRideThroughType->DeadBand_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 137:
            // Grammar: ID=137; read/write bits=3; START (OverVoltageRideThroughNegativeCurveKFactor), START (UnderVoltageRideThroughPositiveCurveKFactor), START (UnderVoltageRideThroughNegativeCurveKFactor), START (DeadBand), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OverVoltageRideThroughNegativeCurveKFactor, RationalNumberType (RationalNumberType)); next=138
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FaultRideThroughType->OverVoltageRideThroughNegativeCurveKFactor);
                    if (error == 0)
                    {
                        FaultRideThroughType->OverVoltageRideThroughNegativeCurveKFactor_isUsed = 1u;
                        grammar_id = 138;
                    }
                    break;
                case 1:
                    // Event: START (UnderVoltageRideThroughPositiveCurveKFactor, RationalNumberType (RationalNumberType)); next=139
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FaultRideThroughType->UnderVoltageRideThroughPositiveCurveKFactor);
                    if (error == 0)
                    {
                        FaultRideThroughType->UnderVoltageRideThroughPositiveCurveKFactor_isUsed = 1u;
                        grammar_id = 139;
                    }
                    break;
                case 2:
                    // Event: START (UnderVoltageRideThroughNegativeCurveKFactor, RationalNumberType (RationalNumberType)); next=140
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FaultRideThroughType->UnderVoltageRideThroughNegativeCurveKFactor);
                    if (error == 0)
                    {
                        FaultRideThroughType->UnderVoltageRideThroughNegativeCurveKFactor_isUsed = 1u;
                        grammar_id = 140;
                    }
                    break;
                case 3:
                    // Event: START (DeadBand, DeadBandType (DeadBandType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DeadBandType(stream, &FaultRideThroughType->DeadBand);
                    if (error == 0)
                    {
                        FaultRideThroughType->DeadBand_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 138:
            // Grammar: ID=138; read/write bits=3; START (UnderVoltageRideThroughPositiveCurveKFactor), START (UnderVoltageRideThroughNegativeCurveKFactor), START (DeadBand), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (UnderVoltageRideThroughPositiveCurveKFactor, RationalNumberType (RationalNumberType)); next=139
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FaultRideThroughType->UnderVoltageRideThroughPositiveCurveKFactor);
                    if (error == 0)
                    {
                        FaultRideThroughType->UnderVoltageRideThroughPositiveCurveKFactor_isUsed = 1u;
                        grammar_id = 139;
                    }
                    break;
                case 1:
                    // Event: START (UnderVoltageRideThroughNegativeCurveKFactor, RationalNumberType (RationalNumberType)); next=140
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FaultRideThroughType->UnderVoltageRideThroughNegativeCurveKFactor);
                    if (error == 0)
                    {
                        FaultRideThroughType->UnderVoltageRideThroughNegativeCurveKFactor_isUsed = 1u;
                        grammar_id = 140;
                    }
                    break;
                case 2:
                    // Event: START (DeadBand, DeadBandType (DeadBandType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DeadBandType(stream, &FaultRideThroughType->DeadBand);
                    if (error == 0)
                    {
                        FaultRideThroughType->DeadBand_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 139:
            // Grammar: ID=139; read/write bits=2; START (UnderVoltageRideThroughNegativeCurveKFactor), START (DeadBand), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (UnderVoltageRideThroughNegativeCurveKFactor, RationalNumberType (RationalNumberType)); next=140
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &FaultRideThroughType->UnderVoltageRideThroughNegativeCurveKFactor);
                    if (error == 0)
                    {
                        FaultRideThroughType->UnderVoltageRideThroughNegativeCurveKFactor_isUsed = 1u;
                        grammar_id = 140;
                    }
                    break;
                case 1:
                    // Event: START (DeadBand, DeadBandType (DeadBandType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DeadBandType(stream, &FaultRideThroughType->DeadBand);
                    if (error == 0)
                    {
                        FaultRideThroughType->DeadBand_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 140:
            // Grammar: ID=140; read/write bits=2; START (DeadBand), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DeadBand, DeadBandType (DeadBandType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DeadBandType(stream, &FaultRideThroughType->DeadBand);
                    if (error == 0)
                    {
                        FaultRideThroughType->DeadBand_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}EnterService; type={urn:iso:std:iso:15118:-20:AC}EnterServiceType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: PermitService, boolean (0, 1); EnterServiceVoltageHigh, RationalNumberType (1, 1); EnterServiceVoltageLow, RationalNumberType (1, 1); EnterServiceFrequencyHigh, RationalNumberType (1, 1); EnterServiceFrequencyLow, RationalNumberType (1, 1); EnterServiceDelay, RationalNumberType (1, 1); EnterServiceRandomizedDelay, RationalNumberType (1, 1); EnterServiceRampTime, RationalNumberType (1, 1); EnterServiceGradient, RationalNumberType (0, 1);
static int decode_iso20_ac_der_EnterServiceType(exi_bitstream_t* stream, struct iso20_ac_der_EnterServiceType* EnterServiceType) {
    int grammar_id = 141;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_EnterServiceType(EnterServiceType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 141:
            // Grammar: ID=141; read/write bits=2; START (PermitService), START (EnterServiceVoltageHigh)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PermitService, boolean (boolean)); next=142
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                EnterServiceType->PermitService = value;
                                EnterServiceType->PermitService_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 142;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (EnterServiceVoltageHigh, RationalNumberType (RationalNumberType)); next=143
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EnterServiceType->EnterServiceVoltageHigh);
                    if (error == 0)
                    {
                        grammar_id = 143;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 142:
            // Grammar: ID=142; read/write bits=1; START (EnterServiceVoltageHigh)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EnterServiceVoltageHigh, RationalNumberType (RationalNumberType)); next=143
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EnterServiceType->EnterServiceVoltageHigh);
                    if (error == 0)
                    {
                        grammar_id = 143;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 143:
            // Grammar: ID=143; read/write bits=1; START (EnterServiceVoltageLow)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EnterServiceVoltageLow, RationalNumberType (RationalNumberType)); next=144
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EnterServiceType->EnterServiceVoltageLow);
                    if (error == 0)
                    {
                        grammar_id = 144;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 144:
            // Grammar: ID=144; read/write bits=1; START (EnterServiceFrequencyHigh)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EnterServiceFrequencyHigh, RationalNumberType (RationalNumberType)); next=145
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EnterServiceType->EnterServiceFrequencyHigh);
                    if (error == 0)
                    {
                        grammar_id = 145;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 145:
            // Grammar: ID=145; read/write bits=1; START (EnterServiceFrequencyLow)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EnterServiceFrequencyLow, RationalNumberType (RationalNumberType)); next=146
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EnterServiceType->EnterServiceFrequencyLow);
                    if (error == 0)
                    {
                        grammar_id = 146;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 146:
            // Grammar: ID=146; read/write bits=1; START (EnterServiceDelay)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EnterServiceDelay, RationalNumberType (RationalNumberType)); next=147
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EnterServiceType->EnterServiceDelay);
                    if (error == 0)
                    {
                        grammar_id = 147;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 147:
            // Grammar: ID=147; read/write bits=1; START (EnterServiceRandomizedDelay)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EnterServiceRandomizedDelay, RationalNumberType (RationalNumberType)); next=148
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EnterServiceType->EnterServiceRandomizedDelay);
                    if (error == 0)
                    {
                        grammar_id = 148;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 148:
            // Grammar: ID=148; read/write bits=1; START (EnterServiceRampTime)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EnterServiceRampTime, RationalNumberType (RationalNumberType)); next=149
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EnterServiceType->EnterServiceRampTime);
                    if (error == 0)
                    {
                        grammar_id = 149;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 149:
            // Grammar: ID=149; read/write bits=2; START (EnterServiceGradient), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EnterServiceGradient, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EnterServiceType->EnterServiceGradient);
                    if (error == 0)
                    {
                        EnterServiceType->EnterServiceGradient_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}ReactivePowerSupport; type={urn:iso:std:iso:15118:-20:AC}ReactivePowerSupportType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ConstantPowerFactor, ConstantPowerFactorType (0, 1); VoltVar, DERCurveType (0, 1); WattVar, DERCurveType (0, 1); ConstantVar, ConstantVarType (0, 1); WattCosPhi, DERCurveType (0, 1);
static int decode_iso20_ac_der_ReactivePowerSupportType(exi_bitstream_t* stream, struct iso20_ac_der_ReactivePowerSupportType* ReactivePowerSupportType) {
    int grammar_id = 150;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_ReactivePowerSupportType(ReactivePowerSupportType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 150:
            // Grammar: ID=150; read/write bits=3; START (ConstantPowerFactor), START (VoltVar), START (WattVar), START (ConstantVar), START (WattCosPhi), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ConstantPowerFactor, ConstantPowerFactorType (ConstantPowerFactorType)); next=151
                    // decode: element
                    error = decode_iso20_ac_der_ConstantPowerFactorType(stream, &ReactivePowerSupportType->ConstantPowerFactor);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->ConstantPowerFactor_isUsed = 1u;
                        grammar_id = 151;
                    }
                    break;
                case 1:
                    // Event: START (VoltVar, DERCurveType (DERCurveType)); next=152
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &ReactivePowerSupportType->VoltVar);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->VoltVar_isUsed = 1u;
                        grammar_id = 152;
                    }
                    break;
                case 2:
                    // Event: START (WattVar, DERCurveType (DERCurveType)); next=153
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &ReactivePowerSupportType->WattVar);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->WattVar_isUsed = 1u;
                        grammar_id = 153;
                    }
                    break;
                case 3:
                    // Event: START (ConstantVar, ConstantVarType (ConstantVarType)); next=154
                    // decode: element
                    error = decode_iso20_ac_der_ConstantVarType(stream, &ReactivePowerSupportType->ConstantVar);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->ConstantVar_isUsed = 1u;
                        grammar_id = 154;
                    }
                    break;
                case 4:
                    // Event: START (WattCosPhi, DERCurveType (DERCurveType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &ReactivePowerSupportType->WattCosPhi);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->WattCosPhi_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 151:
            // Grammar: ID=151; read/write bits=3; START (VoltVar), START (WattVar), START (ConstantVar), START (WattCosPhi), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (VoltVar, DERCurveType (DERCurveType)); next=152
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &ReactivePowerSupportType->VoltVar);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->VoltVar_isUsed = 1u;
                        grammar_id = 152;
                    }
                    break;
                case 1:
                    // Event: START (WattVar, DERCurveType (DERCurveType)); next=153
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &ReactivePowerSupportType->WattVar);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->WattVar_isUsed = 1u;
                        grammar_id = 153;
                    }
                    break;
                case 2:
                    // Event: START (ConstantVar, ConstantVarType (ConstantVarType)); next=154
                    // decode: element
                    error = decode_iso20_ac_der_ConstantVarType(stream, &ReactivePowerSupportType->ConstantVar);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->ConstantVar_isUsed = 1u;
                        grammar_id = 154;
                    }
                    break;
                case 3:
                    // Event: START (WattCosPhi, DERCurveType (DERCurveType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &ReactivePowerSupportType->WattCosPhi);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->WattCosPhi_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 152:
            // Grammar: ID=152; read/write bits=3; START (WattVar), START (ConstantVar), START (WattCosPhi), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (WattVar, DERCurveType (DERCurveType)); next=153
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &ReactivePowerSupportType->WattVar);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->WattVar_isUsed = 1u;
                        grammar_id = 153;
                    }
                    break;
                case 1:
                    // Event: START (ConstantVar, ConstantVarType (ConstantVarType)); next=154
                    // decode: element
                    error = decode_iso20_ac_der_ConstantVarType(stream, &ReactivePowerSupportType->ConstantVar);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->ConstantVar_isUsed = 1u;
                        grammar_id = 154;
                    }
                    break;
                case 2:
                    // Event: START (WattCosPhi, DERCurveType (DERCurveType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &ReactivePowerSupportType->WattCosPhi);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->WattCosPhi_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 153:
            // Grammar: ID=153; read/write bits=2; START (ConstantVar), START (WattCosPhi), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ConstantVar, ConstantVarType (ConstantVarType)); next=154
                    // decode: element
                    error = decode_iso20_ac_der_ConstantVarType(stream, &ReactivePowerSupportType->ConstantVar);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->ConstantVar_isUsed = 1u;
                        grammar_id = 154;
                    }
                    break;
                case 1:
                    // Event: START (WattCosPhi, DERCurveType (DERCurveType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &ReactivePowerSupportType->WattCosPhi);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->WattCosPhi_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 154:
            // Grammar: ID=154; read/write bits=2; START (WattCosPhi), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (WattCosPhi, DERCurveType (DERCurveType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &ReactivePowerSupportType->WattCosPhi);
                    if (error == 0)
                    {
                        ReactivePowerSupportType->WattCosPhi_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts; type={urn:iso:std:iso:15118:-20:CommonTypes}DetailedTaxType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TaxRuleID, numericIDType (1, 1); Amount, RationalNumberType (1, 1);
static int decode_iso20_ac_der_DetailedTaxType(exi_bitstream_t* stream, struct iso20_ac_der_DetailedTaxType* DetailedTaxType) {
    int grammar_id = 155;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DetailedTaxType(DetailedTaxType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 155:
            // Grammar: ID=155; read/write bits=1; START (TaxRuleID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (TaxRuleID, numericIDType (unsignedInt)); next=156
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DetailedTaxType->TaxRuleID);
                    if (error == 0)
                    {
                        grammar_id = 156;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 156:
            // Grammar: ID=156; read/write bits=1; START (Amount)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Amount, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DetailedTaxType->Amount);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}US_FrequencyDroop; type={urn:iso:std:iso:15118:-20:AC}US_FrequencyDroopType; base type=FrequencyDroopType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Enable, boolean (0, 1); Priority, unsignedShort (0, 1); OverFrequencyDroop, US_FrequencyDroopSettingsType (0, 1); UnderFrequencyDroop, US_FrequencyDroopSettingsType (0, 1);
static int decode_iso20_ac_der_US_FrequencyDroopType(exi_bitstream_t* stream, struct iso20_ac_der_US_FrequencyDroopType* US_FrequencyDroopType) {
    int grammar_id = 157;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_US_FrequencyDroopType(US_FrequencyDroopType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 157:
            // Grammar: ID=157; read/write bits=3; START (Enable), START (Priority), START (OverFrequencyDroop), START (UnderFrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Enable, boolean (boolean)); next=158
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                US_FrequencyDroopType->Enable = value;
                                US_FrequencyDroopType->Enable_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 158;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=159
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &US_FrequencyDroopType->Priority);
                    if (error == 0)
                    {
                        US_FrequencyDroopType->Priority_isUsed = 1u;
                        grammar_id = 159;
                    }
                    break;
                case 2:
                    // Event: START (OverFrequencyDroop, US_FrequencyDroopSettingsType (US_FrequencyDroopSettingsType)); next=160
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopSettingsType(stream, &US_FrequencyDroopType->OverFrequencyDroop);
                    if (error == 0)
                    {
                        US_FrequencyDroopType->OverFrequencyDroop_isUsed = 1u;
                        grammar_id = 160;
                    }
                    break;
                case 3:
                    // Event: START (UnderFrequencyDroop, US_FrequencyDroopSettingsType (US_FrequencyDroopSettingsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopSettingsType(stream, &US_FrequencyDroopType->UnderFrequencyDroop);
                    if (error == 0)
                    {
                        US_FrequencyDroopType->UnderFrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 158:
            // Grammar: ID=158; read/write bits=3; START (Priority), START (OverFrequencyDroop), START (UnderFrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=159
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &US_FrequencyDroopType->Priority);
                    if (error == 0)
                    {
                        US_FrequencyDroopType->Priority_isUsed = 1u;
                        grammar_id = 159;
                    }
                    break;
                case 1:
                    // Event: START (OverFrequencyDroop, US_FrequencyDroopSettingsType (US_FrequencyDroopSettingsType)); next=160
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopSettingsType(stream, &US_FrequencyDroopType->OverFrequencyDroop);
                    if (error == 0)
                    {
                        US_FrequencyDroopType->OverFrequencyDroop_isUsed = 1u;
                        grammar_id = 160;
                    }
                    break;
                case 2:
                    // Event: START (UnderFrequencyDroop, US_FrequencyDroopSettingsType (US_FrequencyDroopSettingsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopSettingsType(stream, &US_FrequencyDroopType->UnderFrequencyDroop);
                    if (error == 0)
                    {
                        US_FrequencyDroopType->UnderFrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 159:
            // Grammar: ID=159; read/write bits=2; START (OverFrequencyDroop), START (UnderFrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OverFrequencyDroop, US_FrequencyDroopSettingsType (US_FrequencyDroopSettingsType)); next=160
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopSettingsType(stream, &US_FrequencyDroopType->OverFrequencyDroop);
                    if (error == 0)
                    {
                        US_FrequencyDroopType->OverFrequencyDroop_isUsed = 1u;
                        grammar_id = 160;
                    }
                    break;
                case 1:
                    // Event: START (UnderFrequencyDroop, US_FrequencyDroopSettingsType (US_FrequencyDroopSettingsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopSettingsType(stream, &US_FrequencyDroopType->UnderFrequencyDroop);
                    if (error == 0)
                    {
                        US_FrequencyDroopType->UnderFrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 160:
            // Grammar: ID=160; read/write bits=2; START (UnderFrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (UnderFrequencyDroop, US_FrequencyDroopSettingsType (US_FrequencyDroopSettingsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopSettingsType(stream, &US_FrequencyDroopType->UnderFrequencyDroop);
                    if (error == 0)
                    {
                        US_FrequencyDroopType->UnderFrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}EU_FrequencyDroop; type={urn:iso:std:iso:15118:-20:AC}EU_FrequencyDroopType; base type=FrequencyDroopType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Enable, boolean (0, 1); Priority, unsignedShort (0, 1); OverFrequencyDroop, EU_FrequencyDroopSettingsType (0, 1); UnderFrequencyDroop, EU_FrequencyDroopSettingsType (0, 1);
static int decode_iso20_ac_der_EU_FrequencyDroopType(exi_bitstream_t* stream, struct iso20_ac_der_EU_FrequencyDroopType* EU_FrequencyDroopType) {
    int grammar_id = 161;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_EU_FrequencyDroopType(EU_FrequencyDroopType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 161:
            // Grammar: ID=161; read/write bits=3; START (Enable), START (Priority), START (OverFrequencyDroop), START (UnderFrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Enable, boolean (boolean)); next=162
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                EU_FrequencyDroopType->Enable = value;
                                EU_FrequencyDroopType->Enable_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 162;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=163
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &EU_FrequencyDroopType->Priority);
                    if (error == 0)
                    {
                        EU_FrequencyDroopType->Priority_isUsed = 1u;
                        grammar_id = 163;
                    }
                    break;
                case 2:
                    // Event: START (OverFrequencyDroop, EU_FrequencyDroopSettingsType (EU_FrequencyDroopSettingsType)); next=164
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopSettingsType(stream, &EU_FrequencyDroopType->OverFrequencyDroop);
                    if (error == 0)
                    {
                        EU_FrequencyDroopType->OverFrequencyDroop_isUsed = 1u;
                        grammar_id = 164;
                    }
                    break;
                case 3:
                    // Event: START (UnderFrequencyDroop, EU_FrequencyDroopSettingsType (EU_FrequencyDroopSettingsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopSettingsType(stream, &EU_FrequencyDroopType->UnderFrequencyDroop);
                    if (error == 0)
                    {
                        EU_FrequencyDroopType->UnderFrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 162:
            // Grammar: ID=162; read/write bits=3; START (Priority), START (OverFrequencyDroop), START (UnderFrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=163
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &EU_FrequencyDroopType->Priority);
                    if (error == 0)
                    {
                        EU_FrequencyDroopType->Priority_isUsed = 1u;
                        grammar_id = 163;
                    }
                    break;
                case 1:
                    // Event: START (OverFrequencyDroop, EU_FrequencyDroopSettingsType (EU_FrequencyDroopSettingsType)); next=164
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopSettingsType(stream, &EU_FrequencyDroopType->OverFrequencyDroop);
                    if (error == 0)
                    {
                        EU_FrequencyDroopType->OverFrequencyDroop_isUsed = 1u;
                        grammar_id = 164;
                    }
                    break;
                case 2:
                    // Event: START (UnderFrequencyDroop, EU_FrequencyDroopSettingsType (EU_FrequencyDroopSettingsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopSettingsType(stream, &EU_FrequencyDroopType->UnderFrequencyDroop);
                    if (error == 0)
                    {
                        EU_FrequencyDroopType->UnderFrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 163:
            // Grammar: ID=163; read/write bits=2; START (OverFrequencyDroop), START (UnderFrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OverFrequencyDroop, EU_FrequencyDroopSettingsType (EU_FrequencyDroopSettingsType)); next=164
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopSettingsType(stream, &EU_FrequencyDroopType->OverFrequencyDroop);
                    if (error == 0)
                    {
                        EU_FrequencyDroopType->OverFrequencyDroop_isUsed = 1u;
                        grammar_id = 164;
                    }
                    break;
                case 1:
                    // Event: START (UnderFrequencyDroop, EU_FrequencyDroopSettingsType (EU_FrequencyDroopSettingsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopSettingsType(stream, &EU_FrequencyDroopType->UnderFrequencyDroop);
                    if (error == 0)
                    {
                        EU_FrequencyDroopType->UnderFrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 164:
            // Grammar: ID=164; read/write bits=2; START (UnderFrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (UnderFrequencyDroop, EU_FrequencyDroopSettingsType (EU_FrequencyDroopSettingsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopSettingsType(stream, &EU_FrequencyDroopType->UnderFrequencyDroop);
                    if (error == 0)
                    {
                        EU_FrequencyDroopType->UnderFrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}FrequencyDroop; type={urn:iso:std:iso:15118:-20:AC}FrequencyDroopType; base type=; content type=ELEMENT-ONLY;
//          abstract=True; final=False;
// Particle: Enable, boolean (0, 1); Priority, unsignedShort (0, 1); US_FrequencyDroop, US_FrequencyDroopType (0, 1); EU_FrequencyDroop, EU_FrequencyDroopType (0, 1);
static int decode_iso20_ac_der_FrequencyDroopType(exi_bitstream_t* stream, struct iso20_ac_der_FrequencyDroopType* FrequencyDroopType) {
    int grammar_id = 165;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_FrequencyDroopType(FrequencyDroopType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 165:
            // Grammar: ID=165; read/write bits=3; START (Enable), START (Priority), START (US_FrequencyDroop), START (EU_FrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Enable, boolean (boolean)); next=166
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                FrequencyDroopType->Enable = value;
                                FrequencyDroopType->Enable_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 166;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=167
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &FrequencyDroopType->Priority);
                    if (error == 0)
                    {
                        FrequencyDroopType->Priority_isUsed = 1u;
                        grammar_id = 167;
                    }
                    break;
                case 2:
                    // Event: START (US_FrequencyDroop, US_FrequencyDroopType (FrequencyDroopType)); next=168
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopType(stream, &FrequencyDroopType->US_FrequencyDroop);
                    if (error == 0)
                    {
                        FrequencyDroopType->US_FrequencyDroop_isUsed = 1u;
                        grammar_id = 168;
                    }
                    break;
                case 3:
                    // Event: START (EU_FrequencyDroop, EU_FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopType(stream, &FrequencyDroopType->EU_FrequencyDroop);
                    if (error == 0)
                    {
                        FrequencyDroopType->EU_FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 166:
            // Grammar: ID=166; read/write bits=3; START (Priority), START (US_FrequencyDroop), START (EU_FrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Priority, unsignedShort (unsignedInt)); next=167
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &FrequencyDroopType->Priority);
                    if (error == 0)
                    {
                        FrequencyDroopType->Priority_isUsed = 1u;
                        grammar_id = 167;
                    }
                    break;
                case 1:
                    // Event: START (US_FrequencyDroop, US_FrequencyDroopType (FrequencyDroopType)); next=168
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopType(stream, &FrequencyDroopType->US_FrequencyDroop);
                    if (error == 0)
                    {
                        FrequencyDroopType->US_FrequencyDroop_isUsed = 1u;
                        grammar_id = 168;
                    }
                    break;
                case 2:
                    // Event: START (EU_FrequencyDroop, EU_FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopType(stream, &FrequencyDroopType->EU_FrequencyDroop);
                    if (error == 0)
                    {
                        FrequencyDroopType->EU_FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 167:
            // Grammar: ID=167; read/write bits=2; START (US_FrequencyDroop), START (EU_FrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (US_FrequencyDroop, US_FrequencyDroopType (FrequencyDroopType)); next=168
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopType(stream, &FrequencyDroopType->US_FrequencyDroop);
                    if (error == 0)
                    {
                        FrequencyDroopType->US_FrequencyDroop_isUsed = 1u;
                        grammar_id = 168;
                    }
                    break;
                case 1:
                    // Event: START (EU_FrequencyDroop, EU_FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopType(stream, &FrequencyDroopType->EU_FrequencyDroop);
                    if (error == 0)
                    {
                        FrequencyDroopType->EU_FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 168:
            // Grammar: ID=168; read/write bits=2; START (EU_FrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EU_FrequencyDroop, EU_FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopType(stream, &FrequencyDroopType->EU_FrequencyDroop);
                    if (error == 0)
                    {
                        FrequencyDroopType->EU_FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}ActivePowerSupport; type={urn:iso:std:iso:15118:-20:AC}ActivePowerSupportType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: FrequencyWatt, FrequencyWattCurveType (0, 1); VoltWatt, DERCurveType (0, 1); LimitMaxDischargePower, LimitMaxDischargePowerType (0, 1); EU_FrequencyDroop, EU_FrequencyDroopType (0, 1); FrequencyDroop, FrequencyDroopType (0, 1); US_FrequencyDroop, US_FrequencyDroopType (0, 1);
static int decode_iso20_ac_der_ActivePowerSupportType(exi_bitstream_t* stream, struct iso20_ac_der_ActivePowerSupportType* ActivePowerSupportType) {
    int grammar_id = 169;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_ActivePowerSupportType(ActivePowerSupportType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 169:
            // Grammar: ID=169; read/write bits=3; START (FrequencyWatt), START (VoltWatt), START (LimitMaxDischargePower), START (EU_FrequencyDroop), START (FrequencyDroop), START (US_FrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (FrequencyWatt, FrequencyWattCurveType (FrequencyWattCurveType)); next=170
                    // decode: element
                    error = decode_iso20_ac_der_FrequencyWattCurveType(stream, &ActivePowerSupportType->FrequencyWatt);
                    if (error == 0)
                    {
                        ActivePowerSupportType->FrequencyWatt_isUsed = 1u;
                        grammar_id = 170;
                    }
                    break;
                case 1:
                    // Event: START (VoltWatt, DERCurveType (DERCurveType)); next=171
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &ActivePowerSupportType->VoltWatt);
                    if (error == 0)
                    {
                        ActivePowerSupportType->VoltWatt_isUsed = 1u;
                        grammar_id = 171;
                    }
                    break;
                case 2:
                    // Event: START (LimitMaxDischargePower, LimitMaxDischargePowerType (LimitMaxDischargePowerType)); next=172
                    // decode: element
                    error = decode_iso20_ac_der_LimitMaxDischargePowerType(stream, &ActivePowerSupportType->LimitMaxDischargePower);
                    if (error == 0)
                    {
                        ActivePowerSupportType->LimitMaxDischargePower_isUsed = 1u;
                        grammar_id = 172;
                    }
                    break;
                case 3:
                    // Event: START (EU_FrequencyDroop, EU_FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopType(stream, &ActivePowerSupportType->EU_FrequencyDroop);
                    if (error == 0)
                    {
                        ActivePowerSupportType->EU_FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: START (FrequencyDroop, FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_FrequencyDroopType(stream, &ActivePowerSupportType->FrequencyDroop);
                    if (error == 0)
                    {
                        ActivePowerSupportType->FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: START (US_FrequencyDroop, US_FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopType(stream, &ActivePowerSupportType->US_FrequencyDroop);
                    if (error == 0)
                    {
                        ActivePowerSupportType->US_FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 170:
            // Grammar: ID=170; read/write bits=3; START (VoltWatt), START (LimitMaxDischargePower), START (EU_FrequencyDroop), START (FrequencyDroop), START (US_FrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (VoltWatt, DERCurveType (DERCurveType)); next=171
                    // decode: element
                    error = decode_iso20_ac_der_DERCurveType(stream, &ActivePowerSupportType->VoltWatt);
                    if (error == 0)
                    {
                        ActivePowerSupportType->VoltWatt_isUsed = 1u;
                        grammar_id = 171;
                    }
                    break;
                case 1:
                    // Event: START (LimitMaxDischargePower, LimitMaxDischargePowerType (LimitMaxDischargePowerType)); next=172
                    // decode: element
                    error = decode_iso20_ac_der_LimitMaxDischargePowerType(stream, &ActivePowerSupportType->LimitMaxDischargePower);
                    if (error == 0)
                    {
                        ActivePowerSupportType->LimitMaxDischargePower_isUsed = 1u;
                        grammar_id = 172;
                    }
                    break;
                case 2:
                    // Event: START (EU_FrequencyDroop, EU_FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopType(stream, &ActivePowerSupportType->EU_FrequencyDroop);
                    if (error == 0)
                    {
                        ActivePowerSupportType->EU_FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: START (FrequencyDroop, FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_FrequencyDroopType(stream, &ActivePowerSupportType->FrequencyDroop);
                    if (error == 0)
                    {
                        ActivePowerSupportType->FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: START (US_FrequencyDroop, US_FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopType(stream, &ActivePowerSupportType->US_FrequencyDroop);
                    if (error == 0)
                    {
                        ActivePowerSupportType->US_FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 171:
            // Grammar: ID=171; read/write bits=3; START (LimitMaxDischargePower), START (EU_FrequencyDroop), START (FrequencyDroop), START (US_FrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (LimitMaxDischargePower, LimitMaxDischargePowerType (LimitMaxDischargePowerType)); next=172
                    // decode: element
                    error = decode_iso20_ac_der_LimitMaxDischargePowerType(stream, &ActivePowerSupportType->LimitMaxDischargePower);
                    if (error == 0)
                    {
                        ActivePowerSupportType->LimitMaxDischargePower_isUsed = 1u;
                        grammar_id = 172;
                    }
                    break;
                case 1:
                    // Event: START (EU_FrequencyDroop, EU_FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopType(stream, &ActivePowerSupportType->EU_FrequencyDroop);
                    if (error == 0)
                    {
                        ActivePowerSupportType->EU_FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: START (FrequencyDroop, FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_FrequencyDroopType(stream, &ActivePowerSupportType->FrequencyDroop);
                    if (error == 0)
                    {
                        ActivePowerSupportType->FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: START (US_FrequencyDroop, US_FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopType(stream, &ActivePowerSupportType->US_FrequencyDroop);
                    if (error == 0)
                    {
                        ActivePowerSupportType->US_FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 172:
            // Grammar: ID=172; read/write bits=3; START (EU_FrequencyDroop), START (FrequencyDroop), START (US_FrequencyDroop), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EU_FrequencyDroop, EU_FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EU_FrequencyDroopType(stream, &ActivePowerSupportType->EU_FrequencyDroop);
                    if (error == 0)
                    {
                        ActivePowerSupportType->EU_FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: START (FrequencyDroop, FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_FrequencyDroopType(stream, &ActivePowerSupportType->FrequencyDroop);
                    if (error == 0)
                    {
                        ActivePowerSupportType->FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: START (US_FrequencyDroop, US_FrequencyDroopType (FrequencyDroopType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_US_FrequencyDroopType(stream, &ActivePowerSupportType->US_FrequencyDroop);
                    if (error == 0)
                    {
                        ActivePowerSupportType->US_FrequencyDroop_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}Header; type={urn:iso:std:iso:15118:-20:CommonTypes}MessageHeaderType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SessionID, sessionIDType (1, 1); TimeStamp, unsignedLong (1, 1); Signature, SignatureType (0, 1);
static int decode_iso20_ac_der_MessageHeaderType(exi_bitstream_t* stream, struct iso20_ac_der_MessageHeaderType* MessageHeaderType) {
    int grammar_id = 173;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_MessageHeaderType(MessageHeaderType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 173:
            // Grammar: ID=173; read/write bits=1; START (SessionID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (SessionID, sessionIDType (hexBinary)); next=174
                    // decode exi type: hexBinary
                    error = decode_exi_type_hex_binary(stream, &MessageHeaderType->SessionID.bytesLen, &MessageHeaderType->SessionID.bytes[0], iso20_ac_der_sessionIDType_BYTES_SIZE);
                    if (error == 0)
                    {
                        grammar_id = 174;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 174:
            // Grammar: ID=174; read/write bits=1; START (TimeStamp)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (TimeStamp, unsignedLong (nonNegativeInteger)); next=175
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MessageHeaderType->TimeStamp);
                    if (error == 0)
                    {
                        grammar_id = 175;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 175:
            // Grammar: ID=175; read/write bits=2; START (Signature), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Signature, SignatureType (SignatureType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_SignatureType(stream, &MessageHeaderType->Signature);
                    if (error == 0)
                    {
                        MessageHeaderType->Signature_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureProperty; type={http://www.w3.org/2000/09/xmldsig#}SignaturePropertyType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: Id, ID (0, 1); Target, anyURI (1, 1); ANY, anyType (0, 1);
static int decode_iso20_ac_der_SignaturePropertyType(exi_bitstream_t* stream, struct iso20_ac_der_SignaturePropertyType* SignaturePropertyType) {
    int grammar_id = 176;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_SignaturePropertyType(SignaturePropertyType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 176:
            // Grammar: ID=176; read/write bits=2; START (Id), START (Target)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Id, ID (NCName)); next=177
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignaturePropertyType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignaturePropertyType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignaturePropertyType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignaturePropertyType->Id.charactersLen, SignaturePropertyType->Id.characters, iso20_ac_der_Id_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SignaturePropertyType->Id_isUsed = 1u;
                    grammar_id = 177;
                    break;
                case 1:
                    // Event: START (Target, anyURI (anyURI)); next=178
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignaturePropertyType->Target.charactersLen);
                    if (error == 0)
                    {
                        if (SignaturePropertyType->Target.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignaturePropertyType->Target.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignaturePropertyType->Target.charactersLen, SignaturePropertyType->Target.characters, iso20_ac_der_Target_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 178;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 177:
            // Grammar: ID=177; read/write bits=1; START (Target)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Target, anyURI (anyURI)); next=178
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignaturePropertyType->Target.charactersLen);
                    if (error == 0)
                    {
                        if (SignaturePropertyType->Target.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignaturePropertyType->Target.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignaturePropertyType->Target.charactersLen, SignaturePropertyType->Target.characters, iso20_ac_der_Target_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 178;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 178:
            // Grammar: ID=178; read/write bits=1; START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SignaturePropertyType->ANY.bytesLen, &SignaturePropertyType->ANY.bytes[0], iso20_ac_der_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        SignaturePropertyType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}AC_CPDReqEnergyTransferMode; type={urn:iso:std:iso:15118:-20:AC}AC_CPDReqEnergyTransferModeType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVMaximumChargePower, RationalNumberType (1, 1); EVMaximumChargePower_L2, RationalNumberType (0, 1); EVMaximumChargePower_L3, RationalNumberType (0, 1); EVMinimumChargePower, RationalNumberType (1, 1); EVMinimumChargePower_L2, RationalNumberType (0, 1); EVMinimumChargePower_L3, RationalNumberType (0, 1);
static int decode_iso20_ac_der_AC_CPDReqEnergyTransferModeType(exi_bitstream_t* stream, struct iso20_ac_der_AC_CPDReqEnergyTransferModeType* AC_CPDReqEnergyTransferModeType) {
    int grammar_id = 179;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_AC_CPDReqEnergyTransferModeType(AC_CPDReqEnergyTransferModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 179:
            // Grammar: ID=179; read/write bits=1; START (EVMaximumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=180
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDReqEnergyTransferModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 180;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 180:
            // Grammar: ID=180; read/write bits=2; START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=181
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 181;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=182
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 182;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=183
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDReqEnergyTransferModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 183;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 181:
            // Grammar: ID=181; read/write bits=2; START (EVMaximumChargePower_L3), START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=182
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 182;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=183
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDReqEnergyTransferModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 183;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 182:
            // Grammar: ID=182; read/write bits=1; START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=183
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDReqEnergyTransferModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 183;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 183:
            // Grammar: ID=183; read/write bits=2; START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=184
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 184;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 184:
            // Grammar: ID=184; read/write bits=2; START (EVMinimumChargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}DisplayParameters; type={urn:iso:std:iso:15118:-20:CommonTypes}DisplayParametersType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: PresentSOC, percentValueType (0, 1); MinimumSOC, percentValueType (0, 1); TargetSOC, percentValueType (0, 1); MaximumSOC, percentValueType (0, 1); RemainingTimeToMinimumSOC, unsignedInt (0, 1); RemainingTimeToTargetSOC, unsignedInt (0, 1); RemainingTimeToMaximumSOC, unsignedInt (0, 1); ChargingComplete, boolean (0, 1); BatteryEnergyCapacity, RationalNumberType (0, 1); InletHot, boolean (0, 1);
static int decode_iso20_ac_der_DisplayParametersType(exi_bitstream_t* stream, struct iso20_ac_der_DisplayParametersType* DisplayParametersType) {
    int grammar_id = 185;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DisplayParametersType(DisplayParametersType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 185:
            // Grammar: ID=185; read/write bits=4; START (PresentSOC), START (MinimumSOC), START (TargetSOC), START (MaximumSOC), START (RemainingTimeToMinimumSOC), START (RemainingTimeToTargetSOC), START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (PresentSOC, percentValueType (byte)); next=186
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->PresentSOC = (int8_t)value;
                                DisplayParametersType->PresentSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 186;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (MinimumSOC, percentValueType (byte)); next=187
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->MinimumSOC = (int8_t)value;
                                DisplayParametersType->MinimumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 187;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (TargetSOC, percentValueType (byte)); next=188
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->TargetSOC = (int8_t)value;
                                DisplayParametersType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 188;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 3:
                    // Event: START (MaximumSOC, percentValueType (byte)); next=189
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->MaximumSOC = (int8_t)value;
                                DisplayParametersType->MaximumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 189;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 4:
                    // Event: START (RemainingTimeToMinimumSOC, unsignedInt (unsignedLong)); next=190
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToMinimumSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToMinimumSOC_isUsed = 1u;
                        grammar_id = 190;
                    }
                    break;
                case 5:
                    // Event: START (RemainingTimeToTargetSOC, unsignedInt (unsignedLong)); next=191
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToTargetSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToTargetSOC_isUsed = 1u;
                        grammar_id = 191;
                    }
                    break;
                case 6:
                    // Event: START (RemainingTimeToMaximumSOC, unsignedInt (unsignedLong)); next=192
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToMaximumSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToMaximumSOC_isUsed = 1u;
                        grammar_id = 192;
                    }
                    break;
                case 7:
                    // Event: START (ChargingComplete, boolean (boolean)); next=193
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->ChargingComplete = value;
                                DisplayParametersType->ChargingComplete_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 193;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 8:
                    // Event: START (BatteryEnergyCapacity, RationalNumberType (RationalNumberType)); next=194
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == 0)
                    {
                        DisplayParametersType->BatteryEnergyCapacity_isUsed = 1u;
                        grammar_id = 194;
                    }
                    break;
                case 9:
                    // Event: START (InletHot, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->InletHot = value;
                                DisplayParametersType->InletHot_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 10:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 186:
            // Grammar: ID=186; read/write bits=4; START (MinimumSOC), START (TargetSOC), START (MaximumSOC), START (RemainingTimeToMinimumSOC), START (RemainingTimeToTargetSOC), START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MinimumSOC, percentValueType (byte)); next=187
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->MinimumSOC = (int8_t)value;
                                DisplayParametersType->MinimumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 187;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (TargetSOC, percentValueType (byte)); next=188
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->TargetSOC = (int8_t)value;
                                DisplayParametersType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 188;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (MaximumSOC, percentValueType (byte)); next=189
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->MaximumSOC = (int8_t)value;
                                DisplayParametersType->MaximumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 189;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 3:
                    // Event: START (RemainingTimeToMinimumSOC, unsignedInt (unsignedLong)); next=190
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToMinimumSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToMinimumSOC_isUsed = 1u;
                        grammar_id = 190;
                    }
                    break;
                case 4:
                    // Event: START (RemainingTimeToTargetSOC, unsignedInt (unsignedLong)); next=191
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToTargetSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToTargetSOC_isUsed = 1u;
                        grammar_id = 191;
                    }
                    break;
                case 5:
                    // Event: START (RemainingTimeToMaximumSOC, unsignedInt (unsignedLong)); next=192
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToMaximumSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToMaximumSOC_isUsed = 1u;
                        grammar_id = 192;
                    }
                    break;
                case 6:
                    // Event: START (ChargingComplete, boolean (boolean)); next=193
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->ChargingComplete = value;
                                DisplayParametersType->ChargingComplete_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 193;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 7:
                    // Event: START (BatteryEnergyCapacity, RationalNumberType (RationalNumberType)); next=194
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == 0)
                    {
                        DisplayParametersType->BatteryEnergyCapacity_isUsed = 1u;
                        grammar_id = 194;
                    }
                    break;
                case 8:
                    // Event: START (InletHot, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->InletHot = value;
                                DisplayParametersType->InletHot_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 9:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 187:
            // Grammar: ID=187; read/write bits=4; START (TargetSOC), START (MaximumSOC), START (RemainingTimeToMinimumSOC), START (RemainingTimeToTargetSOC), START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (TargetSOC, percentValueType (byte)); next=188
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->TargetSOC = (int8_t)value;
                                DisplayParametersType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 188;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (MaximumSOC, percentValueType (byte)); next=189
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->MaximumSOC = (int8_t)value;
                                DisplayParametersType->MaximumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 189;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (RemainingTimeToMinimumSOC, unsignedInt (unsignedLong)); next=190
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToMinimumSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToMinimumSOC_isUsed = 1u;
                        grammar_id = 190;
                    }
                    break;
                case 3:
                    // Event: START (RemainingTimeToTargetSOC, unsignedInt (unsignedLong)); next=191
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToTargetSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToTargetSOC_isUsed = 1u;
                        grammar_id = 191;
                    }
                    break;
                case 4:
                    // Event: START (RemainingTimeToMaximumSOC, unsignedInt (unsignedLong)); next=192
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToMaximumSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToMaximumSOC_isUsed = 1u;
                        grammar_id = 192;
                    }
                    break;
                case 5:
                    // Event: START (ChargingComplete, boolean (boolean)); next=193
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->ChargingComplete = value;
                                DisplayParametersType->ChargingComplete_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 193;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 6:
                    // Event: START (BatteryEnergyCapacity, RationalNumberType (RationalNumberType)); next=194
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == 0)
                    {
                        DisplayParametersType->BatteryEnergyCapacity_isUsed = 1u;
                        grammar_id = 194;
                    }
                    break;
                case 7:
                    // Event: START (InletHot, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->InletHot = value;
                                DisplayParametersType->InletHot_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 8:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 188:
            // Grammar: ID=188; read/write bits=4; START (MaximumSOC), START (RemainingTimeToMinimumSOC), START (RemainingTimeToTargetSOC), START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MaximumSOC, percentValueType (byte)); next=189
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->MaximumSOC = (int8_t)value;
                                DisplayParametersType->MaximumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 189;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (RemainingTimeToMinimumSOC, unsignedInt (unsignedLong)); next=190
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToMinimumSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToMinimumSOC_isUsed = 1u;
                        grammar_id = 190;
                    }
                    break;
                case 2:
                    // Event: START (RemainingTimeToTargetSOC, unsignedInt (unsignedLong)); next=191
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToTargetSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToTargetSOC_isUsed = 1u;
                        grammar_id = 191;
                    }
                    break;
                case 3:
                    // Event: START (RemainingTimeToMaximumSOC, unsignedInt (unsignedLong)); next=192
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToMaximumSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToMaximumSOC_isUsed = 1u;
                        grammar_id = 192;
                    }
                    break;
                case 4:
                    // Event: START (ChargingComplete, boolean (boolean)); next=193
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->ChargingComplete = value;
                                DisplayParametersType->ChargingComplete_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 193;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 5:
                    // Event: START (BatteryEnergyCapacity, RationalNumberType (RationalNumberType)); next=194
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == 0)
                    {
                        DisplayParametersType->BatteryEnergyCapacity_isUsed = 1u;
                        grammar_id = 194;
                    }
                    break;
                case 6:
                    // Event: START (InletHot, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->InletHot = value;
                                DisplayParametersType->InletHot_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 7:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 189:
            // Grammar: ID=189; read/write bits=3; START (RemainingTimeToMinimumSOC), START (RemainingTimeToTargetSOC), START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (RemainingTimeToMinimumSOC, unsignedInt (unsignedLong)); next=190
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToMinimumSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToMinimumSOC_isUsed = 1u;
                        grammar_id = 190;
                    }
                    break;
                case 1:
                    // Event: START (RemainingTimeToTargetSOC, unsignedInt (unsignedLong)); next=191
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToTargetSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToTargetSOC_isUsed = 1u;
                        grammar_id = 191;
                    }
                    break;
                case 2:
                    // Event: START (RemainingTimeToMaximumSOC, unsignedInt (unsignedLong)); next=192
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToMaximumSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToMaximumSOC_isUsed = 1u;
                        grammar_id = 192;
                    }
                    break;
                case 3:
                    // Event: START (ChargingComplete, boolean (boolean)); next=193
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->ChargingComplete = value;
                                DisplayParametersType->ChargingComplete_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 193;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 4:
                    // Event: START (BatteryEnergyCapacity, RationalNumberType (RationalNumberType)); next=194
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == 0)
                    {
                        DisplayParametersType->BatteryEnergyCapacity_isUsed = 1u;
                        grammar_id = 194;
                    }
                    break;
                case 5:
                    // Event: START (InletHot, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->InletHot = value;
                                DisplayParametersType->InletHot_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 6:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 190:
            // Grammar: ID=190; read/write bits=3; START (RemainingTimeToTargetSOC), START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (RemainingTimeToTargetSOC, unsignedInt (unsignedLong)); next=191
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToTargetSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToTargetSOC_isUsed = 1u;
                        grammar_id = 191;
                    }
                    break;
                case 1:
                    // Event: START (RemainingTimeToMaximumSOC, unsignedInt (unsignedLong)); next=192
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToMaximumSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToMaximumSOC_isUsed = 1u;
                        grammar_id = 192;
                    }
                    break;
                case 2:
                    // Event: START (ChargingComplete, boolean (boolean)); next=193
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->ChargingComplete = value;
                                DisplayParametersType->ChargingComplete_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 193;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 3:
                    // Event: START (BatteryEnergyCapacity, RationalNumberType (RationalNumberType)); next=194
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == 0)
                    {
                        DisplayParametersType->BatteryEnergyCapacity_isUsed = 1u;
                        grammar_id = 194;
                    }
                    break;
                case 4:
                    // Event: START (InletHot, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->InletHot = value;
                                DisplayParametersType->InletHot_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 191:
            // Grammar: ID=191; read/write bits=3; START (RemainingTimeToMaximumSOC), START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (RemainingTimeToMaximumSOC, unsignedInt (unsignedLong)); next=192
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DisplayParametersType->RemainingTimeToMaximumSOC);
                    if (error == 0)
                    {
                        DisplayParametersType->RemainingTimeToMaximumSOC_isUsed = 1u;
                        grammar_id = 192;
                    }
                    break;
                case 1:
                    // Event: START (ChargingComplete, boolean (boolean)); next=193
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->ChargingComplete = value;
                                DisplayParametersType->ChargingComplete_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 193;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (BatteryEnergyCapacity, RationalNumberType (RationalNumberType)); next=194
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == 0)
                    {
                        DisplayParametersType->BatteryEnergyCapacity_isUsed = 1u;
                        grammar_id = 194;
                    }
                    break;
                case 3:
                    // Event: START (InletHot, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->InletHot = value;
                                DisplayParametersType->InletHot_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 192:
            // Grammar: ID=192; read/write bits=3; START (ChargingComplete), START (BatteryEnergyCapacity), START (InletHot), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ChargingComplete, boolean (boolean)); next=193
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->ChargingComplete = value;
                                DisplayParametersType->ChargingComplete_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 193;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (BatteryEnergyCapacity, RationalNumberType (RationalNumberType)); next=194
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == 0)
                    {
                        DisplayParametersType->BatteryEnergyCapacity_isUsed = 1u;
                        grammar_id = 194;
                    }
                    break;
                case 2:
                    // Event: START (InletHot, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->InletHot = value;
                                DisplayParametersType->InletHot_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 193:
            // Grammar: ID=193; read/write bits=2; START (BatteryEnergyCapacity), START (InletHot), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (BatteryEnergyCapacity, RationalNumberType (RationalNumberType)); next=194
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DisplayParametersType->BatteryEnergyCapacity);
                    if (error == 0)
                    {
                        DisplayParametersType->BatteryEnergyCapacity_isUsed = 1u;
                        grammar_id = 194;
                    }
                    break;
                case 1:
                    // Event: START (InletHot, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->InletHot = value;
                                DisplayParametersType->InletHot_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 194:
            // Grammar: ID=194; read/write bits=2; START (InletHot), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (InletHot, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DisplayParametersType->InletHot = value;
                                DisplayParametersType->InletHot_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}AC_CPDResEnergyTransferMode; type={urn:iso:std:iso:15118:-20:AC}AC_CPDResEnergyTransferModeType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVSEMaximumChargePower, RationalNumberType (1, 1); EVSEMaximumChargePower_L2, RationalNumberType (0, 1); EVSEMaximumChargePower_L3, RationalNumberType (0, 1); EVSEMinimumChargePower, RationalNumberType (1, 1); EVSEMinimumChargePower_L2, RationalNumberType (0, 1); EVSEMinimumChargePower_L3, RationalNumberType (0, 1); EVSENominalFrequency, RationalNumberType (1, 1); MaximumPowerAsymmetry, RationalNumberType (0, 1); EVSEPowerRampLimitation, RationalNumberType (0, 1); EVSEPresentActivePower, RationalNumberType (0, 1); EVSEPresentActivePower_L2, RationalNumberType (0, 1); EVSEPresentActivePower_L3, RationalNumberType (0, 1);
static int decode_iso20_ac_der_AC_CPDResEnergyTransferModeType(exi_bitstream_t* stream, struct iso20_ac_der_AC_CPDResEnergyTransferModeType* AC_CPDResEnergyTransferModeType) {
    int grammar_id = 195;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_AC_CPDResEnergyTransferModeType(AC_CPDResEnergyTransferModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 195:
            // Grammar: ID=195; read/write bits=1; START (EVSEMaximumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumChargePower, RationalNumberType (RationalNumberType)); next=196
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 196;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 196:
            // Grammar: ID=196; read/write bits=2; START (EVSEMaximumChargePower_L2), START (EVSEMaximumChargePower_L3), START (EVSEMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=197
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L2);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 197;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=198
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L3);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 198;
                    }
                    break;
                case 2:
                    // Event: START (EVSEMinimumChargePower, RationalNumberType (RationalNumberType)); next=199
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 199;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 197:
            // Grammar: ID=197; read/write bits=2; START (EVSEMaximumChargePower_L3), START (EVSEMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=198
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L3);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 198;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMinimumChargePower, RationalNumberType (RationalNumberType)); next=199
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 199;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 198:
            // Grammar: ID=198; read/write bits=1; START (EVSEMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMinimumChargePower, RationalNumberType (RationalNumberType)); next=199
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 199;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 199:
            // Grammar: ID=199; read/write bits=2; START (EVSEMinimumChargePower_L2), START (EVSEMinimumChargePower_L3), START (EVSENominalFrequency)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=200
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L2);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 200;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=201
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L3);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 201;
                    }
                    break;
                case 2:
                    // Event: START (EVSENominalFrequency, RationalNumberType (RationalNumberType)); next=202
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSENominalFrequency);
                    if (error == 0)
                    {
                        grammar_id = 202;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 200:
            // Grammar: ID=200; read/write bits=2; START (EVSEMinimumChargePower_L3), START (EVSENominalFrequency)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=201
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L3);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 201;
                    }
                    break;
                case 1:
                    // Event: START (EVSENominalFrequency, RationalNumberType (RationalNumberType)); next=202
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSENominalFrequency);
                    if (error == 0)
                    {
                        grammar_id = 202;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 201:
            // Grammar: ID=201; read/write bits=1; START (EVSENominalFrequency)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSENominalFrequency, RationalNumberType (RationalNumberType)); next=202
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSENominalFrequency);
                    if (error == 0)
                    {
                        grammar_id = 202;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 202:
            // Grammar: ID=202; read/write bits=3; START (MaximumPowerAsymmetry), START (EVSEPowerRampLimitation), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MaximumPowerAsymmetry, RationalNumberType (RationalNumberType)); next=203
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->MaximumPowerAsymmetry);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->MaximumPowerAsymmetry_isUsed = 1u;
                        grammar_id = 203;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPowerRampLimitation, RationalNumberType (RationalNumberType)); next=204
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPowerRampLimitation);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPowerRampLimitation_isUsed = 1u;
                        grammar_id = 204;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=205
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 205;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=206
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 206;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 203:
            // Grammar: ID=203; read/write bits=3; START (EVSEPowerRampLimitation), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPowerRampLimitation, RationalNumberType (RationalNumberType)); next=204
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPowerRampLimitation);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPowerRampLimitation_isUsed = 1u;
                        grammar_id = 204;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=205
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 205;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=206
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 206;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 204:
            // Grammar: ID=204; read/write bits=3; START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=205
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 205;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=206
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 206;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 205:
            // Grammar: ID=205; read/write bits=2; START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=206
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 206;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 206:
            // Grammar: ID=206; read/write bits=2; START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}EVSEStatus; type={urn:iso:std:iso:15118:-20:CommonTypes}EVSEStatusType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: NotificationMaxDelay, unsignedShort (1, 1); EVSENotification, evseNotificationType (1, 1);
static int decode_iso20_ac_der_EVSEStatusType(exi_bitstream_t* stream, struct iso20_ac_der_EVSEStatusType* EVSEStatusType) {
    int grammar_id = 207;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_EVSEStatusType(EVSEStatusType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 207:
            // Grammar: ID=207; read/write bits=1; START (NotificationMaxDelay)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (NotificationMaxDelay, unsignedShort (unsignedInt)); next=208
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &EVSEStatusType->NotificationMaxDelay);
                    if (error == 0)
                    {
                        grammar_id = 208;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 208:
            // Grammar: ID=208; read/write bits=1; START (EVSENotification)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSENotification, evseNotificationType (string)); next=2
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                            if (error == 0)
                            {
                                EVSEStatusType->EVSENotification = (iso20_ac_der_evseNotificationType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}Scheduled_AC_CLReqControlMode; type={urn:iso:std:iso:15118:-20:AC}Scheduled_AC_CLReqControlModeType; base type=Scheduled_CLReqControlModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: EVTargetEnergyRequest, RationalNumberType (0, 1); EVMaximumEnergyRequest, RationalNumberType (0, 1); EVMinimumEnergyRequest, RationalNumberType (0, 1); EVMaximumChargePower, RationalNumberType (0, 1); EVMaximumChargePower_L2, RationalNumberType (0, 1); EVMaximumChargePower_L3, RationalNumberType (0, 1); EVMinimumChargePower, RationalNumberType (0, 1); EVMinimumChargePower_L2, RationalNumberType (0, 1); EVMinimumChargePower_L3, RationalNumberType (0, 1); EVPresentActivePower, RationalNumberType (1, 1); EVPresentActivePower_L2, RationalNumberType (0, 1); EVPresentActivePower_L3, RationalNumberType (0, 1); EVPresentReactivePower, RationalNumberType (0, 1); EVPresentReactivePower_L2, RationalNumberType (0, 1); EVPresentReactivePower_L3, RationalNumberType (0, 1);
static int decode_iso20_ac_der_Scheduled_AC_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_Scheduled_AC_CLReqControlModeType* Scheduled_AC_CLReqControlModeType) {
    int grammar_id = 209;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_Scheduled_AC_CLReqControlModeType(Scheduled_AC_CLReqControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 209:
            // Grammar: ID=209; read/write bits=4; START (EVTargetEnergyRequest), START (EVMaximumEnergyRequest), START (EVMinimumEnergyRequest), START (EVMaximumChargePower), START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=210
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVTargetEnergyRequest);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVTargetEnergyRequest_isUsed = 1u;
                        grammar_id = 210;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumEnergyRequest, RationalNumberType (RationalNumberType)); next=211
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumEnergyRequest);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumEnergyRequest_isUsed = 1u;
                        grammar_id = 211;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=212
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest_isUsed = 1u;
                        grammar_id = 212;
                    }
                    break;
                case 3:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=213
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_isUsed = 1u;
                        grammar_id = 213;
                    }
                    break;
                case 4:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=214
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 214;
                    }
                    break;
                case 5:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=215
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 215;
                    }
                    break;
                case 6:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=216
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 216;
                    }
                    break;
                case 7:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=217
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 217;
                    }
                    break;
                case 8:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=218
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 218;
                    }
                    break;
                case 9:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=219
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 219;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 210:
            // Grammar: ID=210; read/write bits=4; START (EVMaximumEnergyRequest), START (EVMinimumEnergyRequest), START (EVMaximumChargePower), START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumEnergyRequest, RationalNumberType (RationalNumberType)); next=211
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumEnergyRequest);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumEnergyRequest_isUsed = 1u;
                        grammar_id = 211;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=212
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest_isUsed = 1u;
                        grammar_id = 212;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=213
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_isUsed = 1u;
                        grammar_id = 213;
                    }
                    break;
                case 3:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=214
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 214;
                    }
                    break;
                case 4:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=215
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 215;
                    }
                    break;
                case 5:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=216
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 216;
                    }
                    break;
                case 6:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=217
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 217;
                    }
                    break;
                case 7:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=218
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 218;
                    }
                    break;
                case 8:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=219
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 219;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 211:
            // Grammar: ID=211; read/write bits=4; START (EVMinimumEnergyRequest), START (EVMaximumChargePower), START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=212
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest_isUsed = 1u;
                        grammar_id = 212;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=213
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_isUsed = 1u;
                        grammar_id = 213;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=214
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 214;
                    }
                    break;
                case 3:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=215
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 215;
                    }
                    break;
                case 4:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=216
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 216;
                    }
                    break;
                case 5:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=217
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 217;
                    }
                    break;
                case 6:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=218
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 218;
                    }
                    break;
                case 7:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=219
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 219;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 212:
            // Grammar: ID=212; read/write bits=3; START (EVMaximumChargePower), START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=213
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_isUsed = 1u;
                        grammar_id = 213;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=214
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 214;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=215
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 215;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=216
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 216;
                    }
                    break;
                case 4:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=217
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 217;
                    }
                    break;
                case 5:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=218
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 218;
                    }
                    break;
                case 6:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=219
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 219;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 213:
            // Grammar: ID=213; read/write bits=3; START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=214
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 214;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=215
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 215;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=216
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 216;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=217
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 217;
                    }
                    break;
                case 4:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=218
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 218;
                    }
                    break;
                case 5:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=219
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 219;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 214:
            // Grammar: ID=214; read/write bits=3; START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=215
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 215;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=216
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 216;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=217
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 217;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=218
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 218;
                    }
                    break;
                case 4:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=219
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 219;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 215:
            // Grammar: ID=215; read/write bits=3; START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=216
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 216;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=217
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 217;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=218
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 218;
                    }
                    break;
                case 3:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=219
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 219;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 216:
            // Grammar: ID=216; read/write bits=2; START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=217
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 217;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=218
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 218;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=219
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 219;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 217:
            // Grammar: ID=217; read/write bits=2; START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=218
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 218;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=219
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 219;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 218:
            // Grammar: ID=218; read/write bits=1; START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=219
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 219;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 219:
            // Grammar: ID=219; read/write bits=3; START (EVPresentActivePower_L2), START (EVPresentActivePower_L3), START (EVPresentReactivePower), START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=220
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 220;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=221
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 221;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=222
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_isUsed = 1u;
                        grammar_id = 222;
                    }
                    break;
                case 3:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=223
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 223;
                    }
                    break;
                case 4:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 220:
            // Grammar: ID=220; read/write bits=3; START (EVPresentActivePower_L3), START (EVPresentReactivePower), START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=221
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 221;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=222
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_isUsed = 1u;
                        grammar_id = 222;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=223
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 223;
                    }
                    break;
                case 3:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 221:
            // Grammar: ID=221; read/write bits=3; START (EVPresentReactivePower), START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=222
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_isUsed = 1u;
                        grammar_id = 222;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=223
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 223;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 222:
            // Grammar: ID=222; read/write bits=2; START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=223
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 223;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 223:
            // Grammar: ID=223; read/write bits=2; START (EVPresentReactivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}Dynamic_AC_CLReqControlMode; type={urn:iso:std:iso:15118:-20:AC}Dynamic_AC_CLReqControlModeType; base type=Dynamic_CLReqControlModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DepartureTime, unsignedInt (0, 1); EVTargetEnergyRequest, RationalNumberType (1, 1); EVMaximumEnergyRequest, RationalNumberType (1, 1); EVMinimumEnergyRequest, RationalNumberType (1, 1); EVMaximumChargePower, RationalNumberType (1, 1); EVMaximumChargePower_L2, RationalNumberType (0, 1); EVMaximumChargePower_L3, RationalNumberType (0, 1); EVMinimumChargePower, RationalNumberType (1, 1); EVMinimumChargePower_L2, RationalNumberType (0, 1); EVMinimumChargePower_L3, RationalNumberType (0, 1); EVPresentActivePower, RationalNumberType (1, 1); EVPresentActivePower_L2, RationalNumberType (0, 1); EVPresentActivePower_L3, RationalNumberType (0, 1); EVPresentReactivePower, RationalNumberType (1, 1); EVPresentReactivePower_L2, RationalNumberType (0, 1); EVPresentReactivePower_L3, RationalNumberType (0, 1);
static int decode_iso20_ac_der_Dynamic_AC_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_Dynamic_AC_CLReqControlModeType* Dynamic_AC_CLReqControlModeType) {
    int grammar_id = 224;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_Dynamic_AC_CLReqControlModeType(Dynamic_AC_CLReqControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 224:
            // Grammar: ID=224; read/write bits=2; START (DepartureTime), START (EVTargetEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DepartureTime, unsignedInt (unsignedLong)); next=225
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &Dynamic_AC_CLReqControlModeType->DepartureTime);
                    if (error == 0)
                    {
                        Dynamic_AC_CLReqControlModeType->DepartureTime_isUsed = 1u;
                        grammar_id = 225;
                    }
                    break;
                case 1:
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=226
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVTargetEnergyRequest);
                    if (error == 0)
                    {
                        grammar_id = 226;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 225:
            // Grammar: ID=225; read/write bits=1; START (EVTargetEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=226
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVTargetEnergyRequest);
                    if (error == 0)
                    {
                        grammar_id = 226;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 226:
            // Grammar: ID=226; read/write bits=1; START (EVMaximumEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumEnergyRequest, RationalNumberType (RationalNumberType)); next=227
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVMaximumEnergyRequest);
                    if (error == 0)
                    {
                        grammar_id = 227;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 227:
            // Grammar: ID=227; read/write bits=1; START (EVMinimumEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=228
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVMinimumEnergyRequest);
                    if (error == 0)
                    {
                        grammar_id = 228;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 228:
            // Grammar: ID=228; read/write bits=1; START (EVMaximumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=229
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 229;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 229:
            // Grammar: ID=229; read/write bits=2; START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=230
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 230;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=231
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 231;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=232
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 232;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 230:
            // Grammar: ID=230; read/write bits=2; START (EVMaximumChargePower_L3), START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=231
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 231;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=232
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 232;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 231:
            // Grammar: ID=231; read/write bits=1; START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=232
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 232;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 232:
            // Grammar: ID=232; read/write bits=2; START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=233
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 233;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=234
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 234;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=235
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 235;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 233:
            // Grammar: ID=233; read/write bits=2; START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=234
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 234;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=235
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 235;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 234:
            // Grammar: ID=234; read/write bits=1; START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=235
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 235;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 235:
            // Grammar: ID=235; read/write bits=2; START (EVPresentActivePower_L2), START (EVPresentActivePower_L3), START (EVPresentReactivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=236
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 236;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=237
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 237;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=238
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        grammar_id = 238;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 236:
            // Grammar: ID=236; read/write bits=2; START (EVPresentActivePower_L3), START (EVPresentReactivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=237
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 237;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=238
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        grammar_id = 238;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 237:
            // Grammar: ID=237; read/write bits=1; START (EVPresentReactivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=238
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        grammar_id = 238;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 238:
            // Grammar: ID=238; read/write bits=2; START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=239
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 239;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 239:
            // Grammar: ID=239; read/write bits=2; START (EVPresentReactivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}CLReqControlMode; type={urn:iso:std:iso:15118:-20:CommonTypes}CLReqControlModeType; base type=; content type=empty;
//          abstract=False; final=False;
static int decode_iso20_ac_der_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_CLReqControlModeType* CLReqControlModeType) {
    // Element has no particles, so the function just decodes END Element
    (void)CLReqControlModeType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}MeterInfo; type={urn:iso:std:iso:15118:-20:CommonTypes}MeterInfoType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: MeterID, meterIDType (1, 1); ChargedEnergyReadingWh, unsignedLong (1, 1); BPT_DischargedEnergyReadingWh, unsignedLong (0, 1); CapacitiveEnergyReadingVARh, unsignedLong (0, 1); BPT_InductiveEnergyReadingVARh, unsignedLong (0, 1); MeterSignature, meterSignatureType (0, 1); MeterStatus, short (0, 1); MeterTimestamp, unsignedLong (0, 1);
static int decode_iso20_ac_der_MeterInfoType(exi_bitstream_t* stream, struct iso20_ac_der_MeterInfoType* MeterInfoType) {
    int grammar_id = 240;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_MeterInfoType(MeterInfoType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 240:
            // Grammar: ID=240; read/write bits=1; START (MeterID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MeterID, meterIDType (string)); next=241
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &MeterInfoType->MeterID.charactersLen);
                            if (error == 0)
                            {
                                if (MeterInfoType->MeterID.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    MeterInfoType->MeterID.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, MeterInfoType->MeterID.charactersLen, MeterInfoType->MeterID.characters, iso20_ac_der_MeterID_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 241;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 241:
            // Grammar: ID=241; read/write bits=1; START (ChargedEnergyReadingWh)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ChargedEnergyReadingWh, unsignedLong (nonNegativeInteger)); next=242
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->ChargedEnergyReadingWh);
                    if (error == 0)
                    {
                        grammar_id = 242;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 242:
            // Grammar: ID=242; read/write bits=3; START (BPT_DischargedEnergyReadingWh), START (CapacitiveEnergyReadingVARh), START (BPT_InductiveEnergyReadingVARh), START (MeterSignature), START (MeterStatus), START (MeterTimestamp), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (BPT_DischargedEnergyReadingWh, unsignedLong (nonNegativeInteger)); next=243
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->BPT_DischargedEnergyReadingWh);
                    if (error == 0)
                    {
                        MeterInfoType->BPT_DischargedEnergyReadingWh_isUsed = 1u;
                        grammar_id = 243;
                    }
                    break;
                case 1:
                    // Event: START (CapacitiveEnergyReadingVARh, unsignedLong (nonNegativeInteger)); next=244
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->CapacitiveEnergyReadingVARh);
                    if (error == 0)
                    {
                        MeterInfoType->CapacitiveEnergyReadingVARh_isUsed = 1u;
                        grammar_id = 244;
                    }
                    break;
                case 2:
                    // Event: START (BPT_InductiveEnergyReadingVARh, unsignedLong (nonNegativeInteger)); next=245
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->BPT_InductiveEnergyReadingVARh);
                    if (error == 0)
                    {
                        MeterInfoType->BPT_InductiveEnergyReadingVARh_isUsed = 1u;
                        grammar_id = 245;
                    }
                    break;
                case 3:
                    // Event: START (MeterSignature, meterSignatureType (base64Binary)); next=246
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &MeterInfoType->MeterSignature.bytesLen, &MeterInfoType->MeterSignature.bytes[0], iso20_ac_der_meterSignatureType_BYTES_SIZE);
                    if (error == 0)
                    {
                        MeterInfoType->MeterSignature_isUsed = 1u;
                        grammar_id = 246;
                    }
                    break;
                case 4:
                    // Event: START (MeterStatus, short (int)); next=247
                    // decode: short
                    error = decode_exi_type_integer16(stream, &MeterInfoType->MeterStatus);
                    if (error == 0)
                    {
                        MeterInfoType->MeterStatus_isUsed = 1u;
                        grammar_id = 247;
                    }
                    break;
                case 5:
                    // Event: START (MeterTimestamp, unsignedLong (nonNegativeInteger)); next=2
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->MeterTimestamp);
                    if (error == 0)
                    {
                        MeterInfoType->MeterTimestamp_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 243:
            // Grammar: ID=243; read/write bits=3; START (CapacitiveEnergyReadingVARh), START (BPT_InductiveEnergyReadingVARh), START (MeterSignature), START (MeterStatus), START (MeterTimestamp), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (CapacitiveEnergyReadingVARh, unsignedLong (nonNegativeInteger)); next=244
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->CapacitiveEnergyReadingVARh);
                    if (error == 0)
                    {
                        MeterInfoType->CapacitiveEnergyReadingVARh_isUsed = 1u;
                        grammar_id = 244;
                    }
                    break;
                case 1:
                    // Event: START (BPT_InductiveEnergyReadingVARh, unsignedLong (nonNegativeInteger)); next=245
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->BPT_InductiveEnergyReadingVARh);
                    if (error == 0)
                    {
                        MeterInfoType->BPT_InductiveEnergyReadingVARh_isUsed = 1u;
                        grammar_id = 245;
                    }
                    break;
                case 2:
                    // Event: START (MeterSignature, meterSignatureType (base64Binary)); next=246
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &MeterInfoType->MeterSignature.bytesLen, &MeterInfoType->MeterSignature.bytes[0], iso20_ac_der_meterSignatureType_BYTES_SIZE);
                    if (error == 0)
                    {
                        MeterInfoType->MeterSignature_isUsed = 1u;
                        grammar_id = 246;
                    }
                    break;
                case 3:
                    // Event: START (MeterStatus, short (int)); next=247
                    // decode: short
                    error = decode_exi_type_integer16(stream, &MeterInfoType->MeterStatus);
                    if (error == 0)
                    {
                        MeterInfoType->MeterStatus_isUsed = 1u;
                        grammar_id = 247;
                    }
                    break;
                case 4:
                    // Event: START (MeterTimestamp, unsignedLong (nonNegativeInteger)); next=2
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->MeterTimestamp);
                    if (error == 0)
                    {
                        MeterInfoType->MeterTimestamp_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 244:
            // Grammar: ID=244; read/write bits=3; START (BPT_InductiveEnergyReadingVARh), START (MeterSignature), START (MeterStatus), START (MeterTimestamp), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (BPT_InductiveEnergyReadingVARh, unsignedLong (nonNegativeInteger)); next=245
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->BPT_InductiveEnergyReadingVARh);
                    if (error == 0)
                    {
                        MeterInfoType->BPT_InductiveEnergyReadingVARh_isUsed = 1u;
                        grammar_id = 245;
                    }
                    break;
                case 1:
                    // Event: START (MeterSignature, meterSignatureType (base64Binary)); next=246
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &MeterInfoType->MeterSignature.bytesLen, &MeterInfoType->MeterSignature.bytes[0], iso20_ac_der_meterSignatureType_BYTES_SIZE);
                    if (error == 0)
                    {
                        MeterInfoType->MeterSignature_isUsed = 1u;
                        grammar_id = 246;
                    }
                    break;
                case 2:
                    // Event: START (MeterStatus, short (int)); next=247
                    // decode: short
                    error = decode_exi_type_integer16(stream, &MeterInfoType->MeterStatus);
                    if (error == 0)
                    {
                        MeterInfoType->MeterStatus_isUsed = 1u;
                        grammar_id = 247;
                    }
                    break;
                case 3:
                    // Event: START (MeterTimestamp, unsignedLong (nonNegativeInteger)); next=2
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->MeterTimestamp);
                    if (error == 0)
                    {
                        MeterInfoType->MeterTimestamp_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 245:
            // Grammar: ID=245; read/write bits=3; START (MeterSignature), START (MeterStatus), START (MeterTimestamp), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MeterSignature, meterSignatureType (base64Binary)); next=246
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &MeterInfoType->MeterSignature.bytesLen, &MeterInfoType->MeterSignature.bytes[0], iso20_ac_der_meterSignatureType_BYTES_SIZE);
                    if (error == 0)
                    {
                        MeterInfoType->MeterSignature_isUsed = 1u;
                        grammar_id = 246;
                    }
                    break;
                case 1:
                    // Event: START (MeterStatus, short (int)); next=247
                    // decode: short
                    error = decode_exi_type_integer16(stream, &MeterInfoType->MeterStatus);
                    if (error == 0)
                    {
                        MeterInfoType->MeterStatus_isUsed = 1u;
                        grammar_id = 247;
                    }
                    break;
                case 2:
                    // Event: START (MeterTimestamp, unsignedLong (nonNegativeInteger)); next=2
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->MeterTimestamp);
                    if (error == 0)
                    {
                        MeterInfoType->MeterTimestamp_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 246:
            // Grammar: ID=246; read/write bits=2; START (MeterStatus), START (MeterTimestamp), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MeterStatus, short (int)); next=247
                    // decode: short
                    error = decode_exi_type_integer16(stream, &MeterInfoType->MeterStatus);
                    if (error == 0)
                    {
                        MeterInfoType->MeterStatus_isUsed = 1u;
                        grammar_id = 247;
                    }
                    break;
                case 1:
                    // Event: START (MeterTimestamp, unsignedLong (nonNegativeInteger)); next=2
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->MeterTimestamp);
                    if (error == 0)
                    {
                        MeterInfoType->MeterTimestamp_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 247:
            // Grammar: ID=247; read/write bits=2; START (MeterTimestamp), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MeterTimestamp, unsignedLong (nonNegativeInteger)); next=2
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->MeterTimestamp);
                    if (error == 0)
                    {
                        MeterInfoType->MeterTimestamp_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}Receipt; type={urn:iso:std:iso:15118:-20:CommonTypes}ReceiptType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TimeAnchor, unsignedLong (1, 1); EnergyCosts, DetailedCostType (0, 1); OccupancyCosts, DetailedCostType (0, 1); AdditionalServicesCosts, DetailedCostType (0, 1); OverstayCosts, DetailedCostType (0, 1); TaxCosts, DetailedTaxType (0, 10);
static int decode_iso20_ac_der_ReceiptType(exi_bitstream_t* stream, struct iso20_ac_der_ReceiptType* ReceiptType) {
    int grammar_id = 248;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_ReceiptType(ReceiptType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 248:
            // Grammar: ID=248; read/write bits=1; START (TimeAnchor)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (TimeAnchor, unsignedLong (nonNegativeInteger)); next=249
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &ReceiptType->TimeAnchor);
                    if (error == 0)
                    {
                        grammar_id = 249;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 249:
            // Grammar: ID=249; read/write bits=3; START (EnergyCosts), START (OccupancyCosts), START (AdditionalServicesCosts), START (OverstayCosts), START (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EnergyCosts, DetailedCostType (DetailedCostType)); next=251
                    // decode: element
                    error = decode_iso20_ac_der_DetailedCostType(stream, &ReceiptType->EnergyCosts);
                    if (error == 0)
                    {
                        ReceiptType->EnergyCosts_isUsed = 1u;
                        grammar_id = 251;
                    }
                    break;
                case 1:
                    // Event: START (OccupancyCosts, DetailedCostType (DetailedCostType)); next=253
                    // decode: element
                    error = decode_iso20_ac_der_DetailedCostType(stream, &ReceiptType->OccupancyCosts);
                    if (error == 0)
                    {
                        ReceiptType->OccupancyCosts_isUsed = 1u;
                        grammar_id = 253;
                    }
                    break;
                case 2:
                    // Event: START (AdditionalServicesCosts, DetailedCostType (DetailedCostType)); next=255
                    // decode: element
                    error = decode_iso20_ac_der_DetailedCostType(stream, &ReceiptType->AdditionalServicesCosts);
                    if (error == 0)
                    {
                        ReceiptType->AdditionalServicesCosts_isUsed = 1u;
                        grammar_id = 255;
                    }
                    break;
                case 3:
                    // Event: START (OverstayCosts, DetailedCostType (DetailedCostType)); next=257
                    // decode: element
                    error = decode_iso20_ac_der_DetailedCostType(stream, &ReceiptType->OverstayCosts);
                    if (error == 0)
                    {
                        ReceiptType->OverstayCosts_isUsed = 1u;
                        grammar_id = 257;
                    }
                    break;
                case 4:
                    // Event: START (TaxCosts, DetailedTaxType (DetailedTaxType)); next=250
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 250;
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 250:
            // Grammar: ID=250; read/write bits=2; LOOP (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: LOOP (TaxCosts, DetailedTaxType (DetailedTaxType)); next=250
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ReceiptType->TaxCosts.arrayLen < 10)
                    {
                        grammar_id = 250;
                    }
                    else
                    {
                        grammar_id = 251;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 251:
            // Grammar: ID=251; read/write bits=3; START (OccupancyCosts), START (AdditionalServicesCosts), START (OverstayCosts), START (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OccupancyCosts, DetailedCostType (DetailedCostType)); next=253
                    // decode: element
                    error = decode_iso20_ac_der_DetailedCostType(stream, &ReceiptType->OccupancyCosts);
                    if (error == 0)
                    {
                        ReceiptType->OccupancyCosts_isUsed = 1u;
                        grammar_id = 253;
                    }
                    break;
                case 1:
                    // Event: START (AdditionalServicesCosts, DetailedCostType (DetailedCostType)); next=255
                    // decode: element
                    error = decode_iso20_ac_der_DetailedCostType(stream, &ReceiptType->AdditionalServicesCosts);
                    if (error == 0)
                    {
                        ReceiptType->AdditionalServicesCosts_isUsed = 1u;
                        grammar_id = 255;
                    }
                    break;
                case 2:
                    // Event: START (OverstayCosts, DetailedCostType (DetailedCostType)); next=257
                    // decode: element
                    error = decode_iso20_ac_der_DetailedCostType(stream, &ReceiptType->OverstayCosts);
                    if (error == 0)
                    {
                        ReceiptType->OverstayCosts_isUsed = 1u;
                        grammar_id = 257;
                    }
                    break;
                case 3:
                    // Event: START (TaxCosts, DetailedTaxType (DetailedTaxType)); next=252
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 252;
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 252:
            // Grammar: ID=252; read/write bits=2; LOOP (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: LOOP (TaxCosts, DetailedTaxType (DetailedTaxType)); next=252
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ReceiptType->TaxCosts.arrayLen < 10)
                    {
                        grammar_id = 252;
                    }
                    else
                    {
                        grammar_id = 253;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 253:
            // Grammar: ID=253; read/write bits=3; START (AdditionalServicesCosts), START (OverstayCosts), START (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (AdditionalServicesCosts, DetailedCostType (DetailedCostType)); next=255
                    // decode: element
                    error = decode_iso20_ac_der_DetailedCostType(stream, &ReceiptType->AdditionalServicesCosts);
                    if (error == 0)
                    {
                        ReceiptType->AdditionalServicesCosts_isUsed = 1u;
                        grammar_id = 255;
                    }
                    break;
                case 1:
                    // Event: START (OverstayCosts, DetailedCostType (DetailedCostType)); next=257
                    // decode: element
                    error = decode_iso20_ac_der_DetailedCostType(stream, &ReceiptType->OverstayCosts);
                    if (error == 0)
                    {
                        ReceiptType->OverstayCosts_isUsed = 1u;
                        grammar_id = 257;
                    }
                    break;
                case 2:
                    // Event: START (TaxCosts, DetailedTaxType (DetailedTaxType)); next=254
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 254;
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 254:
            // Grammar: ID=254; read/write bits=2; LOOP (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: LOOP (TaxCosts, DetailedTaxType (DetailedTaxType)); next=254
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ReceiptType->TaxCosts.arrayLen < 10)
                    {
                        grammar_id = 254;
                    }
                    else
                    {
                        grammar_id = 255;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 255:
            // Grammar: ID=255; read/write bits=2; START (OverstayCosts), START (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (OverstayCosts, DetailedCostType (DetailedCostType)); next=257
                    // decode: element
                    error = decode_iso20_ac_der_DetailedCostType(stream, &ReceiptType->OverstayCosts);
                    if (error == 0)
                    {
                        ReceiptType->OverstayCosts_isUsed = 1u;
                        grammar_id = 257;
                    }
                    break;
                case 1:
                    // Event: START (TaxCosts, DetailedTaxType (DetailedTaxType)); next=256
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 256;
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 256:
            // Grammar: ID=256; read/write bits=2; LOOP (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: LOOP (TaxCosts, DetailedTaxType (DetailedTaxType)); next=256
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ReceiptType->TaxCosts.arrayLen < 10)
                    {
                        grammar_id = 256;
                    }
                    else
                    {
                        grammar_id = 257;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 257:
            // Grammar: ID=257; read/write bits=2; START (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (TaxCosts, DetailedTaxType (DetailedTaxType)); next=258
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 258;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 258:
            // Grammar: ID=258; read/write bits=2; LOOP (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: LOOP (TaxCosts, DetailedTaxType (DetailedTaxType)); next=258
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ReceiptType->TaxCosts.arrayLen < 10)
                    {
                        grammar_id = 258;
                    }
                    else
                    {
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}Dynamic_AC_CLResControlMode; type={urn:iso:std:iso:15118:-20:AC}Dynamic_AC_CLResControlModeType; base type=Dynamic_CLResControlModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DepartureTime, unsignedInt (0, 1); MinimumSOC, percentValueType (0, 1); TargetSOC, percentValueType (0, 1); AckMaxDelay, unsignedShort (0, 1); EVSETargetActivePower, RationalNumberType (1, 1); EVSETargetActivePower_L2, RationalNumberType (0, 1); EVSETargetActivePower_L3, RationalNumberType (0, 1); EVSETargetReactivePower, RationalNumberType (0, 1); EVSETargetReactivePower_L2, RationalNumberType (0, 1); EVSETargetReactivePower_L3, RationalNumberType (0, 1); EVSEPresentActivePower, RationalNumberType (0, 1); EVSEPresentActivePower_L2, RationalNumberType (0, 1); EVSEPresentActivePower_L3, RationalNumberType (0, 1);
static int decode_iso20_ac_der_Dynamic_AC_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_Dynamic_AC_CLResControlModeType* Dynamic_AC_CLResControlModeType) {
    int grammar_id = 259;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_Dynamic_AC_CLResControlModeType(Dynamic_AC_CLResControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 259:
            // Grammar: ID=259; read/write bits=3; START (DepartureTime), START (MinimumSOC), START (TargetSOC), START (AckMaxDelay), START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DepartureTime, unsignedInt (unsignedLong)); next=260
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &Dynamic_AC_CLResControlModeType->DepartureTime);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->DepartureTime_isUsed = 1u;
                        grammar_id = 260;
                    }
                    break;
                case 1:
                    // Event: START (MinimumSOC, percentValueType (byte)); next=261
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                Dynamic_AC_CLResControlModeType->MinimumSOC = (int8_t)value;
                                Dynamic_AC_CLResControlModeType->MinimumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 261;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (TargetSOC, percentValueType (byte)); next=262
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                Dynamic_AC_CLResControlModeType->TargetSOC = (int8_t)value;
                                Dynamic_AC_CLResControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 262;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 3:
                    // Event: START (AckMaxDelay, unsignedShort (unsignedInt)); next=263
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &Dynamic_AC_CLResControlModeType->AckMaxDelay);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->AckMaxDelay_isUsed = 1u;
                        grammar_id = 263;
                    }
                    break;
                case 4:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=264
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 264;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 260:
            // Grammar: ID=260; read/write bits=3; START (MinimumSOC), START (TargetSOC), START (AckMaxDelay), START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MinimumSOC, percentValueType (byte)); next=261
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                Dynamic_AC_CLResControlModeType->MinimumSOC = (int8_t)value;
                                Dynamic_AC_CLResControlModeType->MinimumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 261;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (TargetSOC, percentValueType (byte)); next=262
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                Dynamic_AC_CLResControlModeType->TargetSOC = (int8_t)value;
                                Dynamic_AC_CLResControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 262;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (AckMaxDelay, unsignedShort (unsignedInt)); next=263
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &Dynamic_AC_CLResControlModeType->AckMaxDelay);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->AckMaxDelay_isUsed = 1u;
                        grammar_id = 263;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=264
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 264;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 261:
            // Grammar: ID=261; read/write bits=2; START (TargetSOC), START (AckMaxDelay), START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (TargetSOC, percentValueType (byte)); next=262
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                Dynamic_AC_CLResControlModeType->TargetSOC = (int8_t)value;
                                Dynamic_AC_CLResControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 262;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (AckMaxDelay, unsignedShort (unsignedInt)); next=263
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &Dynamic_AC_CLResControlModeType->AckMaxDelay);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->AckMaxDelay_isUsed = 1u;
                        grammar_id = 263;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=264
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 264;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 262:
            // Grammar: ID=262; read/write bits=2; START (AckMaxDelay), START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (AckMaxDelay, unsignedShort (unsignedInt)); next=263
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &Dynamic_AC_CLResControlModeType->AckMaxDelay);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->AckMaxDelay_isUsed = 1u;
                        grammar_id = 263;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=264
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 264;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 263:
            // Grammar: ID=263; read/write bits=1; START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=264
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 264;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 264:
            // Grammar: ID=264; read/write bits=4; START (EVSETargetActivePower_L2), START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower_L2, RationalNumberType (RationalNumberType)); next=265
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L2_isUsed = 1u;
                        grammar_id = 265;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=266
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 266;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=267
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 267;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=268
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 268;
                    }
                    break;
                case 4:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=269
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 269;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=270
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 270;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=271
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 271;
                    }
                    break;
                case 7:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 8:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 265:
            // Grammar: ID=265; read/write bits=4; START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=266
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 266;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=267
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 267;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=268
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 268;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=269
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 269;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=270
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 270;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=271
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 271;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 266:
            // Grammar: ID=266; read/write bits=3; START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=267
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 267;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=268
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 268;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=269
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 269;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=270
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 270;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=271
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 271;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 267:
            // Grammar: ID=267; read/write bits=3; START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=268
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 268;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=269
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 269;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=270
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 270;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=271
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 271;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 268:
            // Grammar: ID=268; read/write bits=3; START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=269
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 269;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=270
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 270;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=271
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 271;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 269:
            // Grammar: ID=269; read/write bits=3; START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=270
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 270;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=271
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 271;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 270:
            // Grammar: ID=270; read/write bits=2; START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=271
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 271;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 271:
            // Grammar: ID=271; read/write bits=2; START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}Scheduled_AC_CLResControlMode; type={urn:iso:std:iso:15118:-20:AC}Scheduled_AC_CLResControlModeType; base type=Scheduled_CLResControlModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: EVSETargetActivePower, RationalNumberType (0, 1); EVSETargetActivePower_L2, RationalNumberType (0, 1); EVSETargetActivePower_L3, RationalNumberType (0, 1); EVSETargetReactivePower, RationalNumberType (0, 1); EVSETargetReactivePower_L2, RationalNumberType (0, 1); EVSETargetReactivePower_L3, RationalNumberType (0, 1); EVSEPresentActivePower, RationalNumberType (0, 1); EVSEPresentActivePower_L2, RationalNumberType (0, 1); EVSEPresentActivePower_L3, RationalNumberType (0, 1);
static int decode_iso20_ac_der_Scheduled_AC_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_Scheduled_AC_CLResControlModeType* Scheduled_AC_CLResControlModeType) {
    int grammar_id = 272;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_Scheduled_AC_CLResControlModeType(Scheduled_AC_CLResControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 272:
            // Grammar: ID=272; read/write bits=4; START (EVSETargetActivePower), START (EVSETargetActivePower_L2), START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=273
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetActivePower_isUsed = 1u;
                        grammar_id = 273;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetActivePower_L2, RationalNumberType (RationalNumberType)); next=274
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L2_isUsed = 1u;
                        grammar_id = 274;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=275
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 275;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=276
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 276;
                    }
                    break;
                case 4:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=277
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 277;
                    }
                    break;
                case 5:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=278
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 278;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=279
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 279;
                    }
                    break;
                case 7:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=280
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 280;
                    }
                    break;
                case 8:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 9:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 273:
            // Grammar: ID=273; read/write bits=4; START (EVSETargetActivePower_L2), START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower_L2, RationalNumberType (RationalNumberType)); next=274
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L2_isUsed = 1u;
                        grammar_id = 274;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=275
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 275;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=276
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 276;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=277
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 277;
                    }
                    break;
                case 4:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=278
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 278;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=279
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 279;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=280
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 280;
                    }
                    break;
                case 7:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 8:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 274:
            // Grammar: ID=274; read/write bits=4; START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=275
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 275;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=276
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 276;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=277
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 277;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=278
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 278;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=279
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 279;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=280
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 280;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 275:
            // Grammar: ID=275; read/write bits=3; START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=276
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 276;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=277
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 277;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=278
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 278;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=279
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 279;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=280
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 280;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 276:
            // Grammar: ID=276; read/write bits=3; START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=277
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 277;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=278
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 278;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=279
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 279;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=280
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 280;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 277:
            // Grammar: ID=277; read/write bits=3; START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=278
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 278;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=279
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 279;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=280
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 280;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 278:
            // Grammar: ID=278; read/write bits=3; START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=279
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 279;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=280
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 280;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 279:
            // Grammar: ID=279; read/write bits=2; START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=280
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 280;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 280:
            // Grammar: ID=280; read/write bits=2; START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}CLResControlMode; type={urn:iso:std:iso:15118:-20:CommonTypes}CLResControlModeType; base type=; content type=empty;
//          abstract=False; final=False;
static int decode_iso20_ac_der_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_CLResControlModeType* CLResControlModeType) {
    // Element has no particles, so the function just decodes END Element
    (void)CLResControlModeType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}EVMaximumDischargePower; type={urn:iso:std:iso:15118:-20:AC}PhaseType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False; choice=True;
// Particle: AnyPhase, RationalNumberType (0, 1); ThreePhase, ThreePhaseType (0, 1);
static int decode_iso20_ac_der_PhaseType(exi_bitstream_t* stream, struct iso20_ac_der_PhaseType* PhaseType) {
    int grammar_id = 281;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_PhaseType(PhaseType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 281:
            // Grammar: ID=281; read/write bits=2; START (AnyPhase), START (ThreePhase)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (AnyPhase, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &PhaseType->AnyPhase);
                    if (error == 0)
                    {
                        PhaseType->AnyPhase_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: START (ThreePhase, ThreePhaseType (ThreePhaseType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_ThreePhaseType(stream, &PhaseType->ThreePhase);
                    if (error == 0)
                    {
                        PhaseType->ThreePhase_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}EVApparentPowerLimits; type={urn:iso:std:iso:15118:-20:AC}EVApparentPowerLimitsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVMaximumChargeApparentPower, PhaseType (0, 1); EVMaximumDischargeApparentPower, PhaseType (0, 1); EVMaximumApparentPower, RationalNumberType (0, 1);
static int decode_iso20_ac_der_EVApparentPowerLimitsType(exi_bitstream_t* stream, struct iso20_ac_der_EVApparentPowerLimitsType* EVApparentPowerLimitsType) {
    int grammar_id = 282;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_EVApparentPowerLimitsType(EVApparentPowerLimitsType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 282:
            // Grammar: ID=282; read/write bits=3; START (EVMaximumChargeApparentPower), START (EVMaximumDischargeApparentPower), START (EVMaximumApparentPower), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargeApparentPower, PhaseType (PhaseType)); next=283
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVApparentPowerLimitsType->EVMaximumChargeApparentPower);
                    if (error == 0)
                    {
                        EVApparentPowerLimitsType->EVMaximumChargeApparentPower_isUsed = 1u;
                        grammar_id = 283;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumDischargeApparentPower, PhaseType (PhaseType)); next=284
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVApparentPowerLimitsType->EVMaximumDischargeApparentPower);
                    if (error == 0)
                    {
                        EVApparentPowerLimitsType->EVMaximumDischargeApparentPower_isUsed = 1u;
                        grammar_id = 284;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumApparentPower, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVApparentPowerLimitsType->EVMaximumApparentPower);
                    if (error == 0)
                    {
                        EVApparentPowerLimitsType->EVMaximumApparentPower_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 283:
            // Grammar: ID=283; read/write bits=2; START (EVMaximumDischargeApparentPower), START (EVMaximumApparentPower), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargeApparentPower, PhaseType (PhaseType)); next=284
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVApparentPowerLimitsType->EVMaximumDischargeApparentPower);
                    if (error == 0)
                    {
                        EVApparentPowerLimitsType->EVMaximumDischargeApparentPower_isUsed = 1u;
                        grammar_id = 284;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumApparentPower, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVApparentPowerLimitsType->EVMaximumApparentPower);
                    if (error == 0)
                    {
                        EVApparentPowerLimitsType->EVMaximumApparentPower_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 284:
            // Grammar: ID=284; read/write bits=2; START (EVMaximumApparentPower), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumApparentPower, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVApparentPowerLimitsType->EVMaximumApparentPower);
                    if (error == 0)
                    {
                        EVApparentPowerLimitsType->EVMaximumApparentPower_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}EVReactivePowerLimits; type={urn:iso:std:iso:15118:-20:AC}EVReactivePowerLimitsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVMaximumChargeReactivePower, RationalNumberType (0, 1); EVMinimumChargeReactivePower, RationalNumberType (0, 1); EVMaximumDischargeReactivePower, RationalNumberType (0, 1); EVMinimumDischargeReactivePower, RationalNumberType (0, 1); EVReactiveSusceptance, RationalNumberType (0, 1);
static int decode_iso20_ac_der_EVReactivePowerLimitsType(exi_bitstream_t* stream, struct iso20_ac_der_EVReactivePowerLimitsType* EVReactivePowerLimitsType) {
    int grammar_id = 285;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_EVReactivePowerLimitsType(EVReactivePowerLimitsType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 285:
            // Grammar: ID=285; read/write bits=3; START (EVMaximumChargeReactivePower), START (EVMinimumChargeReactivePower), START (EVMaximumDischargeReactivePower), START (EVMinimumDischargeReactivePower), START (EVReactiveSusceptance), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargeReactivePower, RationalNumberType (RationalNumberType)); next=286
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVMaximumChargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVMaximumChargeReactivePower_isUsed = 1u;
                        grammar_id = 286;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargeReactivePower, RationalNumberType (RationalNumberType)); next=287
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVMinimumChargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVMinimumChargeReactivePower_isUsed = 1u;
                        grammar_id = 287;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumDischargeReactivePower, RationalNumberType (RationalNumberType)); next=288
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVMaximumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVMaximumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 288;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumDischargeReactivePower, RationalNumberType (RationalNumberType)); next=289
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVMinimumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVMinimumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 289;
                    }
                    break;
                case 4:
                    // Event: START (EVReactiveSusceptance, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVReactiveSusceptance);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVReactiveSusceptance_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 286:
            // Grammar: ID=286; read/write bits=3; START (EVMinimumChargeReactivePower), START (EVMaximumDischargeReactivePower), START (EVMinimumDischargeReactivePower), START (EVReactiveSusceptance), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargeReactivePower, RationalNumberType (RationalNumberType)); next=287
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVMinimumChargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVMinimumChargeReactivePower_isUsed = 1u;
                        grammar_id = 287;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumDischargeReactivePower, RationalNumberType (RationalNumberType)); next=288
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVMaximumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVMaximumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 288;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumDischargeReactivePower, RationalNumberType (RationalNumberType)); next=289
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVMinimumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVMinimumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 289;
                    }
                    break;
                case 3:
                    // Event: START (EVReactiveSusceptance, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVReactiveSusceptance);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVReactiveSusceptance_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 287:
            // Grammar: ID=287; read/write bits=3; START (EVMaximumDischargeReactivePower), START (EVMinimumDischargeReactivePower), START (EVReactiveSusceptance), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargeReactivePower, RationalNumberType (RationalNumberType)); next=288
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVMaximumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVMaximumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 288;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumDischargeReactivePower, RationalNumberType (RationalNumberType)); next=289
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVMinimumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVMinimumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 289;
                    }
                    break;
                case 2:
                    // Event: START (EVReactiveSusceptance, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVReactiveSusceptance);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVReactiveSusceptance_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 288:
            // Grammar: ID=288; read/write bits=2; START (EVMinimumDischargeReactivePower), START (EVReactiveSusceptance), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargeReactivePower, RationalNumberType (RationalNumberType)); next=289
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVMinimumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVMinimumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 289;
                    }
                    break;
                case 1:
                    // Event: START (EVReactiveSusceptance, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVReactiveSusceptance);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVReactiveSusceptance_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 289:
            // Grammar: ID=289; read/write bits=2; START (EVReactiveSusceptance), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVReactiveSusceptance, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVReactivePowerLimitsType->EVReactiveSusceptance);
                    if (error == 0)
                    {
                        EVReactivePowerLimitsType->EVReactiveSusceptance_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}EVExcitationLimits; type={urn:iso:std:iso:15118:-20:AC}EVExcitationLimitsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVOverExcitedMaximumPowerFactor, RationalNumberType (0, 1); EVOverExcitedMaximumDischargePower, RationalNumberType (0, 1); EVUnderExcitedMaximumPowerFactor, RationalNumberType (0, 1); EVUnderExcitedMaximumDischargePower, RationalNumberType (0, 1);
static int decode_iso20_ac_der_EVExcitationLimitsType(exi_bitstream_t* stream, struct iso20_ac_der_EVExcitationLimitsType* EVExcitationLimitsType) {
    int grammar_id = 290;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_EVExcitationLimitsType(EVExcitationLimitsType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 290:
            // Grammar: ID=290; read/write bits=3; START (EVOverExcitedMaximumPowerFactor), START (EVOverExcitedMaximumDischargePower), START (EVUnderExcitedMaximumPowerFactor), START (EVUnderExcitedMaximumDischargePower), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVOverExcitedMaximumPowerFactor, RationalNumberType (RationalNumberType)); next=291
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationLimitsType->EVOverExcitedMaximumPowerFactor);
                    if (error == 0)
                    {
                        EVExcitationLimitsType->EVOverExcitedMaximumPowerFactor_isUsed = 1u;
                        grammar_id = 291;
                    }
                    break;
                case 1:
                    // Event: START (EVOverExcitedMaximumDischargePower, RationalNumberType (RationalNumberType)); next=292
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationLimitsType->EVOverExcitedMaximumDischargePower);
                    if (error == 0)
                    {
                        EVExcitationLimitsType->EVOverExcitedMaximumDischargePower_isUsed = 1u;
                        grammar_id = 292;
                    }
                    break;
                case 2:
                    // Event: START (EVUnderExcitedMaximumPowerFactor, RationalNumberType (RationalNumberType)); next=293
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationLimitsType->EVUnderExcitedMaximumPowerFactor);
                    if (error == 0)
                    {
                        EVExcitationLimitsType->EVUnderExcitedMaximumPowerFactor_isUsed = 1u;
                        grammar_id = 293;
                    }
                    break;
                case 3:
                    // Event: START (EVUnderExcitedMaximumDischargePower, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationLimitsType->EVUnderExcitedMaximumDischargePower);
                    if (error == 0)
                    {
                        EVExcitationLimitsType->EVUnderExcitedMaximumDischargePower_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 291:
            // Grammar: ID=291; read/write bits=3; START (EVOverExcitedMaximumDischargePower), START (EVUnderExcitedMaximumPowerFactor), START (EVUnderExcitedMaximumDischargePower), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVOverExcitedMaximumDischargePower, RationalNumberType (RationalNumberType)); next=292
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationLimitsType->EVOverExcitedMaximumDischargePower);
                    if (error == 0)
                    {
                        EVExcitationLimitsType->EVOverExcitedMaximumDischargePower_isUsed = 1u;
                        grammar_id = 292;
                    }
                    break;
                case 1:
                    // Event: START (EVUnderExcitedMaximumPowerFactor, RationalNumberType (RationalNumberType)); next=293
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationLimitsType->EVUnderExcitedMaximumPowerFactor);
                    if (error == 0)
                    {
                        EVExcitationLimitsType->EVUnderExcitedMaximumPowerFactor_isUsed = 1u;
                        grammar_id = 293;
                    }
                    break;
                case 2:
                    // Event: START (EVUnderExcitedMaximumDischargePower, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationLimitsType->EVUnderExcitedMaximumDischargePower);
                    if (error == 0)
                    {
                        EVExcitationLimitsType->EVUnderExcitedMaximumDischargePower_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 292:
            // Grammar: ID=292; read/write bits=2; START (EVUnderExcitedMaximumPowerFactor), START (EVUnderExcitedMaximumDischargePower), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVUnderExcitedMaximumPowerFactor, RationalNumberType (RationalNumberType)); next=293
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationLimitsType->EVUnderExcitedMaximumPowerFactor);
                    if (error == 0)
                    {
                        EVExcitationLimitsType->EVUnderExcitedMaximumPowerFactor_isUsed = 1u;
                        grammar_id = 293;
                    }
                    break;
                case 1:
                    // Event: START (EVUnderExcitedMaximumDischargePower, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationLimitsType->EVUnderExcitedMaximumDischargePower);
                    if (error == 0)
                    {
                        EVExcitationLimitsType->EVUnderExcitedMaximumDischargePower_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 293:
            // Grammar: ID=293; read/write bits=2; START (EVUnderExcitedMaximumDischargePower), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVUnderExcitedMaximumDischargePower, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationLimitsType->EVUnderExcitedMaximumDischargePower);
                    if (error == 0)
                    {
                        EVExcitationLimitsType->EVUnderExcitedMaximumDischargePower_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}EVInverterDetails; type={urn:iso:std:iso:15118:-20:AC}EVInverterDetailsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVInverterSwVersion, evInverterSwVersionType (0, 1); EVInverterHwVersion, evInverterHwVersionType (0, 1); EVInverterManufacturer, evInverterManufacturerType (0, 1); EVInverterModel, evInverterModelType (0, 1); EVInverterSerialNumber, evInverterSerialNumberType (0, 1);
static int decode_iso20_ac_der_EVInverterDetailsType(exi_bitstream_t* stream, struct iso20_ac_der_EVInverterDetailsType* EVInverterDetailsType) {
    int grammar_id = 294;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_EVInverterDetailsType(EVInverterDetailsType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 294:
            // Grammar: ID=294; read/write bits=3; START (EVInverterSwVersion), START (EVInverterHwVersion), START (EVInverterManufacturer), START (EVInverterModel), START (EVInverterSerialNumber), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVInverterSwVersion, evInverterSwVersionType (string)); next=295
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterSwVersion.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterSwVersion.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterSwVersion.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterSwVersion.charactersLen, EVInverterDetailsType->EVInverterSwVersion.characters, iso20_ac_der_EVInverterSwVersion_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterSwVersion_isUsed = 1u;
                                grammar_id = 295;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (EVInverterHwVersion, evInverterHwVersionType (string)); next=296
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterHwVersion.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterHwVersion.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterHwVersion.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterHwVersion.charactersLen, EVInverterDetailsType->EVInverterHwVersion.characters, iso20_ac_der_EVInverterHwVersion_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterHwVersion_isUsed = 1u;
                                grammar_id = 296;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (EVInverterManufacturer, evInverterManufacturerType (string)); next=297
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterManufacturer.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterManufacturer.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterManufacturer.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterManufacturer.charactersLen, EVInverterDetailsType->EVInverterManufacturer.characters, iso20_ac_der_EVInverterManufacturer_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterManufacturer_isUsed = 1u;
                                grammar_id = 297;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 3:
                    // Event: START (EVInverterModel, evInverterModelType (string)); next=298
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterModel.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterModel.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterModel.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterModel.charactersLen, EVInverterDetailsType->EVInverterModel.characters, iso20_ac_der_EVInverterModel_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterModel_isUsed = 1u;
                                grammar_id = 298;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 4:
                    // Event: START (EVInverterSerialNumber, evInverterSerialNumberType (string)); next=2
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterSerialNumber.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterSerialNumber.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterSerialNumber.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterSerialNumber.charactersLen, EVInverterDetailsType->EVInverterSerialNumber.characters, iso20_ac_der_EVInverterSerialNumber_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterSerialNumber_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 295:
            // Grammar: ID=295; read/write bits=3; START (EVInverterHwVersion), START (EVInverterManufacturer), START (EVInverterModel), START (EVInverterSerialNumber), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVInverterHwVersion, evInverterHwVersionType (string)); next=296
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterHwVersion.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterHwVersion.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterHwVersion.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterHwVersion.charactersLen, EVInverterDetailsType->EVInverterHwVersion.characters, iso20_ac_der_EVInverterHwVersion_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterHwVersion_isUsed = 1u;
                                grammar_id = 296;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (EVInverterManufacturer, evInverterManufacturerType (string)); next=297
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterManufacturer.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterManufacturer.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterManufacturer.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterManufacturer.charactersLen, EVInverterDetailsType->EVInverterManufacturer.characters, iso20_ac_der_EVInverterManufacturer_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterManufacturer_isUsed = 1u;
                                grammar_id = 297;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (EVInverterModel, evInverterModelType (string)); next=298
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterModel.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterModel.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterModel.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterModel.charactersLen, EVInverterDetailsType->EVInverterModel.characters, iso20_ac_der_EVInverterModel_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterModel_isUsed = 1u;
                                grammar_id = 298;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 3:
                    // Event: START (EVInverterSerialNumber, evInverterSerialNumberType (string)); next=2
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterSerialNumber.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterSerialNumber.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterSerialNumber.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterSerialNumber.charactersLen, EVInverterDetailsType->EVInverterSerialNumber.characters, iso20_ac_der_EVInverterSerialNumber_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterSerialNumber_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 296:
            // Grammar: ID=296; read/write bits=3; START (EVInverterManufacturer), START (EVInverterModel), START (EVInverterSerialNumber), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVInverterManufacturer, evInverterManufacturerType (string)); next=297
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterManufacturer.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterManufacturer.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterManufacturer.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterManufacturer.charactersLen, EVInverterDetailsType->EVInverterManufacturer.characters, iso20_ac_der_EVInverterManufacturer_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterManufacturer_isUsed = 1u;
                                grammar_id = 297;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (EVInverterModel, evInverterModelType (string)); next=298
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterModel.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterModel.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterModel.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterModel.charactersLen, EVInverterDetailsType->EVInverterModel.characters, iso20_ac_der_EVInverterModel_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterModel_isUsed = 1u;
                                grammar_id = 298;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (EVInverterSerialNumber, evInverterSerialNumberType (string)); next=2
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterSerialNumber.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterSerialNumber.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterSerialNumber.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterSerialNumber.charactersLen, EVInverterDetailsType->EVInverterSerialNumber.characters, iso20_ac_der_EVInverterSerialNumber_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterSerialNumber_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 297:
            // Grammar: ID=297; read/write bits=2; START (EVInverterModel), START (EVInverterSerialNumber), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVInverterModel, evInverterModelType (string)); next=298
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterModel.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterModel.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterModel.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterModel.charactersLen, EVInverterDetailsType->EVInverterModel.characters, iso20_ac_der_EVInverterModel_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterModel_isUsed = 1u;
                                grammar_id = 298;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (EVInverterSerialNumber, evInverterSerialNumberType (string)); next=2
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterSerialNumber.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterSerialNumber.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterSerialNumber.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterSerialNumber.charactersLen, EVInverterDetailsType->EVInverterSerialNumber.characters, iso20_ac_der_EVInverterSerialNumber_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterSerialNumber_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 298:
            // Grammar: ID=298; read/write bits=2; START (EVInverterSerialNumber), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVInverterSerialNumber, evInverterSerialNumberType (string)); next=2
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVInverterDetailsType->EVInverterSerialNumber.charactersLen);
                            if (error == 0)
                            {
                                if (EVInverterDetailsType->EVInverterSerialNumber.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVInverterDetailsType->EVInverterSerialNumber.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVInverterDetailsType->EVInverterSerialNumber.charactersLen, EVInverterDetailsType->EVInverterSerialNumber.characters, iso20_ac_der_EVInverterSerialNumber_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                EVInverterDetailsType->EVInverterSerialNumber_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}DERControl; type={urn:iso:std:iso:15118:-20:AC}DERControlType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: VoltageTrip, VoltageTripType (0, 1); FrequencyTrip, FrequencyTripType (0, 1); FaultRideThrough, FaultRideThroughType (0, 1); EnterService, EnterServiceType (0, 1); ReactivePowerSupport, ReactivePowerSupportType (0, 1); ActivePowerSupport, ActivePowerSupportType (0, 1); MaximumLevel1DCInjection, RationalNumberType (0, 1); MaximumLevel2DCInjection, RationalNumberType (0, 1); SCRatPOC, RationalNumberType (0, 1);
static int decode_iso20_ac_der_DERControlType(exi_bitstream_t* stream, struct iso20_ac_der_DERControlType* DERControlType) {
    int grammar_id = 299;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DERControlType(DERControlType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 299:
            // Grammar: ID=299; read/write bits=4; START (VoltageTrip), START (FrequencyTrip), START (FaultRideThrough), START (EnterService), START (ReactivePowerSupport), START (ActivePowerSupport), START (MaximumLevel1DCInjection), START (MaximumLevel2DCInjection), START (SCRatPOC), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (VoltageTrip, VoltageTripType (VoltageTripType)); next=300
                    // decode: element
                    error = decode_iso20_ac_der_VoltageTripType(stream, &DERControlType->VoltageTrip);
                    if (error == 0)
                    {
                        DERControlType->VoltageTrip_isUsed = 1u;
                        grammar_id = 300;
                    }
                    break;
                case 1:
                    // Event: START (FrequencyTrip, FrequencyTripType (FrequencyTripType)); next=301
                    // decode: element
                    error = decode_iso20_ac_der_FrequencyTripType(stream, &DERControlType->FrequencyTrip);
                    if (error == 0)
                    {
                        DERControlType->FrequencyTrip_isUsed = 1u;
                        grammar_id = 301;
                    }
                    break;
                case 2:
                    // Event: START (FaultRideThrough, FaultRideThroughType (FaultRideThroughType)); next=302
                    // decode: element
                    error = decode_iso20_ac_der_FaultRideThroughType(stream, &DERControlType->FaultRideThrough);
                    if (error == 0)
                    {
                        DERControlType->FaultRideThrough_isUsed = 1u;
                        grammar_id = 302;
                    }
                    break;
                case 3:
                    // Event: START (EnterService, EnterServiceType (EnterServiceType)); next=303
                    // decode: element
                    error = decode_iso20_ac_der_EnterServiceType(stream, &DERControlType->EnterService);
                    if (error == 0)
                    {
                        DERControlType->EnterService_isUsed = 1u;
                        grammar_id = 303;
                    }
                    break;
                case 4:
                    // Event: START (ReactivePowerSupport, ReactivePowerSupportType (ReactivePowerSupportType)); next=304
                    // decode: element
                    error = decode_iso20_ac_der_ReactivePowerSupportType(stream, &DERControlType->ReactivePowerSupport);
                    if (error == 0)
                    {
                        DERControlType->ReactivePowerSupport_isUsed = 1u;
                        grammar_id = 304;
                    }
                    break;
                case 5:
                    // Event: START (ActivePowerSupport, ActivePowerSupportType (ActivePowerSupportType)); next=305
                    // decode: element
                    error = decode_iso20_ac_der_ActivePowerSupportType(stream, &DERControlType->ActivePowerSupport);
                    if (error == 0)
                    {
                        DERControlType->ActivePowerSupport_isUsed = 1u;
                        grammar_id = 305;
                    }
                    break;
                case 6:
                    // Event: START (MaximumLevel1DCInjection, RationalNumberType (RationalNumberType)); next=306
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel1DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel1DCInjection_isUsed = 1u;
                        grammar_id = 306;
                    }
                    break;
                case 7:
                    // Event: START (MaximumLevel2DCInjection, RationalNumberType (RationalNumberType)); next=307
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel2DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel2DCInjection_isUsed = 1u;
                        grammar_id = 307;
                    }
                    break;
                case 8:
                    // Event: START (SCRatPOC, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->SCRatPOC);
                    if (error == 0)
                    {
                        DERControlType->SCRatPOC_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 9:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 300:
            // Grammar: ID=300; read/write bits=4; START (FrequencyTrip), START (FaultRideThrough), START (EnterService), START (ReactivePowerSupport), START (ActivePowerSupport), START (MaximumLevel1DCInjection), START (MaximumLevel2DCInjection), START (SCRatPOC), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (FrequencyTrip, FrequencyTripType (FrequencyTripType)); next=301
                    // decode: element
                    error = decode_iso20_ac_der_FrequencyTripType(stream, &DERControlType->FrequencyTrip);
                    if (error == 0)
                    {
                        DERControlType->FrequencyTrip_isUsed = 1u;
                        grammar_id = 301;
                    }
                    break;
                case 1:
                    // Event: START (FaultRideThrough, FaultRideThroughType (FaultRideThroughType)); next=302
                    // decode: element
                    error = decode_iso20_ac_der_FaultRideThroughType(stream, &DERControlType->FaultRideThrough);
                    if (error == 0)
                    {
                        DERControlType->FaultRideThrough_isUsed = 1u;
                        grammar_id = 302;
                    }
                    break;
                case 2:
                    // Event: START (EnterService, EnterServiceType (EnterServiceType)); next=303
                    // decode: element
                    error = decode_iso20_ac_der_EnterServiceType(stream, &DERControlType->EnterService);
                    if (error == 0)
                    {
                        DERControlType->EnterService_isUsed = 1u;
                        grammar_id = 303;
                    }
                    break;
                case 3:
                    // Event: START (ReactivePowerSupport, ReactivePowerSupportType (ReactivePowerSupportType)); next=304
                    // decode: element
                    error = decode_iso20_ac_der_ReactivePowerSupportType(stream, &DERControlType->ReactivePowerSupport);
                    if (error == 0)
                    {
                        DERControlType->ReactivePowerSupport_isUsed = 1u;
                        grammar_id = 304;
                    }
                    break;
                case 4:
                    // Event: START (ActivePowerSupport, ActivePowerSupportType (ActivePowerSupportType)); next=305
                    // decode: element
                    error = decode_iso20_ac_der_ActivePowerSupportType(stream, &DERControlType->ActivePowerSupport);
                    if (error == 0)
                    {
                        DERControlType->ActivePowerSupport_isUsed = 1u;
                        grammar_id = 305;
                    }
                    break;
                case 5:
                    // Event: START (MaximumLevel1DCInjection, RationalNumberType (RationalNumberType)); next=306
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel1DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel1DCInjection_isUsed = 1u;
                        grammar_id = 306;
                    }
                    break;
                case 6:
                    // Event: START (MaximumLevel2DCInjection, RationalNumberType (RationalNumberType)); next=307
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel2DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel2DCInjection_isUsed = 1u;
                        grammar_id = 307;
                    }
                    break;
                case 7:
                    // Event: START (SCRatPOC, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->SCRatPOC);
                    if (error == 0)
                    {
                        DERControlType->SCRatPOC_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 8:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 301:
            // Grammar: ID=301; read/write bits=4; START (FaultRideThrough), START (EnterService), START (ReactivePowerSupport), START (ActivePowerSupport), START (MaximumLevel1DCInjection), START (MaximumLevel2DCInjection), START (SCRatPOC), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (FaultRideThrough, FaultRideThroughType (FaultRideThroughType)); next=302
                    // decode: element
                    error = decode_iso20_ac_der_FaultRideThroughType(stream, &DERControlType->FaultRideThrough);
                    if (error == 0)
                    {
                        DERControlType->FaultRideThrough_isUsed = 1u;
                        grammar_id = 302;
                    }
                    break;
                case 1:
                    // Event: START (EnterService, EnterServiceType (EnterServiceType)); next=303
                    // decode: element
                    error = decode_iso20_ac_der_EnterServiceType(stream, &DERControlType->EnterService);
                    if (error == 0)
                    {
                        DERControlType->EnterService_isUsed = 1u;
                        grammar_id = 303;
                    }
                    break;
                case 2:
                    // Event: START (ReactivePowerSupport, ReactivePowerSupportType (ReactivePowerSupportType)); next=304
                    // decode: element
                    error = decode_iso20_ac_der_ReactivePowerSupportType(stream, &DERControlType->ReactivePowerSupport);
                    if (error == 0)
                    {
                        DERControlType->ReactivePowerSupport_isUsed = 1u;
                        grammar_id = 304;
                    }
                    break;
                case 3:
                    // Event: START (ActivePowerSupport, ActivePowerSupportType (ActivePowerSupportType)); next=305
                    // decode: element
                    error = decode_iso20_ac_der_ActivePowerSupportType(stream, &DERControlType->ActivePowerSupport);
                    if (error == 0)
                    {
                        DERControlType->ActivePowerSupport_isUsed = 1u;
                        grammar_id = 305;
                    }
                    break;
                case 4:
                    // Event: START (MaximumLevel1DCInjection, RationalNumberType (RationalNumberType)); next=306
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel1DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel1DCInjection_isUsed = 1u;
                        grammar_id = 306;
                    }
                    break;
                case 5:
                    // Event: START (MaximumLevel2DCInjection, RationalNumberType (RationalNumberType)); next=307
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel2DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel2DCInjection_isUsed = 1u;
                        grammar_id = 307;
                    }
                    break;
                case 6:
                    // Event: START (SCRatPOC, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->SCRatPOC);
                    if (error == 0)
                    {
                        DERControlType->SCRatPOC_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 302:
            // Grammar: ID=302; read/write bits=3; START (EnterService), START (ReactivePowerSupport), START (ActivePowerSupport), START (MaximumLevel1DCInjection), START (MaximumLevel2DCInjection), START (SCRatPOC), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EnterService, EnterServiceType (EnterServiceType)); next=303
                    // decode: element
                    error = decode_iso20_ac_der_EnterServiceType(stream, &DERControlType->EnterService);
                    if (error == 0)
                    {
                        DERControlType->EnterService_isUsed = 1u;
                        grammar_id = 303;
                    }
                    break;
                case 1:
                    // Event: START (ReactivePowerSupport, ReactivePowerSupportType (ReactivePowerSupportType)); next=304
                    // decode: element
                    error = decode_iso20_ac_der_ReactivePowerSupportType(stream, &DERControlType->ReactivePowerSupport);
                    if (error == 0)
                    {
                        DERControlType->ReactivePowerSupport_isUsed = 1u;
                        grammar_id = 304;
                    }
                    break;
                case 2:
                    // Event: START (ActivePowerSupport, ActivePowerSupportType (ActivePowerSupportType)); next=305
                    // decode: element
                    error = decode_iso20_ac_der_ActivePowerSupportType(stream, &DERControlType->ActivePowerSupport);
                    if (error == 0)
                    {
                        DERControlType->ActivePowerSupport_isUsed = 1u;
                        grammar_id = 305;
                    }
                    break;
                case 3:
                    // Event: START (MaximumLevel1DCInjection, RationalNumberType (RationalNumberType)); next=306
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel1DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel1DCInjection_isUsed = 1u;
                        grammar_id = 306;
                    }
                    break;
                case 4:
                    // Event: START (MaximumLevel2DCInjection, RationalNumberType (RationalNumberType)); next=307
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel2DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel2DCInjection_isUsed = 1u;
                        grammar_id = 307;
                    }
                    break;
                case 5:
                    // Event: START (SCRatPOC, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->SCRatPOC);
                    if (error == 0)
                    {
                        DERControlType->SCRatPOC_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 303:
            // Grammar: ID=303; read/write bits=3; START (ReactivePowerSupport), START (ActivePowerSupport), START (MaximumLevel1DCInjection), START (MaximumLevel2DCInjection), START (SCRatPOC), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ReactivePowerSupport, ReactivePowerSupportType (ReactivePowerSupportType)); next=304
                    // decode: element
                    error = decode_iso20_ac_der_ReactivePowerSupportType(stream, &DERControlType->ReactivePowerSupport);
                    if (error == 0)
                    {
                        DERControlType->ReactivePowerSupport_isUsed = 1u;
                        grammar_id = 304;
                    }
                    break;
                case 1:
                    // Event: START (ActivePowerSupport, ActivePowerSupportType (ActivePowerSupportType)); next=305
                    // decode: element
                    error = decode_iso20_ac_der_ActivePowerSupportType(stream, &DERControlType->ActivePowerSupport);
                    if (error == 0)
                    {
                        DERControlType->ActivePowerSupport_isUsed = 1u;
                        grammar_id = 305;
                    }
                    break;
                case 2:
                    // Event: START (MaximumLevel1DCInjection, RationalNumberType (RationalNumberType)); next=306
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel1DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel1DCInjection_isUsed = 1u;
                        grammar_id = 306;
                    }
                    break;
                case 3:
                    // Event: START (MaximumLevel2DCInjection, RationalNumberType (RationalNumberType)); next=307
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel2DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel2DCInjection_isUsed = 1u;
                        grammar_id = 307;
                    }
                    break;
                case 4:
                    // Event: START (SCRatPOC, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->SCRatPOC);
                    if (error == 0)
                    {
                        DERControlType->SCRatPOC_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 304:
            // Grammar: ID=304; read/write bits=3; START (ActivePowerSupport), START (MaximumLevel1DCInjection), START (MaximumLevel2DCInjection), START (SCRatPOC), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ActivePowerSupport, ActivePowerSupportType (ActivePowerSupportType)); next=305
                    // decode: element
                    error = decode_iso20_ac_der_ActivePowerSupportType(stream, &DERControlType->ActivePowerSupport);
                    if (error == 0)
                    {
                        DERControlType->ActivePowerSupport_isUsed = 1u;
                        grammar_id = 305;
                    }
                    break;
                case 1:
                    // Event: START (MaximumLevel1DCInjection, RationalNumberType (RationalNumberType)); next=306
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel1DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel1DCInjection_isUsed = 1u;
                        grammar_id = 306;
                    }
                    break;
                case 2:
                    // Event: START (MaximumLevel2DCInjection, RationalNumberType (RationalNumberType)); next=307
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel2DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel2DCInjection_isUsed = 1u;
                        grammar_id = 307;
                    }
                    break;
                case 3:
                    // Event: START (SCRatPOC, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->SCRatPOC);
                    if (error == 0)
                    {
                        DERControlType->SCRatPOC_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 305:
            // Grammar: ID=305; read/write bits=3; START (MaximumLevel1DCInjection), START (MaximumLevel2DCInjection), START (SCRatPOC), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MaximumLevel1DCInjection, RationalNumberType (RationalNumberType)); next=306
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel1DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel1DCInjection_isUsed = 1u;
                        grammar_id = 306;
                    }
                    break;
                case 1:
                    // Event: START (MaximumLevel2DCInjection, RationalNumberType (RationalNumberType)); next=307
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel2DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel2DCInjection_isUsed = 1u;
                        grammar_id = 307;
                    }
                    break;
                case 2:
                    // Event: START (SCRatPOC, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->SCRatPOC);
                    if (error == 0)
                    {
                        DERControlType->SCRatPOC_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 306:
            // Grammar: ID=306; read/write bits=2; START (MaximumLevel2DCInjection), START (SCRatPOC), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MaximumLevel2DCInjection, RationalNumberType (RationalNumberType)); next=307
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->MaximumLevel2DCInjection);
                    if (error == 0)
                    {
                        DERControlType->MaximumLevel2DCInjection_isUsed = 1u;
                        grammar_id = 307;
                    }
                    break;
                case 1:
                    // Event: START (SCRatPOC, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->SCRatPOC);
                    if (error == 0)
                    {
                        DERControlType->SCRatPOC_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 307:
            // Grammar: ID=307; read/write bits=2; START (SCRatPOC), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (SCRatPOC, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DERControlType->SCRatPOC);
                    if (error == 0)
                    {
                        DERControlType->SCRatPOC_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}GridLimits; type={urn:iso:std:iso:15118:-20:AC}GridLimitsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: GridNominalFrequency, RationalNumberType (1, 1); GridNominalVoltage, RationalNumberType (1, 1); GridNominalVoltageOffset, RationalNumberType (0, 1); GridMinFrequency, RationalNumberType (0, 1); GridMaxFrequency, RationalNumberType (0, 1); GridMaximumVoltage, RationalNumberType (0, 1); GridMinimumVoltage, RationalNumberType (0, 1);
static int decode_iso20_ac_der_GridLimitsType(exi_bitstream_t* stream, struct iso20_ac_der_GridLimitsType* GridLimitsType) {
    int grammar_id = 308;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_GridLimitsType(GridLimitsType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 308:
            // Grammar: ID=308; read/write bits=1; START (GridNominalFrequency)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (GridNominalFrequency, RationalNumberType (RationalNumberType)); next=309
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridNominalFrequency);
                    if (error == 0)
                    {
                        grammar_id = 309;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 309:
            // Grammar: ID=309; read/write bits=1; START (GridNominalVoltage)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (GridNominalVoltage, RationalNumberType (RationalNumberType)); next=310
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridNominalVoltage);
                    if (error == 0)
                    {
                        grammar_id = 310;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 310:
            // Grammar: ID=310; read/write bits=3; START (GridNominalVoltageOffset), START (GridMinFrequency), START (GridMaxFrequency), START (GridMaximumVoltage), START (GridMinimumVoltage), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (GridNominalVoltageOffset, RationalNumberType (RationalNumberType)); next=311
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridNominalVoltageOffset);
                    if (error == 0)
                    {
                        GridLimitsType->GridNominalVoltageOffset_isUsed = 1u;
                        grammar_id = 311;
                    }
                    break;
                case 1:
                    // Event: START (GridMinFrequency, RationalNumberType (RationalNumberType)); next=312
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMinFrequency);
                    if (error == 0)
                    {
                        GridLimitsType->GridMinFrequency_isUsed = 1u;
                        grammar_id = 312;
                    }
                    break;
                case 2:
                    // Event: START (GridMaxFrequency, RationalNumberType (RationalNumberType)); next=313
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMaxFrequency);
                    if (error == 0)
                    {
                        GridLimitsType->GridMaxFrequency_isUsed = 1u;
                        grammar_id = 313;
                    }
                    break;
                case 3:
                    // Event: START (GridMaximumVoltage, RationalNumberType (RationalNumberType)); next=314
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMaximumVoltage);
                    if (error == 0)
                    {
                        GridLimitsType->GridMaximumVoltage_isUsed = 1u;
                        grammar_id = 314;
                    }
                    break;
                case 4:
                    // Event: START (GridMinimumVoltage, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMinimumVoltage);
                    if (error == 0)
                    {
                        GridLimitsType->GridMinimumVoltage_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 311:
            // Grammar: ID=311; read/write bits=3; START (GridMinFrequency), START (GridMaxFrequency), START (GridMaximumVoltage), START (GridMinimumVoltage), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (GridMinFrequency, RationalNumberType (RationalNumberType)); next=312
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMinFrequency);
                    if (error == 0)
                    {
                        GridLimitsType->GridMinFrequency_isUsed = 1u;
                        grammar_id = 312;
                    }
                    break;
                case 1:
                    // Event: START (GridMaxFrequency, RationalNumberType (RationalNumberType)); next=313
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMaxFrequency);
                    if (error == 0)
                    {
                        GridLimitsType->GridMaxFrequency_isUsed = 1u;
                        grammar_id = 313;
                    }
                    break;
                case 2:
                    // Event: START (GridMaximumVoltage, RationalNumberType (RationalNumberType)); next=314
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMaximumVoltage);
                    if (error == 0)
                    {
                        GridLimitsType->GridMaximumVoltage_isUsed = 1u;
                        grammar_id = 314;
                    }
                    break;
                case 3:
                    // Event: START (GridMinimumVoltage, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMinimumVoltage);
                    if (error == 0)
                    {
                        GridLimitsType->GridMinimumVoltage_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 312:
            // Grammar: ID=312; read/write bits=3; START (GridMaxFrequency), START (GridMaximumVoltage), START (GridMinimumVoltage), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (GridMaxFrequency, RationalNumberType (RationalNumberType)); next=313
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMaxFrequency);
                    if (error == 0)
                    {
                        GridLimitsType->GridMaxFrequency_isUsed = 1u;
                        grammar_id = 313;
                    }
                    break;
                case 1:
                    // Event: START (GridMaximumVoltage, RationalNumberType (RationalNumberType)); next=314
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMaximumVoltage);
                    if (error == 0)
                    {
                        GridLimitsType->GridMaximumVoltage_isUsed = 1u;
                        grammar_id = 314;
                    }
                    break;
                case 2:
                    // Event: START (GridMinimumVoltage, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMinimumVoltage);
                    if (error == 0)
                    {
                        GridLimitsType->GridMinimumVoltage_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 313:
            // Grammar: ID=313; read/write bits=2; START (GridMaximumVoltage), START (GridMinimumVoltage), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (GridMaximumVoltage, RationalNumberType (RationalNumberType)); next=314
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMaximumVoltage);
                    if (error == 0)
                    {
                        GridLimitsType->GridMaximumVoltage_isUsed = 1u;
                        grammar_id = 314;
                    }
                    break;
                case 1:
                    // Event: START (GridMinimumVoltage, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMinimumVoltage);
                    if (error == 0)
                    {
                        GridLimitsType->GridMinimumVoltage_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 314:
            // Grammar: ID=314; read/write bits=2; START (GridMinimumVoltage), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (GridMinimumVoltage, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &GridLimitsType->GridMinimumVoltage);
                    if (error == 0)
                    {
                        GridLimitsType->GridMinimumVoltage_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}EVApparentPower; type={urn:iso:std:iso:15118:-20:AC}EVApparentPowerType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVMaximumChargeApparentPower, PhaseType (0, 1); EVMaximumDischargeApparentPower, PhaseType (0, 1);
static int decode_iso20_ac_der_EVApparentPowerType(exi_bitstream_t* stream, struct iso20_ac_der_EVApparentPowerType* EVApparentPowerType) {
    int grammar_id = 315;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_EVApparentPowerType(EVApparentPowerType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 315:
            // Grammar: ID=315; read/write bits=2; START (EVMaximumChargeApparentPower), START (EVMaximumDischargeApparentPower), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargeApparentPower, PhaseType (PhaseType)); next=316
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVApparentPowerType->EVMaximumChargeApparentPower);
                    if (error == 0)
                    {
                        EVApparentPowerType->EVMaximumChargeApparentPower_isUsed = 1u;
                        grammar_id = 316;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumDischargeApparentPower, PhaseType (PhaseType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVApparentPowerType->EVMaximumDischargeApparentPower);
                    if (error == 0)
                    {
                        EVApparentPowerType->EVMaximumDischargeApparentPower_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 316:
            // Grammar: ID=316; read/write bits=2; START (EVMaximumDischargeApparentPower), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargeApparentPower, PhaseType (PhaseType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVApparentPowerType->EVMaximumDischargeApparentPower);
                    if (error == 0)
                    {
                        EVApparentPowerType->EVMaximumDischargeApparentPower_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}EVReactivePower; type={urn:iso:std:iso:15118:-20:AC}EVReactivePowerType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVMaximumChargeReactivePower, PhaseType (0, 1); EVMinimumChargeReactivePower, PhaseType (0, 1); EVMaximumDischargeReactivePower, PhaseType (0, 1); EVMinimumDischargeReactivePower, PhaseType (0, 1);
static int decode_iso20_ac_der_EVReactivePowerType(exi_bitstream_t* stream, struct iso20_ac_der_EVReactivePowerType* EVReactivePowerType) {
    int grammar_id = 317;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_EVReactivePowerType(EVReactivePowerType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 317:
            // Grammar: ID=317; read/write bits=3; START (EVMaximumChargeReactivePower), START (EVMinimumChargeReactivePower), START (EVMaximumDischargeReactivePower), START (EVMinimumDischargeReactivePower), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargeReactivePower, PhaseType (PhaseType)); next=318
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVReactivePowerType->EVMaximumChargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerType->EVMaximumChargeReactivePower_isUsed = 1u;
                        grammar_id = 318;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargeReactivePower, PhaseType (PhaseType)); next=319
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVReactivePowerType->EVMinimumChargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerType->EVMinimumChargeReactivePower_isUsed = 1u;
                        grammar_id = 319;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumDischargeReactivePower, PhaseType (PhaseType)); next=320
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVReactivePowerType->EVMaximumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerType->EVMaximumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 320;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumDischargeReactivePower, PhaseType (PhaseType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVReactivePowerType->EVMinimumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerType->EVMinimumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 318:
            // Grammar: ID=318; read/write bits=3; START (EVMinimumChargeReactivePower), START (EVMaximumDischargeReactivePower), START (EVMinimumDischargeReactivePower), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargeReactivePower, PhaseType (PhaseType)); next=319
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVReactivePowerType->EVMinimumChargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerType->EVMinimumChargeReactivePower_isUsed = 1u;
                        grammar_id = 319;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumDischargeReactivePower, PhaseType (PhaseType)); next=320
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVReactivePowerType->EVMaximumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerType->EVMaximumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 320;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumDischargeReactivePower, PhaseType (PhaseType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVReactivePowerType->EVMinimumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerType->EVMinimumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 319:
            // Grammar: ID=319; read/write bits=2; START (EVMaximumDischargeReactivePower), START (EVMinimumDischargeReactivePower), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargeReactivePower, PhaseType (PhaseType)); next=320
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVReactivePowerType->EVMaximumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerType->EVMaximumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 320;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumDischargeReactivePower, PhaseType (PhaseType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVReactivePowerType->EVMinimumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerType->EVMinimumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 320:
            // Grammar: ID=320; read/write bits=2; START (EVMinimumDischargeReactivePower), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargeReactivePower, PhaseType (PhaseType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &EVReactivePowerType->EVMinimumDischargeReactivePower);
                    if (error == 0)
                    {
                        EVReactivePowerType->EVMinimumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}EVExcitation; type={urn:iso:std:iso:15118:-20:AC}EVExcitationType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVOverExcitedMaximumDischargePower, RationalNumberType (0, 1); EVOverExcitedPowerFactor, RationalNumberType (0, 1); EVUnderExcitedMaximumDischargePower, RationalNumberType (0, 1); EVUnderExcitedPowerFactor, RationalNumberType (0, 1);
static int decode_iso20_ac_der_EVExcitationType(exi_bitstream_t* stream, struct iso20_ac_der_EVExcitationType* EVExcitationType) {
    int grammar_id = 321;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_EVExcitationType(EVExcitationType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 321:
            // Grammar: ID=321; read/write bits=3; START (EVOverExcitedMaximumDischargePower), START (EVOverExcitedPowerFactor), START (EVUnderExcitedMaximumDischargePower), START (EVUnderExcitedPowerFactor), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVOverExcitedMaximumDischargePower, RationalNumberType (RationalNumberType)); next=322
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationType->EVOverExcitedMaximumDischargePower);
                    if (error == 0)
                    {
                        EVExcitationType->EVOverExcitedMaximumDischargePower_isUsed = 1u;
                        grammar_id = 322;
                    }
                    break;
                case 1:
                    // Event: START (EVOverExcitedPowerFactor, RationalNumberType (RationalNumberType)); next=323
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationType->EVOverExcitedPowerFactor);
                    if (error == 0)
                    {
                        EVExcitationType->EVOverExcitedPowerFactor_isUsed = 1u;
                        grammar_id = 323;
                    }
                    break;
                case 2:
                    // Event: START (EVUnderExcitedMaximumDischargePower, RationalNumberType (RationalNumberType)); next=324
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationType->EVUnderExcitedMaximumDischargePower);
                    if (error == 0)
                    {
                        EVExcitationType->EVUnderExcitedMaximumDischargePower_isUsed = 1u;
                        grammar_id = 324;
                    }
                    break;
                case 3:
                    // Event: START (EVUnderExcitedPowerFactor, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationType->EVUnderExcitedPowerFactor);
                    if (error == 0)
                    {
                        EVExcitationType->EVUnderExcitedPowerFactor_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 322:
            // Grammar: ID=322; read/write bits=3; START (EVOverExcitedPowerFactor), START (EVUnderExcitedMaximumDischargePower), START (EVUnderExcitedPowerFactor), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVOverExcitedPowerFactor, RationalNumberType (RationalNumberType)); next=323
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationType->EVOverExcitedPowerFactor);
                    if (error == 0)
                    {
                        EVExcitationType->EVOverExcitedPowerFactor_isUsed = 1u;
                        grammar_id = 323;
                    }
                    break;
                case 1:
                    // Event: START (EVUnderExcitedMaximumDischargePower, RationalNumberType (RationalNumberType)); next=324
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationType->EVUnderExcitedMaximumDischargePower);
                    if (error == 0)
                    {
                        EVExcitationType->EVUnderExcitedMaximumDischargePower_isUsed = 1u;
                        grammar_id = 324;
                    }
                    break;
                case 2:
                    // Event: START (EVUnderExcitedPowerFactor, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationType->EVUnderExcitedPowerFactor);
                    if (error == 0)
                    {
                        EVExcitationType->EVUnderExcitedPowerFactor_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 323:
            // Grammar: ID=323; read/write bits=2; START (EVUnderExcitedMaximumDischargePower), START (EVUnderExcitedPowerFactor), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVUnderExcitedMaximumDischargePower, RationalNumberType (RationalNumberType)); next=324
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationType->EVUnderExcitedMaximumDischargePower);
                    if (error == 0)
                    {
                        EVExcitationType->EVUnderExcitedMaximumDischargePower_isUsed = 1u;
                        grammar_id = 324;
                    }
                    break;
                case 1:
                    // Event: START (EVUnderExcitedPowerFactor, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationType->EVUnderExcitedPowerFactor);
                    if (error == 0)
                    {
                        EVExcitationType->EVUnderExcitedPowerFactor_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 324:
            // Grammar: ID=324; read/write bits=2; START (EVUnderExcitedPowerFactor), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVUnderExcitedPowerFactor, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVExcitationType->EVUnderExcitedPowerFactor);
                    if (error == 0)
                    {
                        EVExcitationType->EVUnderExcitedPowerFactor_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}EVSetPoints; type={urn:iso:std:iso:15118:-20:AC}EVSetPointsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVSetNominalVoltage, RationalNumberType (0, 1); EVSetNominalVoltageOffset, RationalNumberType (0, 1); EVSetMaximumNominalVoltage, RationalNumberType (0, 1); EVSetMinimumNominalVoltage, RationalNumberType (0, 1);
static int decode_iso20_ac_der_EVSetPointsType(exi_bitstream_t* stream, struct iso20_ac_der_EVSetPointsType* EVSetPointsType) {
    int grammar_id = 325;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_EVSetPointsType(EVSetPointsType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 325:
            // Grammar: ID=325; read/write bits=3; START (EVSetNominalVoltage), START (EVSetNominalVoltageOffset), START (EVSetMaximumNominalVoltage), START (EVSetMinimumNominalVoltage), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSetNominalVoltage, RationalNumberType (RationalNumberType)); next=326
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVSetPointsType->EVSetNominalVoltage);
                    if (error == 0)
                    {
                        EVSetPointsType->EVSetNominalVoltage_isUsed = 1u;
                        grammar_id = 326;
                    }
                    break;
                case 1:
                    // Event: START (EVSetNominalVoltageOffset, RationalNumberType (RationalNumberType)); next=327
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVSetPointsType->EVSetNominalVoltageOffset);
                    if (error == 0)
                    {
                        EVSetPointsType->EVSetNominalVoltageOffset_isUsed = 1u;
                        grammar_id = 327;
                    }
                    break;
                case 2:
                    // Event: START (EVSetMaximumNominalVoltage, RationalNumberType (RationalNumberType)); next=328
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVSetPointsType->EVSetMaximumNominalVoltage);
                    if (error == 0)
                    {
                        EVSetPointsType->EVSetMaximumNominalVoltage_isUsed = 1u;
                        grammar_id = 328;
                    }
                    break;
                case 3:
                    // Event: START (EVSetMinimumNominalVoltage, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVSetPointsType->EVSetMinimumNominalVoltage);
                    if (error == 0)
                    {
                        EVSetPointsType->EVSetMinimumNominalVoltage_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 326:
            // Grammar: ID=326; read/write bits=3; START (EVSetNominalVoltageOffset), START (EVSetMaximumNominalVoltage), START (EVSetMinimumNominalVoltage), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSetNominalVoltageOffset, RationalNumberType (RationalNumberType)); next=327
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVSetPointsType->EVSetNominalVoltageOffset);
                    if (error == 0)
                    {
                        EVSetPointsType->EVSetNominalVoltageOffset_isUsed = 1u;
                        grammar_id = 327;
                    }
                    break;
                case 1:
                    // Event: START (EVSetMaximumNominalVoltage, RationalNumberType (RationalNumberType)); next=328
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVSetPointsType->EVSetMaximumNominalVoltage);
                    if (error == 0)
                    {
                        EVSetPointsType->EVSetMaximumNominalVoltage_isUsed = 1u;
                        grammar_id = 328;
                    }
                    break;
                case 2:
                    // Event: START (EVSetMinimumNominalVoltage, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVSetPointsType->EVSetMinimumNominalVoltage);
                    if (error == 0)
                    {
                        EVSetPointsType->EVSetMinimumNominalVoltage_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 327:
            // Grammar: ID=327; read/write bits=2; START (EVSetMaximumNominalVoltage), START (EVSetMinimumNominalVoltage), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSetMaximumNominalVoltage, RationalNumberType (RationalNumberType)); next=328
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVSetPointsType->EVSetMaximumNominalVoltage);
                    if (error == 0)
                    {
                        EVSetPointsType->EVSetMaximumNominalVoltage_isUsed = 1u;
                        grammar_id = 328;
                    }
                    break;
                case 1:
                    // Event: START (EVSetMinimumNominalVoltage, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVSetPointsType->EVSetMinimumNominalVoltage);
                    if (error == 0)
                    {
                        EVSetPointsType->EVSetMinimumNominalVoltage_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 328:
            // Grammar: ID=328; read/write bits=2; START (EVSetMinimumNominalVoltage), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSetMinimumNominalVoltage, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &EVSetPointsType->EVSetMinimumNominalVoltage);
                    if (error == 0)
                    {
                        EVSetPointsType->EVSetMinimumNominalVoltage_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}DERGridSupportActiveInfo; type={urn:iso:std:iso:15118:-20:AC}DERGridSupportActiveInfoType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: DERFunctionName, derFunctionNameType (0, 1); GridEventFault, gridEventFaultType (0, 1); ExtraInfo, extraInfoType (0, 1); EventCondition, boolean (1, 1);
static int decode_iso20_ac_der_DERGridSupportActiveInfoType(exi_bitstream_t* stream, struct iso20_ac_der_DERGridSupportActiveInfoType* DERGridSupportActiveInfoType) {
    int grammar_id = 329;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DERGridSupportActiveInfoType(DERGridSupportActiveInfoType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 329:
            // Grammar: ID=329; read/write bits=3; START (DERFunctionName), START (GridEventFault), START (ExtraInfo), START (EventCondition)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DERFunctionName, derFunctionNameType (string)); next=330
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                DERGridSupportActiveInfoType->DERFunctionName = (iso20_ac_der_derFunctionNameType)value;
                                DERGridSupportActiveInfoType->DERFunctionName_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 330;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (GridEventFault, gridEventFaultType (string)); next=331
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                DERGridSupportActiveInfoType->GridEventFault = (iso20_ac_der_gridEventFaultType)value;
                                DERGridSupportActiveInfoType->GridEventFault_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 331;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (ExtraInfo, extraInfoType (string)); next=332
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &DERGridSupportActiveInfoType->ExtraInfo.charactersLen);
                            if (error == 0)
                            {
                                if (DERGridSupportActiveInfoType->ExtraInfo.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    DERGridSupportActiveInfoType->ExtraInfo.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, DERGridSupportActiveInfoType->ExtraInfo.charactersLen, DERGridSupportActiveInfoType->ExtraInfo.characters, iso20_ac_der_ExtraInfo_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                DERGridSupportActiveInfoType->ExtraInfo_isUsed = 1u;
                                grammar_id = 332;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 3:
                    // Event: START (EventCondition, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DERGridSupportActiveInfoType->EventCondition = value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 330:
            // Grammar: ID=330; read/write bits=2; START (GridEventFault), START (ExtraInfo), START (EventCondition)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (GridEventFault, gridEventFaultType (string)); next=331
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 4, &value);
                            if (error == 0)
                            {
                                DERGridSupportActiveInfoType->GridEventFault = (iso20_ac_der_gridEventFaultType)value;
                                DERGridSupportActiveInfoType->GridEventFault_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 331;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (ExtraInfo, extraInfoType (string)); next=332
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &DERGridSupportActiveInfoType->ExtraInfo.charactersLen);
                            if (error == 0)
                            {
                                if (DERGridSupportActiveInfoType->ExtraInfo.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    DERGridSupportActiveInfoType->ExtraInfo.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, DERGridSupportActiveInfoType->ExtraInfo.charactersLen, DERGridSupportActiveInfoType->ExtraInfo.characters, iso20_ac_der_ExtraInfo_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                DERGridSupportActiveInfoType->ExtraInfo_isUsed = 1u;
                                grammar_id = 332;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (EventCondition, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DERGridSupportActiveInfoType->EventCondition = value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 331:
            // Grammar: ID=331; read/write bits=2; START (ExtraInfo), START (EventCondition)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ExtraInfo, extraInfoType (string)); next=332
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &DERGridSupportActiveInfoType->ExtraInfo.charactersLen);
                            if (error == 0)
                            {
                                if (DERGridSupportActiveInfoType->ExtraInfo.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    DERGridSupportActiveInfoType->ExtraInfo.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, DERGridSupportActiveInfoType->ExtraInfo.charactersLen, DERGridSupportActiveInfoType->ExtraInfo.characters, iso20_ac_der_ExtraInfo_CHARACTER_SIZE);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                DERGridSupportActiveInfoType->ExtraInfo_isUsed = 1u;
                                grammar_id = 332;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (EventCondition, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DERGridSupportActiveInfoType->EventCondition = value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 332:
            // Grammar: ID=332; read/write bits=1; START (EventCondition)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EventCondition, boolean (boolean)); next=2
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                DERGridSupportActiveInfoType->EventCondition = value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}BPT_AC_CPDReqEnergyTransferMode; type={urn:iso:std:iso:15118:-20:AC}BPT_AC_CPDReqEnergyTransferModeType; base type=AC_CPDReqEnergyTransferModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: EVMaximumChargePower, RationalNumberType (1, 1); EVMaximumChargePower_L2, RationalNumberType (0, 1); EVMaximumChargePower_L3, RationalNumberType (0, 1); EVMinimumChargePower, RationalNumberType (1, 1); EVMinimumChargePower_L2, RationalNumberType (0, 1); EVMinimumChargePower_L3, RationalNumberType (0, 1); EVMaximumDischargePower, RationalNumberType (1, 1); EVMaximumDischargePower_L2, RationalNumberType (0, 1); EVMaximumDischargePower_L3, RationalNumberType (0, 1); EVMinimumDischargePower, RationalNumberType (1, 1); EVMinimumDischargePower_L2, RationalNumberType (0, 1); EVMinimumDischargePower_L3, RationalNumberType (0, 1);
static int decode_iso20_ac_der_BPT_AC_CPDReqEnergyTransferModeType(exi_bitstream_t* stream, struct iso20_ac_der_BPT_AC_CPDReqEnergyTransferModeType* BPT_AC_CPDReqEnergyTransferModeType) {
    int grammar_id = 333;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_BPT_AC_CPDReqEnergyTransferModeType(BPT_AC_CPDReqEnergyTransferModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 333:
            // Grammar: ID=333; read/write bits=1; START (EVMaximumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=334
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 334;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 334:
            // Grammar: ID=334; read/write bits=2; START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=335
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 335;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=336
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 336;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=337
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 337;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 335:
            // Grammar: ID=335; read/write bits=2; START (EVMaximumChargePower_L3), START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=336
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 336;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=337
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 337;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 336:
            // Grammar: ID=336; read/write bits=1; START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=337
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 337;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 337:
            // Grammar: ID=337; read/write bits=2; START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=338
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 338;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=339
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 339;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumDischargePower, RationalNumberType (RationalNumberType)); next=340
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 340;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 338:
            // Grammar: ID=338; read/write bits=2; START (EVMinimumChargePower_L3), START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=339
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 339;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumDischargePower, RationalNumberType (RationalNumberType)); next=340
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 340;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 339:
            // Grammar: ID=339; read/write bits=1; START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargePower, RationalNumberType (RationalNumberType)); next=340
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 340;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 340:
            // Grammar: ID=340; read/write bits=2; START (EVMaximumDischargePower_L2), START (EVMaximumDischargePower_L3), START (EVMinimumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargePower_L2, RationalNumberType (RationalNumberType)); next=341
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMaximumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_AC_CPDReqEnergyTransferModeType->EVMaximumDischargePower_L2_isUsed = 1u;
                        grammar_id = 341;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=342
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDReqEnergyTransferModeType->EVMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 342;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=343
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 343;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 341:
            // Grammar: ID=341; read/write bits=2; START (EVMaximumDischargePower_L3), START (EVMinimumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=342
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDReqEnergyTransferModeType->EVMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 342;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=343
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 343;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 342:
            // Grammar: ID=342; read/write bits=1; START (EVMinimumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=343
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 343;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 343:
            // Grammar: ID=343; read/write bits=2; START (EVMinimumDischargePower_L2), START (EVMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargePower_L2, RationalNumberType (RationalNumberType)); next=344
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMinimumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_AC_CPDReqEnergyTransferModeType->EVMinimumDischargePower_L2_isUsed = 1u;
                        grammar_id = 344;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDReqEnergyTransferModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 344:
            // Grammar: ID=344; read/write bits=2; START (EVMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDReqEnergyTransferModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDReqEnergyTransferModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}BPT_AC_CPDResEnergyTransferMode; type={urn:iso:std:iso:15118:-20:AC}BPT_AC_CPDResEnergyTransferModeType; base type=AC_CPDResEnergyTransferModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: EVSEMaximumChargePower, RationalNumberType (1, 1); EVSEMaximumChargePower_L2, RationalNumberType (0, 1); EVSEMaximumChargePower_L3, RationalNumberType (0, 1); EVSEMinimumChargePower, RationalNumberType (1, 1); EVSEMinimumChargePower_L2, RationalNumberType (0, 1); EVSEMinimumChargePower_L3, RationalNumberType (0, 1); EVSENominalFrequency, RationalNumberType (1, 1); MaximumPowerAsymmetry, RationalNumberType (0, 1); EVSEPowerRampLimitation, RationalNumberType (0, 1); EVSEPresentActivePower, RationalNumberType (0, 1); EVSEPresentActivePower_L2, RationalNumberType (0, 1); EVSEPresentActivePower_L3, RationalNumberType (0, 1); EVSEMaximumDischargePower, RationalNumberType (1, 1); EVSEMaximumDischargePower_L2, RationalNumberType (0, 1); EVSEMaximumDischargePower_L3, RationalNumberType (0, 1); EVSEMinimumDischargePower, RationalNumberType (1, 1); EVSEMinimumDischargePower_L2, RationalNumberType (0, 1); EVSEMinimumDischargePower_L3, RationalNumberType (0, 1);
static int decode_iso20_ac_der_BPT_AC_CPDResEnergyTransferModeType(exi_bitstream_t* stream, struct iso20_ac_der_BPT_AC_CPDResEnergyTransferModeType* BPT_AC_CPDResEnergyTransferModeType) {
    int grammar_id = 345;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_BPT_AC_CPDResEnergyTransferModeType(BPT_AC_CPDResEnergyTransferModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 345:
            // Grammar: ID=345; read/write bits=1; START (EVSEMaximumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumChargePower, RationalNumberType (RationalNumberType)); next=346
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 346;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 346:
            // Grammar: ID=346; read/write bits=2; START (EVSEMaximumChargePower_L2), START (EVSEMaximumChargePower_L3), START (EVSEMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=347
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 347;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=348
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 348;
                    }
                    break;
                case 2:
                    // Event: START (EVSEMinimumChargePower, RationalNumberType (RationalNumberType)); next=349
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 349;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 347:
            // Grammar: ID=347; read/write bits=2; START (EVSEMaximumChargePower_L3), START (EVSEMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=348
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 348;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMinimumChargePower, RationalNumberType (RationalNumberType)); next=349
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 349;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 348:
            // Grammar: ID=348; read/write bits=1; START (EVSEMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMinimumChargePower, RationalNumberType (RationalNumberType)); next=349
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 349;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 349:
            // Grammar: ID=349; read/write bits=2; START (EVSEMinimumChargePower_L2), START (EVSEMinimumChargePower_L3), START (EVSENominalFrequency)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=350
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 350;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=351
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 351;
                    }
                    break;
                case 2:
                    // Event: START (EVSENominalFrequency, RationalNumberType (RationalNumberType)); next=352
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSENominalFrequency);
                    if (error == 0)
                    {
                        grammar_id = 352;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 350:
            // Grammar: ID=350; read/write bits=2; START (EVSEMinimumChargePower_L3), START (EVSENominalFrequency)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=351
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 351;
                    }
                    break;
                case 1:
                    // Event: START (EVSENominalFrequency, RationalNumberType (RationalNumberType)); next=352
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSENominalFrequency);
                    if (error == 0)
                    {
                        grammar_id = 352;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 351:
            // Grammar: ID=351; read/write bits=1; START (EVSENominalFrequency)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSENominalFrequency, RationalNumberType (RationalNumberType)); next=352
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSENominalFrequency);
                    if (error == 0)
                    {
                        grammar_id = 352;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 352:
            // Grammar: ID=352; read/write bits=3; START (MaximumPowerAsymmetry), START (EVSEPowerRampLimitation), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (EVSEMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MaximumPowerAsymmetry, RationalNumberType (RationalNumberType)); next=353
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->MaximumPowerAsymmetry);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->MaximumPowerAsymmetry_isUsed = 1u;
                        grammar_id = 353;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPowerRampLimitation, RationalNumberType (RationalNumberType)); next=354
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPowerRampLimitation);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPowerRampLimitation_isUsed = 1u;
                        grammar_id = 354;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=355
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 355;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=356
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 356;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=357
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 357;
                    }
                    break;
                case 5:
                    // Event: START (EVSEMaximumDischargePower, RationalNumberType (RationalNumberType)); next=358
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 358;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 353:
            // Grammar: ID=353; read/write bits=3; START (EVSEPowerRampLimitation), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (EVSEMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPowerRampLimitation, RationalNumberType (RationalNumberType)); next=354
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPowerRampLimitation);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPowerRampLimitation_isUsed = 1u;
                        grammar_id = 354;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=355
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 355;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=356
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 356;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=357
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 357;
                    }
                    break;
                case 4:
                    // Event: START (EVSEMaximumDischargePower, RationalNumberType (RationalNumberType)); next=358
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 358;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 354:
            // Grammar: ID=354; read/write bits=3; START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (EVSEMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=355
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 355;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=356
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 356;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=357
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 357;
                    }
                    break;
                case 3:
                    // Event: START (EVSEMaximumDischargePower, RationalNumberType (RationalNumberType)); next=358
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 358;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 355:
            // Grammar: ID=355; read/write bits=2; START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (EVSEMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=356
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 356;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=357
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 357;
                    }
                    break;
                case 2:
                    // Event: START (EVSEMaximumDischargePower, RationalNumberType (RationalNumberType)); next=358
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 358;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 356:
            // Grammar: ID=356; read/write bits=2; START (EVSEPresentActivePower_L3), START (EVSEMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=357
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 357;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMaximumDischargePower, RationalNumberType (RationalNumberType)); next=358
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 358;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 357:
            // Grammar: ID=357; read/write bits=1; START (EVSEMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumDischargePower, RationalNumberType (RationalNumberType)); next=358
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 358;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 358:
            // Grammar: ID=358; read/write bits=2; START (EVSEMaximumDischargePower_L2), START (EVSEMaximumDischargePower_L3), START (EVSEMinimumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumDischargePower_L2, RationalNumberType (RationalNumberType)); next=359
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower_L2_isUsed = 1u;
                        grammar_id = 359;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=360
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 360;
                    }
                    break;
                case 2:
                    // Event: START (EVSEMinimumDischargePower, RationalNumberType (RationalNumberType)); next=361
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 361;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 359:
            // Grammar: ID=359; read/write bits=2; START (EVSEMaximumDischargePower_L3), START (EVSEMinimumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=360
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 360;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMinimumDischargePower, RationalNumberType (RationalNumberType)); next=361
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 361;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 360:
            // Grammar: ID=360; read/write bits=1; START (EVSEMinimumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMinimumDischargePower, RationalNumberType (RationalNumberType)); next=361
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 361;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 361:
            // Grammar: ID=361; read/write bits=2; START (EVSEMinimumDischargePower_L2), START (EVSEMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMinimumDischargePower_L2, RationalNumberType (RationalNumberType)); next=362
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumDischargePower_L2_isUsed = 1u;
                        grammar_id = 362;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 362:
            // Grammar: ID=362; read/write bits=2; START (EVSEMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_AC_CPDResEnergyTransferModeType->EVSEMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}DER_AC_CPDReqEnergyTransferMode; type={urn:iso:std:iso:15118:-20:AC}DER_AC_CPDReqEnergyTransferModeType; base type=AC_CPDReqEnergyTransferModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: EVMaximumChargePower, RationalNumberType (1, 1); EVMaximumChargePower_L2, RationalNumberType (0, 1); EVMaximumChargePower_L3, RationalNumberType (0, 1); EVMinimumChargePower, RationalNumberType (1, 1); EVMinimumChargePower_L2, RationalNumberType (0, 1); EVMinimumChargePower_L3, RationalNumberType (0, 1); EVProcessing, processingType (1, 1); EVMaximumDischargePower, PhaseType (1, 1); EVMinimumDischargePower, PhaseType (1, 1); EVSessionTotalDischargeEnergyAvailable, RationalNumberType (0, 1); EVApparentPowerLimits, EVApparentPowerLimitsType (0, 1); EVReactivePowerLimits, EVReactivePowerLimitsType (0, 1); EVExcitationLimits, EVExcitationLimitsType (0, 1); EVInverterDetails, EVInverterDetailsType (0, 1);
static int decode_iso20_ac_der_DER_AC_CPDReqEnergyTransferModeType(exi_bitstream_t* stream, struct iso20_ac_der_DER_AC_CPDReqEnergyTransferModeType* DER_AC_CPDReqEnergyTransferModeType) {
    int grammar_id = 363;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DER_AC_CPDReqEnergyTransferModeType(DER_AC_CPDReqEnergyTransferModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 363:
            // Grammar: ID=363; read/write bits=1; START (EVMaximumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=364
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 364;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 364:
            // Grammar: ID=364; read/write bits=2; START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=365
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 365;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=366
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 366;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=367
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 367;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 365:
            // Grammar: ID=365; read/write bits=2; START (EVMaximumChargePower_L3), START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=366
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 366;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=367
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 367;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 366:
            // Grammar: ID=366; read/write bits=1; START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=367
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 367;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 367:
            // Grammar: ID=367; read/write bits=2; START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVProcessing)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=368
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 368;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=369
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 369;
                    }
                    break;
                case 2:
                    // Event: START (EVProcessing, processingType (string)); next=370
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                DER_AC_CPDReqEnergyTransferModeType->EVProcessing = (iso20_ac_der_processingType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 370;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 368:
            // Grammar: ID=368; read/write bits=2; START (EVMinimumChargePower_L3), START (EVProcessing)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=369
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 369;
                    }
                    break;
                case 1:
                    // Event: START (EVProcessing, processingType (string)); next=370
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                DER_AC_CPDReqEnergyTransferModeType->EVProcessing = (iso20_ac_der_processingType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 370;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 369:
            // Grammar: ID=369; read/write bits=1; START (EVProcessing)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVProcessing, processingType (string)); next=370
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                DER_AC_CPDReqEnergyTransferModeType->EVProcessing = (iso20_ac_der_processingType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 370;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 370:
            // Grammar: ID=370; read/write bits=1; START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargePower, PhaseType (PhaseType)); next=371
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 371;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 371:
            // Grammar: ID=371; read/write bits=1; START (EVMinimumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargePower, PhaseType (PhaseType)); next=372
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 372;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 372:
            // Grammar: ID=372; read/write bits=3; START (EVSessionTotalDischargeEnergyAvailable), START (EVApparentPowerLimits), START (EVReactivePowerLimits), START (EVExcitationLimits), START (EVInverterDetails), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSessionTotalDischargeEnergyAvailable, RationalNumberType (RationalNumberType)); next=373
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVSessionTotalDischargeEnergyAvailable);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVSessionTotalDischargeEnergyAvailable_isUsed = 1u;
                        grammar_id = 373;
                    }
                    break;
                case 1:
                    // Event: START (EVApparentPowerLimits, EVApparentPowerLimitsType (EVApparentPowerLimitsType)); next=374
                    // decode: element
                    error = decode_iso20_ac_der_EVApparentPowerLimitsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVApparentPowerLimits);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVApparentPowerLimits_isUsed = 1u;
                        grammar_id = 374;
                    }
                    break;
                case 2:
                    // Event: START (EVReactivePowerLimits, EVReactivePowerLimitsType (EVReactivePowerLimitsType)); next=375
                    // decode: element
                    error = decode_iso20_ac_der_EVReactivePowerLimitsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVReactivePowerLimits);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVReactivePowerLimits_isUsed = 1u;
                        grammar_id = 375;
                    }
                    break;
                case 3:
                    // Event: START (EVExcitationLimits, EVExcitationLimitsType (EVExcitationLimitsType)); next=376
                    // decode: element
                    error = decode_iso20_ac_der_EVExcitationLimitsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVExcitationLimits);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVExcitationLimits_isUsed = 1u;
                        grammar_id = 376;
                    }
                    break;
                case 4:
                    // Event: START (EVInverterDetails, EVInverterDetailsType (EVInverterDetailsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EVInverterDetailsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVInverterDetails);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVInverterDetails_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 373:
            // Grammar: ID=373; read/write bits=3; START (EVApparentPowerLimits), START (EVReactivePowerLimits), START (EVExcitationLimits), START (EVInverterDetails), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVApparentPowerLimits, EVApparentPowerLimitsType (EVApparentPowerLimitsType)); next=374
                    // decode: element
                    error = decode_iso20_ac_der_EVApparentPowerLimitsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVApparentPowerLimits);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVApparentPowerLimits_isUsed = 1u;
                        grammar_id = 374;
                    }
                    break;
                case 1:
                    // Event: START (EVReactivePowerLimits, EVReactivePowerLimitsType (EVReactivePowerLimitsType)); next=375
                    // decode: element
                    error = decode_iso20_ac_der_EVReactivePowerLimitsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVReactivePowerLimits);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVReactivePowerLimits_isUsed = 1u;
                        grammar_id = 375;
                    }
                    break;
                case 2:
                    // Event: START (EVExcitationLimits, EVExcitationLimitsType (EVExcitationLimitsType)); next=376
                    // decode: element
                    error = decode_iso20_ac_der_EVExcitationLimitsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVExcitationLimits);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVExcitationLimits_isUsed = 1u;
                        grammar_id = 376;
                    }
                    break;
                case 3:
                    // Event: START (EVInverterDetails, EVInverterDetailsType (EVInverterDetailsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EVInverterDetailsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVInverterDetails);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVInverterDetails_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 374:
            // Grammar: ID=374; read/write bits=3; START (EVReactivePowerLimits), START (EVExcitationLimits), START (EVInverterDetails), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVReactivePowerLimits, EVReactivePowerLimitsType (EVReactivePowerLimitsType)); next=375
                    // decode: element
                    error = decode_iso20_ac_der_EVReactivePowerLimitsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVReactivePowerLimits);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVReactivePowerLimits_isUsed = 1u;
                        grammar_id = 375;
                    }
                    break;
                case 1:
                    // Event: START (EVExcitationLimits, EVExcitationLimitsType (EVExcitationLimitsType)); next=376
                    // decode: element
                    error = decode_iso20_ac_der_EVExcitationLimitsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVExcitationLimits);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVExcitationLimits_isUsed = 1u;
                        grammar_id = 376;
                    }
                    break;
                case 2:
                    // Event: START (EVInverterDetails, EVInverterDetailsType (EVInverterDetailsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EVInverterDetailsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVInverterDetails);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVInverterDetails_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 375:
            // Grammar: ID=375; read/write bits=2; START (EVExcitationLimits), START (EVInverterDetails), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVExcitationLimits, EVExcitationLimitsType (EVExcitationLimitsType)); next=376
                    // decode: element
                    error = decode_iso20_ac_der_EVExcitationLimitsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVExcitationLimits);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVExcitationLimits_isUsed = 1u;
                        grammar_id = 376;
                    }
                    break;
                case 1:
                    // Event: START (EVInverterDetails, EVInverterDetailsType (EVInverterDetailsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EVInverterDetailsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVInverterDetails);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVInverterDetails_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 376:
            // Grammar: ID=376; read/write bits=2; START (EVInverterDetails), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVInverterDetails, EVInverterDetailsType (EVInverterDetailsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_EVInverterDetailsType(stream, &DER_AC_CPDReqEnergyTransferModeType->EVInverterDetails);
                    if (error == 0)
                    {
                        DER_AC_CPDReqEnergyTransferModeType->EVInverterDetails_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}AC_ChargeParameterDiscoveryReq; type={urn:iso:std:iso:15118:-20:AC}AC_ChargeParameterDiscoveryReqType; base type=ChargeParameterDiscoveryReqType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); AC_CPDReqEnergyTransferMode, AC_CPDReqEnergyTransferModeType (0, 1); BPT_AC_CPDReqEnergyTransferMode, BPT_AC_CPDReqEnergyTransferModeType (0, 1); DER_AC_CPDReqEnergyTransferMode, DER_AC_CPDReqEnergyTransferModeType (0, 1);
static int decode_iso20_ac_der_AC_ChargeParameterDiscoveryReqType(exi_bitstream_t* stream, struct iso20_ac_der_AC_ChargeParameterDiscoveryReqType* AC_ChargeParameterDiscoveryReqType) {
    int grammar_id = 377;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_AC_ChargeParameterDiscoveryReqType(AC_ChargeParameterDiscoveryReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 377:
            // Grammar: ID=377; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=378
                    // decode: element
                    error = decode_iso20_ac_der_MessageHeaderType(stream, &AC_ChargeParameterDiscoveryReqType->Header);
                    if (error == 0)
                    {
                        grammar_id = 378;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 378:
            // Grammar: ID=378; read/write bits=2; START (AC_CPDReqEnergyTransferMode), START (BPT_AC_CPDReqEnergyTransferMode), START (DER_AC_CPDReqEnergyTransferMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (AC_CPDReqEnergyTransferMode, AC_CPDReqEnergyTransferModeType (AC_CPDReqEnergyTransferModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_AC_CPDReqEnergyTransferModeType(stream, &AC_ChargeParameterDiscoveryReqType->AC_CPDReqEnergyTransferMode);
                    if (error == 0)
                    {
                        AC_ChargeParameterDiscoveryReqType->AC_CPDReqEnergyTransferMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: START (BPT_AC_CPDReqEnergyTransferMode, BPT_AC_CPDReqEnergyTransferModeType (AC_CPDReqEnergyTransferModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_AC_CPDReqEnergyTransferModeType(stream, &AC_ChargeParameterDiscoveryReqType->BPT_AC_CPDReqEnergyTransferMode);
                    if (error == 0)
                    {
                        AC_ChargeParameterDiscoveryReqType->BPT_AC_CPDReqEnergyTransferMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: START (DER_AC_CPDReqEnergyTransferMode, DER_AC_CPDReqEnergyTransferModeType (AC_CPDReqEnergyTransferModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_AC_CPDReqEnergyTransferModeType(stream, &AC_ChargeParameterDiscoveryReqType->DER_AC_CPDReqEnergyTransferMode);
                    if (error == 0)
                    {
                        AC_ChargeParameterDiscoveryReqType->DER_AC_CPDReqEnergyTransferMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}BPT_Scheduled_AC_CLReqControlMode; type={urn:iso:std:iso:15118:-20:AC}BPT_Scheduled_AC_CLReqControlModeType; base type=Scheduled_AC_CLReqControlModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: EVTargetEnergyRequest, RationalNumberType (0, 1); EVMaximumEnergyRequest, RationalNumberType (0, 1); EVMinimumEnergyRequest, RationalNumberType (0, 1); EVMaximumChargePower, RationalNumberType (0, 1); EVMaximumChargePower_L2, RationalNumberType (0, 1); EVMaximumChargePower_L3, RationalNumberType (0, 1); EVMinimumChargePower, RationalNumberType (0, 1); EVMinimumChargePower_L2, RationalNumberType (0, 1); EVMinimumChargePower_L3, RationalNumberType (0, 1); EVPresentActivePower, RationalNumberType (1, 1); EVPresentActivePower_L2, RationalNumberType (0, 1); EVPresentActivePower_L3, RationalNumberType (0, 1); EVPresentReactivePower, RationalNumberType (0, 1); EVPresentReactivePower_L2, RationalNumberType (0, 1); EVPresentReactivePower_L3, RationalNumberType (0, 1); EVMaximumDischargePower, RationalNumberType (0, 1); EVMaximumDischargePower_L2, RationalNumberType (0, 1); EVMaximumDischargePower_L3, RationalNumberType (0, 1); EVMinimumDischargePower, RationalNumberType (0, 1); EVMinimumDischargePower_L2, RationalNumberType (0, 1); EVMinimumDischargePower_L3, RationalNumberType (0, 1);
static int decode_iso20_ac_der_BPT_Scheduled_AC_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_BPT_Scheduled_AC_CLReqControlModeType* BPT_Scheduled_AC_CLReqControlModeType) {
    int grammar_id = 379;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_BPT_Scheduled_AC_CLReqControlModeType(BPT_Scheduled_AC_CLReqControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 379:
            // Grammar: ID=379; read/write bits=4; START (EVTargetEnergyRequest), START (EVMaximumEnergyRequest), START (EVMinimumEnergyRequest), START (EVMaximumChargePower), START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=380
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVTargetEnergyRequest);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVTargetEnergyRequest_isUsed = 1u;
                        grammar_id = 380;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumEnergyRequest, RationalNumberType (RationalNumberType)); next=381
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumEnergyRequest);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumEnergyRequest_isUsed = 1u;
                        grammar_id = 381;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=382
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest_isUsed = 1u;
                        grammar_id = 382;
                    }
                    break;
                case 3:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=383
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_isUsed = 1u;
                        grammar_id = 383;
                    }
                    break;
                case 4:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=384
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 384;
                    }
                    break;
                case 5:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=385
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 385;
                    }
                    break;
                case 6:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=386
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 386;
                    }
                    break;
                case 7:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=387
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 387;
                    }
                    break;
                case 8:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=388
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 388;
                    }
                    break;
                case 9:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=389
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 389;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 380:
            // Grammar: ID=380; read/write bits=4; START (EVMaximumEnergyRequest), START (EVMinimumEnergyRequest), START (EVMaximumChargePower), START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumEnergyRequest, RationalNumberType (RationalNumberType)); next=381
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumEnergyRequest);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumEnergyRequest_isUsed = 1u;
                        grammar_id = 381;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=382
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest_isUsed = 1u;
                        grammar_id = 382;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=383
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_isUsed = 1u;
                        grammar_id = 383;
                    }
                    break;
                case 3:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=384
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 384;
                    }
                    break;
                case 4:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=385
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 385;
                    }
                    break;
                case 5:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=386
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 386;
                    }
                    break;
                case 6:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=387
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 387;
                    }
                    break;
                case 7:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=388
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 388;
                    }
                    break;
                case 8:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=389
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 389;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 381:
            // Grammar: ID=381; read/write bits=4; START (EVMinimumEnergyRequest), START (EVMaximumChargePower), START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=382
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest_isUsed = 1u;
                        grammar_id = 382;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=383
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_isUsed = 1u;
                        grammar_id = 383;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=384
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 384;
                    }
                    break;
                case 3:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=385
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 385;
                    }
                    break;
                case 4:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=386
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 386;
                    }
                    break;
                case 5:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=387
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 387;
                    }
                    break;
                case 6:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=388
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 388;
                    }
                    break;
                case 7:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=389
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 389;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 382:
            // Grammar: ID=382; read/write bits=3; START (EVMaximumChargePower), START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=383
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_isUsed = 1u;
                        grammar_id = 383;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=384
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 384;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=385
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 385;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=386
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 386;
                    }
                    break;
                case 4:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=387
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 387;
                    }
                    break;
                case 5:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=388
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 388;
                    }
                    break;
                case 6:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=389
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 389;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 383:
            // Grammar: ID=383; read/write bits=3; START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=384
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 384;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=385
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 385;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=386
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 386;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=387
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 387;
                    }
                    break;
                case 4:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=388
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 388;
                    }
                    break;
                case 5:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=389
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 389;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 384:
            // Grammar: ID=384; read/write bits=3; START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=385
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 385;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=386
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 386;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=387
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 387;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=388
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 388;
                    }
                    break;
                case 4:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=389
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 389;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 385:
            // Grammar: ID=385; read/write bits=3; START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=386
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 386;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=387
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 387;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=388
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 388;
                    }
                    break;
                case 3:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=389
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 389;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 386:
            // Grammar: ID=386; read/write bits=2; START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=387
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 387;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=388
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 388;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=389
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 389;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 387:
            // Grammar: ID=387; read/write bits=2; START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=388
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 388;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=389
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 389;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 388:
            // Grammar: ID=388; read/write bits=1; START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=389
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 389;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 389:
            // Grammar: ID=389; read/write bits=4; START (EVPresentActivePower_L2), START (EVPresentActivePower_L3), START (EVPresentReactivePower), START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), START (EVMaximumDischargePower), START (EVMaximumDischargePower_L2), START (EVMaximumDischargePower_L3), START (EVMinimumDischargePower), START (EVMinimumDischargePower_L2), START (EVMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=390
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 390;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=391
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 391;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=392
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_isUsed = 1u;
                        grammar_id = 392;
                    }
                    break;
                case 3:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=393
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 393;
                    }
                    break;
                case 4:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=394
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 394;
                    }
                    break;
                case 5:
                    // Event: START (EVMaximumDischargePower, RationalNumberType (RationalNumberType)); next=395
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_isUsed = 1u;
                        grammar_id = 395;
                    }
                    break;
                case 6:
                    // Event: START (EVMaximumDischargePower_L2, RationalNumberType (RationalNumberType)); next=396
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2_isUsed = 1u;
                        grammar_id = 396;
                    }
                    break;
                case 7:
                    // Event: START (EVMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=397
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 397;
                    }
                    break;
                case 8:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=398
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_isUsed = 1u;
                        grammar_id = 398;
                    }
                    break;
                case 9:
                    // Event: START (EVMinimumDischargePower_L2, RationalNumberType (RationalNumberType)); next=399
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2_isUsed = 1u;
                        grammar_id = 399;
                    }
                    break;
                case 10:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 11:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 390:
            // Grammar: ID=390; read/write bits=4; START (EVPresentActivePower_L3), START (EVPresentReactivePower), START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), START (EVMaximumDischargePower), START (EVMaximumDischargePower_L2), START (EVMaximumDischargePower_L3), START (EVMinimumDischargePower), START (EVMinimumDischargePower_L2), START (EVMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=391
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 391;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=392
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_isUsed = 1u;
                        grammar_id = 392;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=393
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 393;
                    }
                    break;
                case 3:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=394
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 394;
                    }
                    break;
                case 4:
                    // Event: START (EVMaximumDischargePower, RationalNumberType (RationalNumberType)); next=395
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_isUsed = 1u;
                        grammar_id = 395;
                    }
                    break;
                case 5:
                    // Event: START (EVMaximumDischargePower_L2, RationalNumberType (RationalNumberType)); next=396
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2_isUsed = 1u;
                        grammar_id = 396;
                    }
                    break;
                case 6:
                    // Event: START (EVMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=397
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 397;
                    }
                    break;
                case 7:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=398
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_isUsed = 1u;
                        grammar_id = 398;
                    }
                    break;
                case 8:
                    // Event: START (EVMinimumDischargePower_L2, RationalNumberType (RationalNumberType)); next=399
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2_isUsed = 1u;
                        grammar_id = 399;
                    }
                    break;
                case 9:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 10:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 391:
            // Grammar: ID=391; read/write bits=4; START (EVPresentReactivePower), START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), START (EVMaximumDischargePower), START (EVMaximumDischargePower_L2), START (EVMaximumDischargePower_L3), START (EVMinimumDischargePower), START (EVMinimumDischargePower_L2), START (EVMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=392
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_isUsed = 1u;
                        grammar_id = 392;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=393
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 393;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=394
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 394;
                    }
                    break;
                case 3:
                    // Event: START (EVMaximumDischargePower, RationalNumberType (RationalNumberType)); next=395
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_isUsed = 1u;
                        grammar_id = 395;
                    }
                    break;
                case 4:
                    // Event: START (EVMaximumDischargePower_L2, RationalNumberType (RationalNumberType)); next=396
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2_isUsed = 1u;
                        grammar_id = 396;
                    }
                    break;
                case 5:
                    // Event: START (EVMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=397
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 397;
                    }
                    break;
                case 6:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=398
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_isUsed = 1u;
                        grammar_id = 398;
                    }
                    break;
                case 7:
                    // Event: START (EVMinimumDischargePower_L2, RationalNumberType (RationalNumberType)); next=399
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2_isUsed = 1u;
                        grammar_id = 399;
                    }
                    break;
                case 8:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 9:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 392:
            // Grammar: ID=392; read/write bits=4; START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), START (EVMaximumDischargePower), START (EVMaximumDischargePower_L2), START (EVMaximumDischargePower_L3), START (EVMinimumDischargePower), START (EVMinimumDischargePower_L2), START (EVMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=393
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 393;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=394
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 394;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumDischargePower, RationalNumberType (RationalNumberType)); next=395
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_isUsed = 1u;
                        grammar_id = 395;
                    }
                    break;
                case 3:
                    // Event: START (EVMaximumDischargePower_L2, RationalNumberType (RationalNumberType)); next=396
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2_isUsed = 1u;
                        grammar_id = 396;
                    }
                    break;
                case 4:
                    // Event: START (EVMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=397
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 397;
                    }
                    break;
                case 5:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=398
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_isUsed = 1u;
                        grammar_id = 398;
                    }
                    break;
                case 6:
                    // Event: START (EVMinimumDischargePower_L2, RationalNumberType (RationalNumberType)); next=399
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2_isUsed = 1u;
                        grammar_id = 399;
                    }
                    break;
                case 7:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 8:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 393:
            // Grammar: ID=393; read/write bits=4; START (EVPresentReactivePower_L3), START (EVMaximumDischargePower), START (EVMaximumDischargePower_L2), START (EVMaximumDischargePower_L3), START (EVMinimumDischargePower), START (EVMinimumDischargePower_L2), START (EVMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=394
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 394;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumDischargePower, RationalNumberType (RationalNumberType)); next=395
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_isUsed = 1u;
                        grammar_id = 395;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumDischargePower_L2, RationalNumberType (RationalNumberType)); next=396
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2_isUsed = 1u;
                        grammar_id = 396;
                    }
                    break;
                case 3:
                    // Event: START (EVMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=397
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 397;
                    }
                    break;
                case 4:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=398
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_isUsed = 1u;
                        grammar_id = 398;
                    }
                    break;
                case 5:
                    // Event: START (EVMinimumDischargePower_L2, RationalNumberType (RationalNumberType)); next=399
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2_isUsed = 1u;
                        grammar_id = 399;
                    }
                    break;
                case 6:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 394:
            // Grammar: ID=394; read/write bits=3; START (EVMaximumDischargePower), START (EVMaximumDischargePower_L2), START (EVMaximumDischargePower_L3), START (EVMinimumDischargePower), START (EVMinimumDischargePower_L2), START (EVMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargePower, RationalNumberType (RationalNumberType)); next=395
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_isUsed = 1u;
                        grammar_id = 395;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumDischargePower_L2, RationalNumberType (RationalNumberType)); next=396
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2_isUsed = 1u;
                        grammar_id = 396;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=397
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 397;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=398
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_isUsed = 1u;
                        grammar_id = 398;
                    }
                    break;
                case 4:
                    // Event: START (EVMinimumDischargePower_L2, RationalNumberType (RationalNumberType)); next=399
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2_isUsed = 1u;
                        grammar_id = 399;
                    }
                    break;
                case 5:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 395:
            // Grammar: ID=395; read/write bits=3; START (EVMaximumDischargePower_L2), START (EVMaximumDischargePower_L3), START (EVMinimumDischargePower), START (EVMinimumDischargePower_L2), START (EVMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargePower_L2, RationalNumberType (RationalNumberType)); next=396
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L2_isUsed = 1u;
                        grammar_id = 396;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=397
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 397;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=398
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_isUsed = 1u;
                        grammar_id = 398;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumDischargePower_L2, RationalNumberType (RationalNumberType)); next=399
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2_isUsed = 1u;
                        grammar_id = 399;
                    }
                    break;
                case 4:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 396:
            // Grammar: ID=396; read/write bits=3; START (EVMaximumDischargePower_L3), START (EVMinimumDischargePower), START (EVMinimumDischargePower_L2), START (EVMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=397
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 397;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=398
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_isUsed = 1u;
                        grammar_id = 398;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumDischargePower_L2, RationalNumberType (RationalNumberType)); next=399
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2_isUsed = 1u;
                        grammar_id = 399;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 397:
            // Grammar: ID=397; read/write bits=3; START (EVMinimumDischargePower), START (EVMinimumDischargePower_L2), START (EVMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=398
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_isUsed = 1u;
                        grammar_id = 398;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumDischargePower_L2, RationalNumberType (RationalNumberType)); next=399
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2_isUsed = 1u;
                        grammar_id = 399;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 398:
            // Grammar: ID=398; read/write bits=2; START (EVMinimumDischargePower_L2), START (EVMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargePower_L2, RationalNumberType (RationalNumberType)); next=399
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L2_isUsed = 1u;
                        grammar_id = 399;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 399:
            // Grammar: ID=399; read/write bits=2; START (EVMinimumDischargePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}BPT_Scheduled_AC_CLResControlMode; type={urn:iso:std:iso:15118:-20:AC}BPT_Scheduled_AC_CLResControlModeType; base type=Scheduled_AC_CLResControlModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: EVSETargetActivePower, RationalNumberType (0, 1); EVSETargetActivePower_L2, RationalNumberType (0, 1); EVSETargetActivePower_L3, RationalNumberType (0, 1); EVSETargetReactivePower, RationalNumberType (0, 1); EVSETargetReactivePower_L2, RationalNumberType (0, 1); EVSETargetReactivePower_L3, RationalNumberType (0, 1); EVSEPresentActivePower, RationalNumberType (0, 1); EVSEPresentActivePower_L2, RationalNumberType (0, 1); EVSEPresentActivePower_L3, RationalNumberType (0, 1);
static int decode_iso20_ac_der_BPT_Scheduled_AC_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_BPT_Scheduled_AC_CLResControlModeType* BPT_Scheduled_AC_CLResControlModeType) {
    int grammar_id = 400;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_BPT_Scheduled_AC_CLResControlModeType(BPT_Scheduled_AC_CLResControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 400:
            // Grammar: ID=400; read/write bits=4; START (EVSETargetActivePower), START (EVSETargetActivePower_L2), START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=401
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_isUsed = 1u;
                        grammar_id = 401;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetActivePower_L2, RationalNumberType (RationalNumberType)); next=402
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L2_isUsed = 1u;
                        grammar_id = 402;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=403
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 403;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=404
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 404;
                    }
                    break;
                case 4:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=405
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 405;
                    }
                    break;
                case 5:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=406
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 406;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=407
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 407;
                    }
                    break;
                case 7:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=408
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 408;
                    }
                    break;
                case 8:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 9:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 401:
            // Grammar: ID=401; read/write bits=4; START (EVSETargetActivePower_L2), START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower_L2, RationalNumberType (RationalNumberType)); next=402
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L2_isUsed = 1u;
                        grammar_id = 402;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=403
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 403;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=404
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 404;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=405
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 405;
                    }
                    break;
                case 4:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=406
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 406;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=407
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 407;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=408
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 408;
                    }
                    break;
                case 7:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 8:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 402:
            // Grammar: ID=402; read/write bits=4; START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=403
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 403;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=404
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 404;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=405
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 405;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=406
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 406;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=407
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 407;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=408
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 408;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 403:
            // Grammar: ID=403; read/write bits=3; START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=404
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 404;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=405
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 405;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=406
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 406;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=407
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 407;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=408
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 408;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 404:
            // Grammar: ID=404; read/write bits=3; START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=405
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 405;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=406
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 406;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=407
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 407;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=408
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 408;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 405:
            // Grammar: ID=405; read/write bits=3; START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=406
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 406;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=407
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 407;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=408
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 408;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 406:
            // Grammar: ID=406; read/write bits=3; START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=407
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 407;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=408
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 408;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 407:
            // Grammar: ID=407; read/write bits=2; START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=408
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 408;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 408:
            // Grammar: ID=408; read/write bits=2; START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}BPT_Dynamic_AC_CLReqControlMode; type={urn:iso:std:iso:15118:-20:AC}BPT_Dynamic_AC_CLReqControlModeType; base type=Dynamic_AC_CLReqControlModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DepartureTime, unsignedInt (0, 1); EVTargetEnergyRequest, RationalNumberType (1, 1); EVMaximumEnergyRequest, RationalNumberType (1, 1); EVMinimumEnergyRequest, RationalNumberType (1, 1); EVMaximumChargePower, RationalNumberType (1, 1); EVMaximumChargePower_L2, RationalNumberType (0, 1); EVMaximumChargePower_L3, RationalNumberType (0, 1); EVMinimumChargePower, RationalNumberType (1, 1); EVMinimumChargePower_L2, RationalNumberType (0, 1); EVMinimumChargePower_L3, RationalNumberType (0, 1); EVPresentActivePower, RationalNumberType (1, 1); EVPresentActivePower_L2, RationalNumberType (0, 1); EVPresentActivePower_L3, RationalNumberType (0, 1); EVPresentReactivePower, RationalNumberType (1, 1); EVPresentReactivePower_L2, RationalNumberType (0, 1); EVPresentReactivePower_L3, RationalNumberType (0, 1); EVMaximumDischargePower, RationalNumberType (1, 1); EVMaximumDischargePower_L2, RationalNumberType (0, 1); EVMaximumDischargePower_L3, RationalNumberType (0, 1); EVMinimumDischargePower, RationalNumberType (1, 1); EVMinimumDischargePower_L2, RationalNumberType (0, 1); EVMinimumDischargePower_L3, RationalNumberType (0, 1); EVMaximumV2XEnergyRequest, RationalNumberType (0, 1); EVMinimumV2XEnergyRequest, RationalNumberType (0, 1);
static int decode_iso20_ac_der_BPT_Dynamic_AC_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_BPT_Dynamic_AC_CLReqControlModeType* BPT_Dynamic_AC_CLReqControlModeType) {
    int grammar_id = 409;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_BPT_Dynamic_AC_CLReqControlModeType(BPT_Dynamic_AC_CLReqControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 409:
            // Grammar: ID=409; read/write bits=2; START (DepartureTime), START (EVTargetEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DepartureTime, unsignedInt (unsignedLong)); next=410
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &BPT_Dynamic_AC_CLReqControlModeType->DepartureTime);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->DepartureTime_isUsed = 1u;
                        grammar_id = 410;
                    }
                    break;
                case 1:
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=411
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVTargetEnergyRequest);
                    if (error == 0)
                    {
                        grammar_id = 411;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 410:
            // Grammar: ID=410; read/write bits=1; START (EVTargetEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=411
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVTargetEnergyRequest);
                    if (error == 0)
                    {
                        grammar_id = 411;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 411:
            // Grammar: ID=411; read/write bits=1; START (EVMaximumEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumEnergyRequest, RationalNumberType (RationalNumberType)); next=412
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumEnergyRequest);
                    if (error == 0)
                    {
                        grammar_id = 412;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 412:
            // Grammar: ID=412; read/write bits=1; START (EVMinimumEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=413
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumEnergyRequest);
                    if (error == 0)
                    {
                        grammar_id = 413;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 413:
            // Grammar: ID=413; read/write bits=1; START (EVMaximumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=414
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 414;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 414:
            // Grammar: ID=414; read/write bits=2; START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=415
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 415;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=416
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 416;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=417
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 417;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 415:
            // Grammar: ID=415; read/write bits=2; START (EVMaximumChargePower_L3), START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=416
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 416;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=417
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 417;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 416:
            // Grammar: ID=416; read/write bits=1; START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=417
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 417;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 417:
            // Grammar: ID=417; read/write bits=2; START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=418
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 418;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=419
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 419;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=420
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 420;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 418:
            // Grammar: ID=418; read/write bits=2; START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=419
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 419;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=420
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 420;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 419:
            // Grammar: ID=419; read/write bits=1; START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=420
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 420;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 420:
            // Grammar: ID=420; read/write bits=2; START (EVPresentActivePower_L2), START (EVPresentActivePower_L3), START (EVPresentReactivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=421
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 421;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=422
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 422;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=423
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        grammar_id = 423;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 421:
            // Grammar: ID=421; read/write bits=2; START (EVPresentActivePower_L3), START (EVPresentReactivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=422
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 422;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=423
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        grammar_id = 423;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 422:
            // Grammar: ID=422; read/write bits=1; START (EVPresentReactivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=423
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        grammar_id = 423;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 423:
            // Grammar: ID=423; read/write bits=2; START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=424
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 424;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=425
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 425;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumDischargePower, RationalNumberType (RationalNumberType)); next=426
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 426;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 424:
            // Grammar: ID=424; read/write bits=2; START (EVPresentReactivePower_L3), START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=425
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 425;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumDischargePower, RationalNumberType (RationalNumberType)); next=426
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 426;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 425:
            // Grammar: ID=425; read/write bits=1; START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargePower, RationalNumberType (RationalNumberType)); next=426
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 426;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 426:
            // Grammar: ID=426; read/write bits=2; START (EVMaximumDischargePower_L2), START (EVMaximumDischargePower_L3), START (EVMinimumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargePower_L2, RationalNumberType (RationalNumberType)); next=427
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMaximumDischargePower_L2_isUsed = 1u;
                        grammar_id = 427;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=428
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 428;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=429
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 429;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 427:
            // Grammar: ID=427; read/write bits=2; START (EVMaximumDischargePower_L3), START (EVMinimumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargePower_L3, RationalNumberType (RationalNumberType)); next=428
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMaximumDischargePower_L3_isUsed = 1u;
                        grammar_id = 428;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=429
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 429;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 428:
            // Grammar: ID=428; read/write bits=1; START (EVMinimumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargePower, RationalNumberType (RationalNumberType)); next=429
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 429;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 429:
            // Grammar: ID=429; read/write bits=3; START (EVMinimumDischargePower_L2), START (EVMinimumDischargePower_L3), START (EVMaximumV2XEnergyRequest), START (EVMinimumV2XEnergyRequest), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargePower_L2, RationalNumberType (RationalNumberType)); next=430
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumDischargePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMinimumDischargePower_L2_isUsed = 1u;
                        grammar_id = 430;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=431
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 431;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumV2XEnergyRequest, RationalNumberType (RationalNumberType)); next=432
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumV2XEnergyRequest);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMaximumV2XEnergyRequest_isUsed = 1u;
                        grammar_id = 432;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumV2XEnergyRequest, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumV2XEnergyRequest);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMinimumV2XEnergyRequest_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 430:
            // Grammar: ID=430; read/write bits=3; START (EVMinimumDischargePower_L3), START (EVMaximumV2XEnergyRequest), START (EVMinimumV2XEnergyRequest), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargePower_L3, RationalNumberType (RationalNumberType)); next=431
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumDischargePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMinimumDischargePower_L3_isUsed = 1u;
                        grammar_id = 431;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumV2XEnergyRequest, RationalNumberType (RationalNumberType)); next=432
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumV2XEnergyRequest);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMaximumV2XEnergyRequest_isUsed = 1u;
                        grammar_id = 432;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumV2XEnergyRequest, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumV2XEnergyRequest);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMinimumV2XEnergyRequest_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 431:
            // Grammar: ID=431; read/write bits=2; START (EVMaximumV2XEnergyRequest), START (EVMinimumV2XEnergyRequest), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumV2XEnergyRequest, RationalNumberType (RationalNumberType)); next=432
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMaximumV2XEnergyRequest);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMaximumV2XEnergyRequest_isUsed = 1u;
                        grammar_id = 432;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumV2XEnergyRequest, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumV2XEnergyRequest);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMinimumV2XEnergyRequest_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 432:
            // Grammar: ID=432; read/write bits=2; START (EVMinimumV2XEnergyRequest), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumV2XEnergyRequest, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLReqControlModeType->EVMinimumV2XEnergyRequest);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLReqControlModeType->EVMinimumV2XEnergyRequest_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}BPT_Dynamic_AC_CLResControlMode; type={urn:iso:std:iso:15118:-20:AC}BPT_Dynamic_AC_CLResControlModeType; base type=Dynamic_AC_CLResControlModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DepartureTime, unsignedInt (0, 1); MinimumSOC, percentValueType (0, 1); TargetSOC, percentValueType (0, 1); AckMaxDelay, unsignedShort (0, 1); EVSETargetActivePower, RationalNumberType (1, 1); EVSETargetActivePower_L2, RationalNumberType (0, 1); EVSETargetActivePower_L3, RationalNumberType (0, 1); EVSETargetReactivePower, RationalNumberType (0, 1); EVSETargetReactivePower_L2, RationalNumberType (0, 1); EVSETargetReactivePower_L3, RationalNumberType (0, 1); EVSEPresentActivePower, RationalNumberType (0, 1); EVSEPresentActivePower_L2, RationalNumberType (0, 1); EVSEPresentActivePower_L3, RationalNumberType (0, 1);
static int decode_iso20_ac_der_BPT_Dynamic_AC_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_BPT_Dynamic_AC_CLResControlModeType* BPT_Dynamic_AC_CLResControlModeType) {
    int grammar_id = 433;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_BPT_Dynamic_AC_CLResControlModeType(BPT_Dynamic_AC_CLResControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 433:
            // Grammar: ID=433; read/write bits=3; START (DepartureTime), START (MinimumSOC), START (TargetSOC), START (AckMaxDelay), START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DepartureTime, unsignedInt (unsignedLong)); next=434
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &BPT_Dynamic_AC_CLResControlModeType->DepartureTime);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->DepartureTime_isUsed = 1u;
                        grammar_id = 434;
                    }
                    break;
                case 1:
                    // Event: START (MinimumSOC, percentValueType (byte)); next=435
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                BPT_Dynamic_AC_CLResControlModeType->MinimumSOC = (int8_t)value;
                                BPT_Dynamic_AC_CLResControlModeType->MinimumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 435;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (TargetSOC, percentValueType (byte)); next=436
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                BPT_Dynamic_AC_CLResControlModeType->TargetSOC = (int8_t)value;
                                BPT_Dynamic_AC_CLResControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 436;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 3:
                    // Event: START (AckMaxDelay, unsignedShort (unsignedInt)); next=437
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &BPT_Dynamic_AC_CLResControlModeType->AckMaxDelay);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->AckMaxDelay_isUsed = 1u;
                        grammar_id = 437;
                    }
                    break;
                case 4:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=438
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 438;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 434:
            // Grammar: ID=434; read/write bits=3; START (MinimumSOC), START (TargetSOC), START (AckMaxDelay), START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MinimumSOC, percentValueType (byte)); next=435
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                BPT_Dynamic_AC_CLResControlModeType->MinimumSOC = (int8_t)value;
                                BPT_Dynamic_AC_CLResControlModeType->MinimumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 435;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (TargetSOC, percentValueType (byte)); next=436
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                BPT_Dynamic_AC_CLResControlModeType->TargetSOC = (int8_t)value;
                                BPT_Dynamic_AC_CLResControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 436;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (AckMaxDelay, unsignedShort (unsignedInt)); next=437
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &BPT_Dynamic_AC_CLResControlModeType->AckMaxDelay);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->AckMaxDelay_isUsed = 1u;
                        grammar_id = 437;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=438
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 438;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 435:
            // Grammar: ID=435; read/write bits=2; START (TargetSOC), START (AckMaxDelay), START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (TargetSOC, percentValueType (byte)); next=436
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                BPT_Dynamic_AC_CLResControlModeType->TargetSOC = (int8_t)value;
                                BPT_Dynamic_AC_CLResControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 436;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (AckMaxDelay, unsignedShort (unsignedInt)); next=437
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &BPT_Dynamic_AC_CLResControlModeType->AckMaxDelay);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->AckMaxDelay_isUsed = 1u;
                        grammar_id = 437;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=438
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 438;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 436:
            // Grammar: ID=436; read/write bits=2; START (AckMaxDelay), START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (AckMaxDelay, unsignedShort (unsignedInt)); next=437
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &BPT_Dynamic_AC_CLResControlModeType->AckMaxDelay);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->AckMaxDelay_isUsed = 1u;
                        grammar_id = 437;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=438
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 438;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 437:
            // Grammar: ID=437; read/write bits=1; START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=438
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 438;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 438:
            // Grammar: ID=438; read/write bits=4; START (EVSETargetActivePower_L2), START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower_L2, RationalNumberType (RationalNumberType)); next=439
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L2_isUsed = 1u;
                        grammar_id = 439;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=440
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 440;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=441
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 441;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=442
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 442;
                    }
                    break;
                case 4:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=443
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 443;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=444
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 444;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=445
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 445;
                    }
                    break;
                case 7:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 8:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 439:
            // Grammar: ID=439; read/write bits=4; START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=440
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 440;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=441
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 441;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=442
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 442;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=443
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 443;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=444
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 444;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=445
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 445;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 440:
            // Grammar: ID=440; read/write bits=3; START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=441
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 441;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=442
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 442;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=443
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 443;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=444
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 444;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=445
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 445;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 441:
            // Grammar: ID=441; read/write bits=3; START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=442
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 442;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=443
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 443;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=444
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 444;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=445
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 445;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 442:
            // Grammar: ID=442; read/write bits=3; START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=443
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 443;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=444
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 444;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=445
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 445;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 443:
            // Grammar: ID=443; read/write bits=3; START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=444
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 444;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=445
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 445;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 444:
            // Grammar: ID=444; read/write bits=2; START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=445
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 445;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 445:
            // Grammar: ID=445; read/write bits=2; START (EVSEPresentActivePower_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        BPT_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}DER_AC_CPDResEnergyTransferMode; type={urn:iso:std:iso:15118:-20:AC}DER_AC_CPDResEnergyTransferModeType; base type=AC_CPDResEnergyTransferModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: EVSEMaximumChargePower, RationalNumberType (1, 1); EVSEMaximumChargePower_L2, RationalNumberType (0, 1); EVSEMaximumChargePower_L3, RationalNumberType (0, 1); EVSEMinimumChargePower, RationalNumberType (1, 1); EVSEMinimumChargePower_L2, RationalNumberType (0, 1); EVSEMinimumChargePower_L3, RationalNumberType (0, 1); EVSENominalFrequency, RationalNumberType (1, 1); MaximumPowerAsymmetry, RationalNumberType (0, 1); EVSEPowerRampLimitation, RationalNumberType (0, 1); EVSEPresentActivePower, RationalNumberType (0, 1); EVSEPresentActivePower_L2, RationalNumberType (0, 1); EVSEPresentActivePower_L3, RationalNumberType (0, 1); EVSEStatus, EVSEStatusType (0, 1); DERControl, DERControlType (1, 1); EVSENominalPower, RationalNumberType (1, 1); EVSEMaximumDischargePower, PhaseType (0, 1); EVSEMaximumChargeReactivePower, PhaseType (0, 1); EVSEMaximumDischargeReactivePower, PhaseType (0, 1); GridLimits, GridLimitsType (1, 1);
static int decode_iso20_ac_der_DER_AC_CPDResEnergyTransferModeType(exi_bitstream_t* stream, struct iso20_ac_der_DER_AC_CPDResEnergyTransferModeType* DER_AC_CPDResEnergyTransferModeType) {
    int grammar_id = 446;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DER_AC_CPDResEnergyTransferModeType(DER_AC_CPDResEnergyTransferModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 446:
            // Grammar: ID=446; read/write bits=1; START (EVSEMaximumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumChargePower, RationalNumberType (RationalNumberType)); next=447
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 447;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 447:
            // Grammar: ID=447; read/write bits=2; START (EVSEMaximumChargePower_L2), START (EVSEMaximumChargePower_L3), START (EVSEMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=448
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L2);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 448;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=449
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L3);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 449;
                    }
                    break;
                case 2:
                    // Event: START (EVSEMinimumChargePower, RationalNumberType (RationalNumberType)); next=450
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 450;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 448:
            // Grammar: ID=448; read/write bits=2; START (EVSEMaximumChargePower_L3), START (EVSEMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=449
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L3);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 449;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMinimumChargePower, RationalNumberType (RationalNumberType)); next=450
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 450;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 449:
            // Grammar: ID=449; read/write bits=1; START (EVSEMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMinimumChargePower, RationalNumberType (RationalNumberType)); next=450
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 450;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 450:
            // Grammar: ID=450; read/write bits=2; START (EVSEMinimumChargePower_L2), START (EVSEMinimumChargePower_L3), START (EVSENominalFrequency)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=451
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L2);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 451;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=452
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 452;
                    }
                    break;
                case 2:
                    // Event: START (EVSENominalFrequency, RationalNumberType (RationalNumberType)); next=453
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSENominalFrequency);
                    if (error == 0)
                    {
                        grammar_id = 453;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 451:
            // Grammar: ID=451; read/write bits=2; START (EVSEMinimumChargePower_L3), START (EVSENominalFrequency)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=452
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 452;
                    }
                    break;
                case 1:
                    // Event: START (EVSENominalFrequency, RationalNumberType (RationalNumberType)); next=453
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSENominalFrequency);
                    if (error == 0)
                    {
                        grammar_id = 453;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 452:
            // Grammar: ID=452; read/write bits=1; START (EVSENominalFrequency)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSENominalFrequency, RationalNumberType (RationalNumberType)); next=453
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSENominalFrequency);
                    if (error == 0)
                    {
                        grammar_id = 453;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 453:
            // Grammar: ID=453; read/write bits=3; START (MaximumPowerAsymmetry), START (EVSEPowerRampLimitation), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (EVSEStatus), START (DERControl)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MaximumPowerAsymmetry, RationalNumberType (RationalNumberType)); next=454
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->MaximumPowerAsymmetry);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->MaximumPowerAsymmetry_isUsed = 1u;
                        grammar_id = 454;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPowerRampLimitation, RationalNumberType (RationalNumberType)); next=455
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPowerRampLimitation);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPowerRampLimitation_isUsed = 1u;
                        grammar_id = 455;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=456
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 456;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=457
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 457;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=458
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 458;
                    }
                    break;
                case 5:
                    // Event: START (EVSEStatus, EVSEStatusType (EVSEStatusType)); next=459
                    // decode: element
                    error = decode_iso20_ac_der_EVSEStatusType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEStatus);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEStatus_isUsed = 1u;
                        grammar_id = 459;
                    }
                    break;
                case 6:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=460
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_AC_CPDResEnergyTransferModeType->DERControl);
                    if (error == 0)
                    {
                        grammar_id = 460;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 454:
            // Grammar: ID=454; read/write bits=3; START (EVSEPowerRampLimitation), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (EVSEStatus), START (DERControl)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPowerRampLimitation, RationalNumberType (RationalNumberType)); next=455
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPowerRampLimitation);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPowerRampLimitation_isUsed = 1u;
                        grammar_id = 455;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=456
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 456;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=457
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 457;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=458
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 458;
                    }
                    break;
                case 4:
                    // Event: START (EVSEStatus, EVSEStatusType (EVSEStatusType)); next=459
                    // decode: element
                    error = decode_iso20_ac_der_EVSEStatusType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEStatus);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEStatus_isUsed = 1u;
                        grammar_id = 459;
                    }
                    break;
                case 5:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=460
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_AC_CPDResEnergyTransferModeType->DERControl);
                    if (error == 0)
                    {
                        grammar_id = 460;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 455:
            // Grammar: ID=455; read/write bits=3; START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (EVSEStatus), START (DERControl)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=456
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 456;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=457
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 457;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=458
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 458;
                    }
                    break;
                case 3:
                    // Event: START (EVSEStatus, EVSEStatusType (EVSEStatusType)); next=459
                    // decode: element
                    error = decode_iso20_ac_der_EVSEStatusType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEStatus);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEStatus_isUsed = 1u;
                        grammar_id = 459;
                    }
                    break;
                case 4:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=460
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_AC_CPDResEnergyTransferModeType->DERControl);
                    if (error == 0)
                    {
                        grammar_id = 460;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 456:
            // Grammar: ID=456; read/write bits=3; START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (EVSEStatus), START (DERControl)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=457
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 457;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=458
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 458;
                    }
                    break;
                case 2:
                    // Event: START (EVSEStatus, EVSEStatusType (EVSEStatusType)); next=459
                    // decode: element
                    error = decode_iso20_ac_der_EVSEStatusType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEStatus);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEStatus_isUsed = 1u;
                        grammar_id = 459;
                    }
                    break;
                case 3:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=460
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_AC_CPDResEnergyTransferModeType->DERControl);
                    if (error == 0)
                    {
                        grammar_id = 460;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 457:
            // Grammar: ID=457; read/write bits=2; START (EVSEPresentActivePower_L3), START (EVSEStatus), START (DERControl)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=458
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 458;
                    }
                    break;
                case 1:
                    // Event: START (EVSEStatus, EVSEStatusType (EVSEStatusType)); next=459
                    // decode: element
                    error = decode_iso20_ac_der_EVSEStatusType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEStatus);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEStatus_isUsed = 1u;
                        grammar_id = 459;
                    }
                    break;
                case 2:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=460
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_AC_CPDResEnergyTransferModeType->DERControl);
                    if (error == 0)
                    {
                        grammar_id = 460;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 458:
            // Grammar: ID=458; read/write bits=2; START (EVSEStatus), START (DERControl)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEStatus, EVSEStatusType (EVSEStatusType)); next=459
                    // decode: element
                    error = decode_iso20_ac_der_EVSEStatusType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEStatus);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEStatus_isUsed = 1u;
                        grammar_id = 459;
                    }
                    break;
                case 1:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=460
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_AC_CPDResEnergyTransferModeType->DERControl);
                    if (error == 0)
                    {
                        grammar_id = 460;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 459:
            // Grammar: ID=459; read/write bits=1; START (DERControl)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=460
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_AC_CPDResEnergyTransferModeType->DERControl);
                    if (error == 0)
                    {
                        grammar_id = 460;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 460:
            // Grammar: ID=460; read/write bits=1; START (EVSENominalPower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSENominalPower, RationalNumberType (RationalNumberType)); next=461
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSENominalPower);
                    if (error == 0)
                    {
                        grammar_id = 461;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 461:
            // Grammar: ID=461; read/write bits=3; START (EVSEMaximumDischargePower), START (EVSEMaximumChargeReactivePower), START (EVSEMaximumDischargeReactivePower), START (GridLimits)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumDischargePower, PhaseType (PhaseType)); next=462
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargePower_isUsed = 1u;
                        grammar_id = 462;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMaximumChargeReactivePower, PhaseType (PhaseType)); next=463
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMaximumChargeReactivePower);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEMaximumChargeReactivePower_isUsed = 1u;
                        grammar_id = 463;
                    }
                    break;
                case 2:
                    // Event: START (EVSEMaximumDischargeReactivePower, PhaseType (PhaseType)); next=464
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargeReactivePower);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 464;
                    }
                    break;
                case 3:
                    // Event: START (GridLimits, GridLimitsType (GridLimitsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_GridLimitsType(stream, &DER_AC_CPDResEnergyTransferModeType->GridLimits);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 462:
            // Grammar: ID=462; read/write bits=2; START (EVSEMaximumChargeReactivePower), START (EVSEMaximumDischargeReactivePower), START (GridLimits)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumChargeReactivePower, PhaseType (PhaseType)); next=463
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMaximumChargeReactivePower);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEMaximumChargeReactivePower_isUsed = 1u;
                        grammar_id = 463;
                    }
                    break;
                case 1:
                    // Event: START (EVSEMaximumDischargeReactivePower, PhaseType (PhaseType)); next=464
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargeReactivePower);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 464;
                    }
                    break;
                case 2:
                    // Event: START (GridLimits, GridLimitsType (GridLimitsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_GridLimitsType(stream, &DER_AC_CPDResEnergyTransferModeType->GridLimits);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 463:
            // Grammar: ID=463; read/write bits=2; START (EVSEMaximumDischargeReactivePower), START (GridLimits)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEMaximumDischargeReactivePower, PhaseType (PhaseType)); next=464
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargeReactivePower);
                    if (error == 0)
                    {
                        DER_AC_CPDResEnergyTransferModeType->EVSEMaximumDischargeReactivePower_isUsed = 1u;
                        grammar_id = 464;
                    }
                    break;
                case 1:
                    // Event: START (GridLimits, GridLimitsType (GridLimitsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_GridLimitsType(stream, &DER_AC_CPDResEnergyTransferModeType->GridLimits);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 464:
            // Grammar: ID=464; read/write bits=1; START (GridLimits)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (GridLimits, GridLimitsType (GridLimitsType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_GridLimitsType(stream, &DER_AC_CPDResEnergyTransferModeType->GridLimits);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}AC_ChargeParameterDiscoveryRes; type={urn:iso:std:iso:15118:-20:AC}AC_ChargeParameterDiscoveryResType; base type=ChargeParameterDiscoveryResType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); AC_CPDResEnergyTransferMode, AC_CPDResEnergyTransferModeType (0, 1); BPT_AC_CPDResEnergyTransferMode, BPT_AC_CPDResEnergyTransferModeType (0, 1); DER_AC_CPDResEnergyTransferMode, DER_AC_CPDResEnergyTransferModeType (0, 1);
static int decode_iso20_ac_der_AC_ChargeParameterDiscoveryResType(exi_bitstream_t* stream, struct iso20_ac_der_AC_ChargeParameterDiscoveryResType* AC_ChargeParameterDiscoveryResType) {
    int grammar_id = 465;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_AC_ChargeParameterDiscoveryResType(AC_ChargeParameterDiscoveryResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 465:
            // Grammar: ID=465; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=466
                    // decode: element
                    error = decode_iso20_ac_der_MessageHeaderType(stream, &AC_ChargeParameterDiscoveryResType->Header);
                    if (error == 0)
                    {
                        grammar_id = 466;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 466:
            // Grammar: ID=466; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ResponseCode, responseCodeType (string)); next=467
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                AC_ChargeParameterDiscoveryResType->ResponseCode = (iso20_ac_der_responseCodeType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 467;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 467:
            // Grammar: ID=467; read/write bits=2; START (AC_CPDResEnergyTransferMode), START (BPT_AC_CPDResEnergyTransferMode), START (DER_AC_CPDResEnergyTransferMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (AC_CPDResEnergyTransferMode, AC_CPDResEnergyTransferModeType (AC_CPDResEnergyTransferModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_AC_CPDResEnergyTransferModeType(stream, &AC_ChargeParameterDiscoveryResType->AC_CPDResEnergyTransferMode);
                    if (error == 0)
                    {
                        AC_ChargeParameterDiscoveryResType->AC_CPDResEnergyTransferMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: START (BPT_AC_CPDResEnergyTransferMode, BPT_AC_CPDResEnergyTransferModeType (AC_CPDResEnergyTransferModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_AC_CPDResEnergyTransferModeType(stream, &AC_ChargeParameterDiscoveryResType->BPT_AC_CPDResEnergyTransferMode);
                    if (error == 0)
                    {
                        AC_ChargeParameterDiscoveryResType->BPT_AC_CPDResEnergyTransferMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: START (DER_AC_CPDResEnergyTransferMode, DER_AC_CPDResEnergyTransferModeType (AC_CPDResEnergyTransferModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_AC_CPDResEnergyTransferModeType(stream, &AC_ChargeParameterDiscoveryResType->DER_AC_CPDResEnergyTransferMode);
                    if (error == 0)
                    {
                        AC_ChargeParameterDiscoveryResType->DER_AC_CPDResEnergyTransferMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}DER_Scheduled_AC_CLReqControlMode; type={urn:iso:std:iso:15118:-20:AC}DER_Scheduled_AC_CLReqControlModeType; base type=Scheduled_AC_CLReqControlModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: EVTargetEnergyRequest, RationalNumberType (0, 1); EVMaximumEnergyRequest, RationalNumberType (0, 1); EVMinimumEnergyRequest, RationalNumberType (0, 1); EVMaximumChargePower, RationalNumberType (0, 1); EVMaximumChargePower_L2, RationalNumberType (0, 1); EVMaximumChargePower_L3, RationalNumberType (0, 1); EVMinimumChargePower, RationalNumberType (0, 1); EVMinimumChargePower_L2, RationalNumberType (0, 1); EVMinimumChargePower_L3, RationalNumberType (0, 1); EVPresentActivePower, RationalNumberType (1, 1); EVPresentActivePower_L2, RationalNumberType (0, 1); EVPresentActivePower_L3, RationalNumberType (0, 1); EVPresentReactivePower, RationalNumberType (0, 1); EVPresentReactivePower_L2, RationalNumberType (0, 1); EVPresentReactivePower_L3, RationalNumberType (0, 1); EVMaximumDischargePower, PhaseType (1, 1); EVMinimumDischargePower, PhaseType (1, 1); EVSessionTotalDischargeEnergyAvailable, RationalNumberType (0, 1); EVApparentPower, EVApparentPowerType (0, 1); EVReactivePower, EVReactivePowerType (0, 1); EVExcitation, EVExcitationType (0, 1); EVSetPoints, EVSetPointsType (0, 1); EVPresentVoltage, PhaseType (0, 1); EVPresentFrequency, PhaseType (0, 1); DERGridSupportActiveInfo, DERGridSupportActiveInfoType (0, 1);
static int decode_iso20_ac_der_DER_Scheduled_AC_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_DER_Scheduled_AC_CLReqControlModeType* DER_Scheduled_AC_CLReqControlModeType) {
    int grammar_id = 468;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DER_Scheduled_AC_CLReqControlModeType(DER_Scheduled_AC_CLReqControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 468:
            // Grammar: ID=468; read/write bits=4; START (EVTargetEnergyRequest), START (EVMaximumEnergyRequest), START (EVMinimumEnergyRequest), START (EVMaximumChargePower), START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=469
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVTargetEnergyRequest);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVTargetEnergyRequest_isUsed = 1u;
                        grammar_id = 469;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumEnergyRequest, RationalNumberType (RationalNumberType)); next=470
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumEnergyRequest);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumEnergyRequest_isUsed = 1u;
                        grammar_id = 470;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=471
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest_isUsed = 1u;
                        grammar_id = 471;
                    }
                    break;
                case 3:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=472
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_isUsed = 1u;
                        grammar_id = 472;
                    }
                    break;
                case 4:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=473
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 473;
                    }
                    break;
                case 5:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=474
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 474;
                    }
                    break;
                case 6:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=475
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 475;
                    }
                    break;
                case 7:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=476
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 476;
                    }
                    break;
                case 8:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=477
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 477;
                    }
                    break;
                case 9:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=478
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 478;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 469:
            // Grammar: ID=469; read/write bits=4; START (EVMaximumEnergyRequest), START (EVMinimumEnergyRequest), START (EVMaximumChargePower), START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumEnergyRequest, RationalNumberType (RationalNumberType)); next=470
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumEnergyRequest);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumEnergyRequest_isUsed = 1u;
                        grammar_id = 470;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=471
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest_isUsed = 1u;
                        grammar_id = 471;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=472
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_isUsed = 1u;
                        grammar_id = 472;
                    }
                    break;
                case 3:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=473
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 473;
                    }
                    break;
                case 4:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=474
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 474;
                    }
                    break;
                case 5:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=475
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 475;
                    }
                    break;
                case 6:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=476
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 476;
                    }
                    break;
                case 7:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=477
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 477;
                    }
                    break;
                case 8:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=478
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 478;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 470:
            // Grammar: ID=470; read/write bits=4; START (EVMinimumEnergyRequest), START (EVMaximumChargePower), START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=471
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumEnergyRequest_isUsed = 1u;
                        grammar_id = 471;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=472
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_isUsed = 1u;
                        grammar_id = 472;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=473
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 473;
                    }
                    break;
                case 3:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=474
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 474;
                    }
                    break;
                case 4:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=475
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 475;
                    }
                    break;
                case 5:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=476
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 476;
                    }
                    break;
                case 6:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=477
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 477;
                    }
                    break;
                case 7:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=478
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 478;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 471:
            // Grammar: ID=471; read/write bits=3; START (EVMaximumChargePower), START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=472
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_isUsed = 1u;
                        grammar_id = 472;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=473
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 473;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=474
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 474;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=475
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 475;
                    }
                    break;
                case 4:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=476
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 476;
                    }
                    break;
                case 5:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=477
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 477;
                    }
                    break;
                case 6:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=478
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 478;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 472:
            // Grammar: ID=472; read/write bits=3; START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=473
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 473;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=474
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 474;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=475
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 475;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=476
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 476;
                    }
                    break;
                case 4:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=477
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 477;
                    }
                    break;
                case 5:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=478
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 478;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 473:
            // Grammar: ID=473; read/write bits=3; START (EVMaximumChargePower_L3), START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=474
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 474;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=475
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 475;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=476
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 476;
                    }
                    break;
                case 3:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=477
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 477;
                    }
                    break;
                case 4:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=478
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 478;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 474:
            // Grammar: ID=474; read/write bits=3; START (EVMinimumChargePower), START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=475
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_isUsed = 1u;
                        grammar_id = 475;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=476
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 476;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=477
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 477;
                    }
                    break;
                case 3:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=478
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 478;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 475:
            // Grammar: ID=475; read/write bits=2; START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=476
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 476;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=477
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 477;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=478
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 478;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 476:
            // Grammar: ID=476; read/write bits=2; START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=477
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 477;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=478
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 478;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 477:
            // Grammar: ID=477; read/write bits=1; START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=478
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 478;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 478:
            // Grammar: ID=478; read/write bits=3; START (EVPresentActivePower_L2), START (EVPresentActivePower_L3), START (EVPresentReactivePower), START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=479
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 479;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=480
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 480;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=481
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_isUsed = 1u;
                        grammar_id = 481;
                    }
                    break;
                case 3:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=482
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 482;
                    }
                    break;
                case 4:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=483
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 483;
                    }
                    break;
                case 5:
                    // Event: START (EVMaximumDischargePower, PhaseType (PhaseType)); next=484
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 484;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 479:
            // Grammar: ID=479; read/write bits=3; START (EVPresentActivePower_L3), START (EVPresentReactivePower), START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=480
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 480;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=481
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_isUsed = 1u;
                        grammar_id = 481;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=482
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 482;
                    }
                    break;
                case 3:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=483
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 483;
                    }
                    break;
                case 4:
                    // Event: START (EVMaximumDischargePower, PhaseType (PhaseType)); next=484
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 484;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 480:
            // Grammar: ID=480; read/write bits=3; START (EVPresentReactivePower), START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=481
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_isUsed = 1u;
                        grammar_id = 481;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=482
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 482;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=483
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 483;
                    }
                    break;
                case 3:
                    // Event: START (EVMaximumDischargePower, PhaseType (PhaseType)); next=484
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 484;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 481:
            // Grammar: ID=481; read/write bits=2; START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=482
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 482;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=483
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 483;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumDischargePower, PhaseType (PhaseType)); next=484
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 484;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 482:
            // Grammar: ID=482; read/write bits=2; START (EVPresentReactivePower_L3), START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=483
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 483;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumDischargePower, PhaseType (PhaseType)); next=484
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 484;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 483:
            // Grammar: ID=483; read/write bits=1; START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargePower, PhaseType (PhaseType)); next=484
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 484;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 484:
            // Grammar: ID=484; read/write bits=1; START (EVMinimumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargePower, PhaseType (PhaseType)); next=485
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 485;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 485:
            // Grammar: ID=485; read/write bits=4; START (EVSessionTotalDischargeEnergyAvailable), START (EVApparentPower), START (EVReactivePower), START (EVExcitation), START (EVSetPoints), START (EVPresentVoltage), START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSessionTotalDischargeEnergyAvailable, RationalNumberType (RationalNumberType)); next=486
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVSessionTotalDischargeEnergyAvailable);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVSessionTotalDischargeEnergyAvailable_isUsed = 1u;
                        grammar_id = 486;
                    }
                    break;
                case 1:
                    // Event: START (EVApparentPower, EVApparentPowerType (EVApparentPowerType)); next=487
                    // decode: element
                    error = decode_iso20_ac_der_EVApparentPowerType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVApparentPower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVApparentPower_isUsed = 1u;
                        grammar_id = 487;
                    }
                    break;
                case 2:
                    // Event: START (EVReactivePower, EVReactivePowerType (EVReactivePowerType)); next=488
                    // decode: element
                    error = decode_iso20_ac_der_EVReactivePowerType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVReactivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVReactivePower_isUsed = 1u;
                        grammar_id = 488;
                    }
                    break;
                case 3:
                    // Event: START (EVExcitation, EVExcitationType (EVExcitationType)); next=489
                    // decode: element
                    error = decode_iso20_ac_der_EVExcitationType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVExcitation);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVExcitation_isUsed = 1u;
                        grammar_id = 489;
                    }
                    break;
                case 4:
                    // Event: START (EVSetPoints, EVSetPointsType (EVSetPointsType)); next=490
                    // decode: element
                    error = decode_iso20_ac_der_EVSetPointsType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVSetPoints);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVSetPoints_isUsed = 1u;
                        grammar_id = 490;
                    }
                    break;
                case 5:
                    // Event: START (EVPresentVoltage, PhaseType (PhaseType)); next=491
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentVoltage);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentVoltage_isUsed = 1u;
                        grammar_id = 491;
                    }
                    break;
                case 6:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=492
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 492;
                    }
                    break;
                case 7:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 8:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 486:
            // Grammar: ID=486; read/write bits=4; START (EVApparentPower), START (EVReactivePower), START (EVExcitation), START (EVSetPoints), START (EVPresentVoltage), START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVApparentPower, EVApparentPowerType (EVApparentPowerType)); next=487
                    // decode: element
                    error = decode_iso20_ac_der_EVApparentPowerType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVApparentPower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVApparentPower_isUsed = 1u;
                        grammar_id = 487;
                    }
                    break;
                case 1:
                    // Event: START (EVReactivePower, EVReactivePowerType (EVReactivePowerType)); next=488
                    // decode: element
                    error = decode_iso20_ac_der_EVReactivePowerType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVReactivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVReactivePower_isUsed = 1u;
                        grammar_id = 488;
                    }
                    break;
                case 2:
                    // Event: START (EVExcitation, EVExcitationType (EVExcitationType)); next=489
                    // decode: element
                    error = decode_iso20_ac_der_EVExcitationType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVExcitation);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVExcitation_isUsed = 1u;
                        grammar_id = 489;
                    }
                    break;
                case 3:
                    // Event: START (EVSetPoints, EVSetPointsType (EVSetPointsType)); next=490
                    // decode: element
                    error = decode_iso20_ac_der_EVSetPointsType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVSetPoints);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVSetPoints_isUsed = 1u;
                        grammar_id = 490;
                    }
                    break;
                case 4:
                    // Event: START (EVPresentVoltage, PhaseType (PhaseType)); next=491
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentVoltage);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentVoltage_isUsed = 1u;
                        grammar_id = 491;
                    }
                    break;
                case 5:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=492
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 492;
                    }
                    break;
                case 6:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 487:
            // Grammar: ID=487; read/write bits=3; START (EVReactivePower), START (EVExcitation), START (EVSetPoints), START (EVPresentVoltage), START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVReactivePower, EVReactivePowerType (EVReactivePowerType)); next=488
                    // decode: element
                    error = decode_iso20_ac_der_EVReactivePowerType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVReactivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVReactivePower_isUsed = 1u;
                        grammar_id = 488;
                    }
                    break;
                case 1:
                    // Event: START (EVExcitation, EVExcitationType (EVExcitationType)); next=489
                    // decode: element
                    error = decode_iso20_ac_der_EVExcitationType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVExcitation);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVExcitation_isUsed = 1u;
                        grammar_id = 489;
                    }
                    break;
                case 2:
                    // Event: START (EVSetPoints, EVSetPointsType (EVSetPointsType)); next=490
                    // decode: element
                    error = decode_iso20_ac_der_EVSetPointsType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVSetPoints);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVSetPoints_isUsed = 1u;
                        grammar_id = 490;
                    }
                    break;
                case 3:
                    // Event: START (EVPresentVoltage, PhaseType (PhaseType)); next=491
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentVoltage);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentVoltage_isUsed = 1u;
                        grammar_id = 491;
                    }
                    break;
                case 4:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=492
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 492;
                    }
                    break;
                case 5:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 488:
            // Grammar: ID=488; read/write bits=3; START (EVExcitation), START (EVSetPoints), START (EVPresentVoltage), START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVExcitation, EVExcitationType (EVExcitationType)); next=489
                    // decode: element
                    error = decode_iso20_ac_der_EVExcitationType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVExcitation);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVExcitation_isUsed = 1u;
                        grammar_id = 489;
                    }
                    break;
                case 1:
                    // Event: START (EVSetPoints, EVSetPointsType (EVSetPointsType)); next=490
                    // decode: element
                    error = decode_iso20_ac_der_EVSetPointsType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVSetPoints);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVSetPoints_isUsed = 1u;
                        grammar_id = 490;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentVoltage, PhaseType (PhaseType)); next=491
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentVoltage);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentVoltage_isUsed = 1u;
                        grammar_id = 491;
                    }
                    break;
                case 3:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=492
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 492;
                    }
                    break;
                case 4:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 489:
            // Grammar: ID=489; read/write bits=3; START (EVSetPoints), START (EVPresentVoltage), START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSetPoints, EVSetPointsType (EVSetPointsType)); next=490
                    // decode: element
                    error = decode_iso20_ac_der_EVSetPointsType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVSetPoints);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVSetPoints_isUsed = 1u;
                        grammar_id = 490;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentVoltage, PhaseType (PhaseType)); next=491
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentVoltage);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentVoltage_isUsed = 1u;
                        grammar_id = 491;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=492
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 492;
                    }
                    break;
                case 3:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 490:
            // Grammar: ID=490; read/write bits=3; START (EVPresentVoltage), START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentVoltage, PhaseType (PhaseType)); next=491
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentVoltage);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentVoltage_isUsed = 1u;
                        grammar_id = 491;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=492
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 492;
                    }
                    break;
                case 2:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 491:
            // Grammar: ID=491; read/write bits=2; START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=492
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 492;
                    }
                    break;
                case 1:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 492:
            // Grammar: ID=492; read/write bits=2; START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}DER_Scheduled_AC_CLResControlMode; type={urn:iso:std:iso:15118:-20:AC}DER_Scheduled_AC_CLResControlModeType; base type=Scheduled_AC_CLResControlModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: EVSETargetActivePower, RationalNumberType (0, 1); EVSETargetActivePower_L2, RationalNumberType (0, 1); EVSETargetActivePower_L3, RationalNumberType (0, 1); EVSETargetReactivePower, RationalNumberType (0, 1); EVSETargetReactivePower_L2, RationalNumberType (0, 1); EVSETargetReactivePower_L3, RationalNumberType (0, 1); EVSEPresentActivePower, RationalNumberType (0, 1); EVSEPresentActivePower_L2, RationalNumberType (0, 1); EVSEPresentActivePower_L3, RationalNumberType (0, 1); DERControl, DERControlType (0, 1);
static int decode_iso20_ac_der_DER_Scheduled_AC_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_DER_Scheduled_AC_CLResControlModeType* DER_Scheduled_AC_CLResControlModeType) {
    int grammar_id = 493;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DER_Scheduled_AC_CLResControlModeType(DER_Scheduled_AC_CLResControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 493:
            // Grammar: ID=493; read/write bits=4; START (EVSETargetActivePower), START (EVSETargetActivePower_L2), START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=494
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_isUsed = 1u;
                        grammar_id = 494;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetActivePower_L2, RationalNumberType (RationalNumberType)); next=495
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L2_isUsed = 1u;
                        grammar_id = 495;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=496
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 496;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=497
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 497;
                    }
                    break;
                case 4:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=498
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 498;
                    }
                    break;
                case 5:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=499
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 499;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=500
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 500;
                    }
                    break;
                case 7:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=501
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 501;
                    }
                    break;
                case 8:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=502
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 502;
                    }
                    break;
                case 9:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Scheduled_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 10:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 494:
            // Grammar: ID=494; read/write bits=4; START (EVSETargetActivePower_L2), START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower_L2, RationalNumberType (RationalNumberType)); next=495
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L2_isUsed = 1u;
                        grammar_id = 495;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=496
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 496;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=497
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 497;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=498
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 498;
                    }
                    break;
                case 4:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=499
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 499;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=500
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 500;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=501
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 501;
                    }
                    break;
                case 7:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=502
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 502;
                    }
                    break;
                case 8:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Scheduled_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 9:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 495:
            // Grammar: ID=495; read/write bits=4; START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=496
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 496;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=497
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 497;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=498
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 498;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=499
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 499;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=500
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 500;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=501
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 501;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=502
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 502;
                    }
                    break;
                case 7:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Scheduled_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 8:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 496:
            // Grammar: ID=496; read/write bits=4; START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=497
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 497;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=498
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 498;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=499
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 499;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=500
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 500;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=501
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 501;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=502
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 502;
                    }
                    break;
                case 6:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Scheduled_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 497:
            // Grammar: ID=497; read/write bits=3; START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=498
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 498;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=499
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 499;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=500
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 500;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=501
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 501;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=502
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 502;
                    }
                    break;
                case 5:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Scheduled_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 498:
            // Grammar: ID=498; read/write bits=3; START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=499
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 499;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=500
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 500;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=501
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 501;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=502
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 502;
                    }
                    break;
                case 4:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Scheduled_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 499:
            // Grammar: ID=499; read/write bits=3; START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=500
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 500;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=501
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 501;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=502
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 502;
                    }
                    break;
                case 3:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Scheduled_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 500:
            // Grammar: ID=500; read/write bits=3; START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=501
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 501;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=502
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 502;
                    }
                    break;
                case 2:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Scheduled_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 501:
            // Grammar: ID=501; read/write bits=2; START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=502
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 502;
                    }
                    break;
                case 1:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Scheduled_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 502:
            // Grammar: ID=502; read/write bits=2; START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Scheduled_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Scheduled_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}DER_Dynamic_AC_CLReqControlMode; type={urn:iso:std:iso:15118:-20:AC}DER_Dynamic_AC_CLReqControlModeType; base type=Dynamic_AC_CLReqControlModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DepartureTime, unsignedInt (0, 1); EVTargetEnergyRequest, RationalNumberType (1, 1); EVMaximumEnergyRequest, RationalNumberType (1, 1); EVMinimumEnergyRequest, RationalNumberType (1, 1); EVMaximumChargePower, RationalNumberType (1, 1); EVMaximumChargePower_L2, RationalNumberType (0, 1); EVMaximumChargePower_L3, RationalNumberType (0, 1); EVMinimumChargePower, RationalNumberType (1, 1); EVMinimumChargePower_L2, RationalNumberType (0, 1); EVMinimumChargePower_L3, RationalNumberType (0, 1); EVPresentActivePower, RationalNumberType (1, 1); EVPresentActivePower_L2, RationalNumberType (0, 1); EVPresentActivePower_L3, RationalNumberType (0, 1); EVPresentReactivePower, RationalNumberType (1, 1); EVPresentReactivePower_L2, RationalNumberType (0, 1); EVPresentReactivePower_L3, RationalNumberType (0, 1); EVMaximumDischargePower, PhaseType (1, 1); EVMinimumDischargePower, PhaseType (1, 1); EVSessionTotalDischargeEnergyAvailable, RationalNumberType (0, 1); EVApparentPower, EVApparentPowerType (0, 1); EVReactivePower, EVReactivePowerType (0, 1); EVExcitation, EVExcitationType (0, 1); EVSetPoints, EVSetPointsType (0, 1); EVPresentVoltage, PhaseType (0, 1); EVPresentFrequency, PhaseType (0, 1); DERGridSupportActiveInfo, DERGridSupportActiveInfoType (0, 1);
static int decode_iso20_ac_der_DER_Dynamic_AC_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_DER_Dynamic_AC_CLReqControlModeType* DER_Dynamic_AC_CLReqControlModeType) {
    int grammar_id = 503;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DER_Dynamic_AC_CLReqControlModeType(DER_Dynamic_AC_CLReqControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 503:
            // Grammar: ID=503; read/write bits=2; START (DepartureTime), START (EVTargetEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DepartureTime, unsignedInt (unsignedLong)); next=504
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DER_Dynamic_AC_CLReqControlModeType->DepartureTime);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->DepartureTime_isUsed = 1u;
                        grammar_id = 504;
                    }
                    break;
                case 1:
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=505
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVTargetEnergyRequest);
                    if (error == 0)
                    {
                        grammar_id = 505;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 504:
            // Grammar: ID=504; read/write bits=1; START (EVTargetEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=505
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVTargetEnergyRequest);
                    if (error == 0)
                    {
                        grammar_id = 505;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 505:
            // Grammar: ID=505; read/write bits=1; START (EVMaximumEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumEnergyRequest, RationalNumberType (RationalNumberType)); next=506
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMaximumEnergyRequest);
                    if (error == 0)
                    {
                        grammar_id = 506;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 506:
            // Grammar: ID=506; read/write bits=1; START (EVMinimumEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=507
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMinimumEnergyRequest);
                    if (error == 0)
                    {
                        grammar_id = 507;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 507:
            // Grammar: ID=507; read/write bits=1; START (EVMaximumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower, RationalNumberType (RationalNumberType)); next=508
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 508;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 508:
            // Grammar: ID=508; read/write bits=2; START (EVMaximumChargePower_L2), START (EVMaximumChargePower_L3), START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L2, RationalNumberType (RationalNumberType)); next=509
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L2_isUsed = 1u;
                        grammar_id = 509;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=510
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 510;
                    }
                    break;
                case 2:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=511
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 511;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 509:
            // Grammar: ID=509; read/write bits=2; START (EVMaximumChargePower_L3), START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumChargePower_L3, RationalNumberType (RationalNumberType)); next=510
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVMaximumChargePower_L3_isUsed = 1u;
                        grammar_id = 510;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=511
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 511;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 510:
            // Grammar: ID=510; read/write bits=1; START (EVMinimumChargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower, RationalNumberType (RationalNumberType)); next=511
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower);
                    if (error == 0)
                    {
                        grammar_id = 511;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 511:
            // Grammar: ID=511; read/write bits=2; START (EVMinimumChargePower_L2), START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L2, RationalNumberType (RationalNumberType)); next=512
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L2_isUsed = 1u;
                        grammar_id = 512;
                    }
                    break;
                case 1:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=513
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 513;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=514
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 514;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 512:
            // Grammar: ID=512; read/write bits=2; START (EVMinimumChargePower_L3), START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumChargePower_L3, RationalNumberType (RationalNumberType)); next=513
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVMinimumChargePower_L3_isUsed = 1u;
                        grammar_id = 513;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=514
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 514;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 513:
            // Grammar: ID=513; read/write bits=1; START (EVPresentActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower, RationalNumberType (RationalNumberType)); next=514
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentActivePower);
                    if (error == 0)
                    {
                        grammar_id = 514;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 514:
            // Grammar: ID=514; read/write bits=2; START (EVPresentActivePower_L2), START (EVPresentActivePower_L3), START (EVPresentReactivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=515
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 515;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=516
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 516;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=517
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        grammar_id = 517;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 515:
            // Grammar: ID=515; read/write bits=2; START (EVPresentActivePower_L3), START (EVPresentReactivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=516
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 516;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=517
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        grammar_id = 517;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 516:
            // Grammar: ID=516; read/write bits=1; START (EVPresentReactivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower, RationalNumberType (RationalNumberType)); next=517
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower);
                    if (error == 0)
                    {
                        grammar_id = 517;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 517:
            // Grammar: ID=517; read/write bits=2; START (EVPresentReactivePower_L2), START (EVPresentReactivePower_L3), START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower_L2, RationalNumberType (RationalNumberType)); next=518
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L2_isUsed = 1u;
                        grammar_id = 518;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=519
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 519;
                    }
                    break;
                case 2:
                    // Event: START (EVMaximumDischargePower, PhaseType (PhaseType)); next=520
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 520;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 518:
            // Grammar: ID=518; read/write bits=2; START (EVPresentReactivePower_L3), START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentReactivePower_L3, RationalNumberType (RationalNumberType)); next=519
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentReactivePower_L3_isUsed = 1u;
                        grammar_id = 519;
                    }
                    break;
                case 1:
                    // Event: START (EVMaximumDischargePower, PhaseType (PhaseType)); next=520
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 520;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 519:
            // Grammar: ID=519; read/write bits=1; START (EVMaximumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMaximumDischargePower, PhaseType (PhaseType)); next=520
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMaximumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 520;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 520:
            // Grammar: ID=520; read/write bits=1; START (EVMinimumDischargePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVMinimumDischargePower, PhaseType (PhaseType)); next=521
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVMinimumDischargePower);
                    if (error == 0)
                    {
                        grammar_id = 521;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 521:
            // Grammar: ID=521; read/write bits=4; START (EVSessionTotalDischargeEnergyAvailable), START (EVApparentPower), START (EVReactivePower), START (EVExcitation), START (EVSetPoints), START (EVPresentVoltage), START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSessionTotalDischargeEnergyAvailable, RationalNumberType (RationalNumberType)); next=522
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVSessionTotalDischargeEnergyAvailable);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVSessionTotalDischargeEnergyAvailable_isUsed = 1u;
                        grammar_id = 522;
                    }
                    break;
                case 1:
                    // Event: START (EVApparentPower, EVApparentPowerType (EVApparentPowerType)); next=523
                    // decode: element
                    error = decode_iso20_ac_der_EVApparentPowerType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVApparentPower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVApparentPower_isUsed = 1u;
                        grammar_id = 523;
                    }
                    break;
                case 2:
                    // Event: START (EVReactivePower, EVReactivePowerType (EVReactivePowerType)); next=524
                    // decode: element
                    error = decode_iso20_ac_der_EVReactivePowerType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVReactivePower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVReactivePower_isUsed = 1u;
                        grammar_id = 524;
                    }
                    break;
                case 3:
                    // Event: START (EVExcitation, EVExcitationType (EVExcitationType)); next=525
                    // decode: element
                    error = decode_iso20_ac_der_EVExcitationType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVExcitation);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVExcitation_isUsed = 1u;
                        grammar_id = 525;
                    }
                    break;
                case 4:
                    // Event: START (EVSetPoints, EVSetPointsType (EVSetPointsType)); next=526
                    // decode: element
                    error = decode_iso20_ac_der_EVSetPointsType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVSetPoints);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVSetPoints_isUsed = 1u;
                        grammar_id = 526;
                    }
                    break;
                case 5:
                    // Event: START (EVPresentVoltage, PhaseType (PhaseType)); next=527
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentVoltage);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentVoltage_isUsed = 1u;
                        grammar_id = 527;
                    }
                    break;
                case 6:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=528
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 528;
                    }
                    break;
                case 7:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 8:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 522:
            // Grammar: ID=522; read/write bits=4; START (EVApparentPower), START (EVReactivePower), START (EVExcitation), START (EVSetPoints), START (EVPresentVoltage), START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVApparentPower, EVApparentPowerType (EVApparentPowerType)); next=523
                    // decode: element
                    error = decode_iso20_ac_der_EVApparentPowerType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVApparentPower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVApparentPower_isUsed = 1u;
                        grammar_id = 523;
                    }
                    break;
                case 1:
                    // Event: START (EVReactivePower, EVReactivePowerType (EVReactivePowerType)); next=524
                    // decode: element
                    error = decode_iso20_ac_der_EVReactivePowerType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVReactivePower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVReactivePower_isUsed = 1u;
                        grammar_id = 524;
                    }
                    break;
                case 2:
                    // Event: START (EVExcitation, EVExcitationType (EVExcitationType)); next=525
                    // decode: element
                    error = decode_iso20_ac_der_EVExcitationType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVExcitation);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVExcitation_isUsed = 1u;
                        grammar_id = 525;
                    }
                    break;
                case 3:
                    // Event: START (EVSetPoints, EVSetPointsType (EVSetPointsType)); next=526
                    // decode: element
                    error = decode_iso20_ac_der_EVSetPointsType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVSetPoints);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVSetPoints_isUsed = 1u;
                        grammar_id = 526;
                    }
                    break;
                case 4:
                    // Event: START (EVPresentVoltage, PhaseType (PhaseType)); next=527
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentVoltage);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentVoltage_isUsed = 1u;
                        grammar_id = 527;
                    }
                    break;
                case 5:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=528
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 528;
                    }
                    break;
                case 6:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 523:
            // Grammar: ID=523; read/write bits=3; START (EVReactivePower), START (EVExcitation), START (EVSetPoints), START (EVPresentVoltage), START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVReactivePower, EVReactivePowerType (EVReactivePowerType)); next=524
                    // decode: element
                    error = decode_iso20_ac_der_EVReactivePowerType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVReactivePower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVReactivePower_isUsed = 1u;
                        grammar_id = 524;
                    }
                    break;
                case 1:
                    // Event: START (EVExcitation, EVExcitationType (EVExcitationType)); next=525
                    // decode: element
                    error = decode_iso20_ac_der_EVExcitationType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVExcitation);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVExcitation_isUsed = 1u;
                        grammar_id = 525;
                    }
                    break;
                case 2:
                    // Event: START (EVSetPoints, EVSetPointsType (EVSetPointsType)); next=526
                    // decode: element
                    error = decode_iso20_ac_der_EVSetPointsType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVSetPoints);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVSetPoints_isUsed = 1u;
                        grammar_id = 526;
                    }
                    break;
                case 3:
                    // Event: START (EVPresentVoltage, PhaseType (PhaseType)); next=527
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentVoltage);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentVoltage_isUsed = 1u;
                        grammar_id = 527;
                    }
                    break;
                case 4:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=528
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 528;
                    }
                    break;
                case 5:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 524:
            // Grammar: ID=524; read/write bits=3; START (EVExcitation), START (EVSetPoints), START (EVPresentVoltage), START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVExcitation, EVExcitationType (EVExcitationType)); next=525
                    // decode: element
                    error = decode_iso20_ac_der_EVExcitationType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVExcitation);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVExcitation_isUsed = 1u;
                        grammar_id = 525;
                    }
                    break;
                case 1:
                    // Event: START (EVSetPoints, EVSetPointsType (EVSetPointsType)); next=526
                    // decode: element
                    error = decode_iso20_ac_der_EVSetPointsType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVSetPoints);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVSetPoints_isUsed = 1u;
                        grammar_id = 526;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentVoltage, PhaseType (PhaseType)); next=527
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentVoltage);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentVoltage_isUsed = 1u;
                        grammar_id = 527;
                    }
                    break;
                case 3:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=528
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 528;
                    }
                    break;
                case 4:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 525:
            // Grammar: ID=525; read/write bits=3; START (EVSetPoints), START (EVPresentVoltage), START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSetPoints, EVSetPointsType (EVSetPointsType)); next=526
                    // decode: element
                    error = decode_iso20_ac_der_EVSetPointsType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVSetPoints);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVSetPoints_isUsed = 1u;
                        grammar_id = 526;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentVoltage, PhaseType (PhaseType)); next=527
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentVoltage);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentVoltage_isUsed = 1u;
                        grammar_id = 527;
                    }
                    break;
                case 2:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=528
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 528;
                    }
                    break;
                case 3:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 526:
            // Grammar: ID=526; read/write bits=3; START (EVPresentVoltage), START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentVoltage, PhaseType (PhaseType)); next=527
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentVoltage);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentVoltage_isUsed = 1u;
                        grammar_id = 527;
                    }
                    break;
                case 1:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=528
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 528;
                    }
                    break;
                case 2:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 527:
            // Grammar: ID=527; read/write bits=2; START (EVPresentFrequency), START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVPresentFrequency, PhaseType (PhaseType)); next=528
                    // decode: element
                    error = decode_iso20_ac_der_PhaseType(stream, &DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->EVPresentFrequency_isUsed = 1u;
                        grammar_id = 528;
                    }
                    break;
                case 1:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 528:
            // Grammar: ID=528; read/write bits=2; START (DERGridSupportActiveInfo), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DERGridSupportActiveInfo, DERGridSupportActiveInfoType (DERGridSupportActiveInfoType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERGridSupportActiveInfoType(stream, &DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLReqControlModeType->DERGridSupportActiveInfo_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}AC_ChargeLoopReq; type={urn:iso:std:iso:15118:-20:AC}AC_ChargeLoopReqType; base type=ChargeLoopReqType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); DisplayParameters, DisplayParametersType (0, 1); MeterInfoRequested, boolean (1, 1); BPT_Dynamic_AC_CLReqControlMode, BPT_Dynamic_AC_CLReqControlModeType (0, 1); BPT_Scheduled_AC_CLReqControlMode, BPT_Scheduled_AC_CLReqControlModeType (0, 1); CLReqControlMode, CLReqControlModeType (0, 1); DER_Dynamic_AC_CLReqControlMode, DER_Dynamic_AC_CLReqControlModeType (0, 1); DER_Scheduled_AC_CLReqControlMode, DER_Scheduled_AC_CLReqControlModeType (0, 1); Dynamic_AC_CLReqControlMode, Dynamic_AC_CLReqControlModeType (0, 1); Scheduled_AC_CLReqControlMode, Scheduled_AC_CLReqControlModeType (0, 1);
static int decode_iso20_ac_der_AC_ChargeLoopReqType(exi_bitstream_t* stream, struct iso20_ac_der_AC_ChargeLoopReqType* AC_ChargeLoopReqType) {
    int grammar_id = 529;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_AC_ChargeLoopReqType(AC_ChargeLoopReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 529:
            // Grammar: ID=529; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=530
                    // decode: element
                    error = decode_iso20_ac_der_MessageHeaderType(stream, &AC_ChargeLoopReqType->Header);
                    if (error == 0)
                    {
                        grammar_id = 530;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 530:
            // Grammar: ID=530; read/write bits=2; START (DisplayParameters), START (MeterInfoRequested)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DisplayParameters, DisplayParametersType (DisplayParametersType)); next=531
                    // decode: element
                    error = decode_iso20_ac_der_DisplayParametersType(stream, &AC_ChargeLoopReqType->DisplayParameters);
                    if (error == 0)
                    {
                        AC_ChargeLoopReqType->DisplayParameters_isUsed = 1u;
                        grammar_id = 531;
                    }
                    break;
                case 1:
                    // Event: START (MeterInfoRequested, boolean (boolean)); next=532
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                AC_ChargeLoopReqType->MeterInfoRequested = value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 532;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 531:
            // Grammar: ID=531; read/write bits=1; START (MeterInfoRequested)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MeterInfoRequested, boolean (boolean)); next=532
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                AC_ChargeLoopReqType->MeterInfoRequested = value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 532;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 532:
            // Grammar: ID=532; read/write bits=3; START (BPT_Dynamic_AC_CLReqControlMode), START (BPT_Scheduled_AC_CLReqControlMode), START (CLReqControlMode), START (DER_Dynamic_AC_CLReqControlMode), START (DER_Scheduled_AC_CLReqControlMode), START (Dynamic_AC_CLReqControlMode), START (Scheduled_AC_CLReqControlMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (BPT_Dynamic_AC_CLReqControlMode, BPT_Dynamic_AC_CLReqControlModeType (Dynamic_AC_CLReqControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_Dynamic_AC_CLReqControlModeType(stream, &AC_ChargeLoopReqType->BPT_Dynamic_AC_CLReqControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopReqType->BPT_Dynamic_AC_CLReqControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: START (BPT_Scheduled_AC_CLReqControlMode, BPT_Scheduled_AC_CLReqControlModeType (Scheduled_AC_CLReqControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_Scheduled_AC_CLReqControlModeType(stream, &AC_ChargeLoopReqType->BPT_Scheduled_AC_CLReqControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopReqType->BPT_Scheduled_AC_CLReqControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Abstract element or type: CLReqControlMode, CLReqControlModeType (CLReqControlModeType)
                    // decode: element
                    error = decode_iso20_ac_der_CLReqControlModeType(stream, &AC_ChargeLoopReqType->CLReqControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopReqType->CLReqControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: START (DER_Dynamic_AC_CLReqControlMode, DER_Dynamic_AC_CLReqControlModeType (Dynamic_AC_CLReqControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_Dynamic_AC_CLReqControlModeType(stream, &AC_ChargeLoopReqType->DER_Dynamic_AC_CLReqControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopReqType->DER_Dynamic_AC_CLReqControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: START (DER_Scheduled_AC_CLReqControlMode, DER_Scheduled_AC_CLReqControlModeType (Scheduled_AC_CLReqControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_Scheduled_AC_CLReqControlModeType(stream, &AC_ChargeLoopReqType->DER_Scheduled_AC_CLReqControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopReqType->DER_Scheduled_AC_CLReqControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: START (Dynamic_AC_CLReqControlMode, Dynamic_AC_CLReqControlModeType (Dynamic_CLReqControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_Dynamic_AC_CLReqControlModeType(stream, &AC_ChargeLoopReqType->Dynamic_AC_CLReqControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopReqType->Dynamic_AC_CLReqControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: START (Scheduled_AC_CLReqControlMode, Scheduled_AC_CLReqControlModeType (Scheduled_CLReqControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_Scheduled_AC_CLReqControlModeType(stream, &AC_ChargeLoopReqType->Scheduled_AC_CLReqControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopReqType->Scheduled_AC_CLReqControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}DER_Dynamic_AC_CLResControlMode; type={urn:iso:std:iso:15118:-20:AC}DER_Dynamic_AC_CLResControlModeType; base type=Dynamic_AC_CLResControlModeType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: DepartureTime, unsignedInt (0, 1); MinimumSOC, percentValueType (0, 1); TargetSOC, percentValueType (0, 1); AckMaxDelay, unsignedShort (0, 1); EVSETargetActivePower, RationalNumberType (1, 1); EVSETargetActivePower_L2, RationalNumberType (0, 1); EVSETargetActivePower_L3, RationalNumberType (0, 1); EVSETargetReactivePower, RationalNumberType (0, 1); EVSETargetReactivePower_L2, RationalNumberType (0, 1); EVSETargetReactivePower_L3, RationalNumberType (0, 1); EVSEPresentActivePower, RationalNumberType (0, 1); EVSEPresentActivePower_L2, RationalNumberType (0, 1); EVSEPresentActivePower_L3, RationalNumberType (0, 1); DERControl, DERControlType (0, 1);
static int decode_iso20_ac_der_DER_Dynamic_AC_CLResControlModeType(exi_bitstream_t* stream, struct iso20_ac_der_DER_Dynamic_AC_CLResControlModeType* DER_Dynamic_AC_CLResControlModeType) {
    int grammar_id = 533;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_DER_Dynamic_AC_CLResControlModeType(DER_Dynamic_AC_CLResControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 533:
            // Grammar: ID=533; read/write bits=3; START (DepartureTime), START (MinimumSOC), START (TargetSOC), START (AckMaxDelay), START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DepartureTime, unsignedInt (unsignedLong)); next=534
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DER_Dynamic_AC_CLResControlModeType->DepartureTime);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->DepartureTime_isUsed = 1u;
                        grammar_id = 534;
                    }
                    break;
                case 1:
                    // Event: START (MinimumSOC, percentValueType (byte)); next=535
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DER_Dynamic_AC_CLResControlModeType->MinimumSOC = (int8_t)value;
                                DER_Dynamic_AC_CLResControlModeType->MinimumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 535;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (TargetSOC, percentValueType (byte)); next=536
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DER_Dynamic_AC_CLResControlModeType->TargetSOC = (int8_t)value;
                                DER_Dynamic_AC_CLResControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 536;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 3:
                    // Event: START (AckMaxDelay, unsignedShort (unsignedInt)); next=537
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &DER_Dynamic_AC_CLResControlModeType->AckMaxDelay);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->AckMaxDelay_isUsed = 1u;
                        grammar_id = 537;
                    }
                    break;
                case 4:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=538
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 538;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 534:
            // Grammar: ID=534; read/write bits=3; START (MinimumSOC), START (TargetSOC), START (AckMaxDelay), START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MinimumSOC, percentValueType (byte)); next=535
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DER_Dynamic_AC_CLResControlModeType->MinimumSOC = (int8_t)value;
                                DER_Dynamic_AC_CLResControlModeType->MinimumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 535;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (TargetSOC, percentValueType (byte)); next=536
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DER_Dynamic_AC_CLResControlModeType->TargetSOC = (int8_t)value;
                                DER_Dynamic_AC_CLResControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 536;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 2:
                    // Event: START (AckMaxDelay, unsignedShort (unsignedInt)); next=537
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &DER_Dynamic_AC_CLResControlModeType->AckMaxDelay);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->AckMaxDelay_isUsed = 1u;
                        grammar_id = 537;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=538
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 538;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 535:
            // Grammar: ID=535; read/write bits=2; START (TargetSOC), START (AckMaxDelay), START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (TargetSOC, percentValueType (byte)); next=536
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                DER_Dynamic_AC_CLResControlModeType->TargetSOC = (int8_t)value;
                                DER_Dynamic_AC_CLResControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 536;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                case 1:
                    // Event: START (AckMaxDelay, unsignedShort (unsignedInt)); next=537
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &DER_Dynamic_AC_CLResControlModeType->AckMaxDelay);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->AckMaxDelay_isUsed = 1u;
                        grammar_id = 537;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=538
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 538;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 536:
            // Grammar: ID=536; read/write bits=2; START (AckMaxDelay), START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (AckMaxDelay, unsignedShort (unsignedInt)); next=537
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &DER_Dynamic_AC_CLResControlModeType->AckMaxDelay);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->AckMaxDelay_isUsed = 1u;
                        grammar_id = 537;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=538
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 538;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 537:
            // Grammar: ID=537; read/write bits=1; START (EVSETargetActivePower)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower, RationalNumberType (RationalNumberType)); next=538
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetActivePower);
                    if (error == 0)
                    {
                        grammar_id = 538;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 538:
            // Grammar: ID=538; read/write bits=4; START (EVSETargetActivePower_L2), START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower_L2, RationalNumberType (RationalNumberType)); next=539
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L2_isUsed = 1u;
                        grammar_id = 539;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=540
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 540;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=541
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 541;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=542
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 542;
                    }
                    break;
                case 4:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=543
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 543;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=544
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 544;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=545
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 545;
                    }
                    break;
                case 7:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=546
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 546;
                    }
                    break;
                case 8:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Dynamic_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 9:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 539:
            // Grammar: ID=539; read/write bits=4; START (EVSETargetActivePower_L3), START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetActivePower_L3, RationalNumberType (RationalNumberType)); next=540
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetActivePower_L3_isUsed = 1u;
                        grammar_id = 540;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=541
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 541;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=542
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 542;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=543
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 543;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=544
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 544;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=545
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 545;
                    }
                    break;
                case 6:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=546
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 546;
                    }
                    break;
                case 7:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Dynamic_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 8:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 540:
            // Grammar: ID=540; read/write bits=4; START (EVSETargetReactivePower), START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower, RationalNumberType (RationalNumberType)); next=541
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_isUsed = 1u;
                        grammar_id = 541;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=542
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 542;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=543
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 543;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=544
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 544;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=545
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 545;
                    }
                    break;
                case 5:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=546
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 546;
                    }
                    break;
                case 6:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Dynamic_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 541:
            // Grammar: ID=541; read/write bits=3; START (EVSETargetReactivePower_L2), START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower_L2, RationalNumberType (RationalNumberType)); next=542
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L2_isUsed = 1u;
                        grammar_id = 542;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=543
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 543;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=544
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 544;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=545
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 545;
                    }
                    break;
                case 4:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=546
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 546;
                    }
                    break;
                case 5:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Dynamic_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 542:
            // Grammar: ID=542; read/write bits=3; START (EVSETargetReactivePower_L3), START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetReactivePower_L3, RationalNumberType (RationalNumberType)); next=543
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSETargetReactivePower_L3_isUsed = 1u;
                        grammar_id = 543;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=544
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 544;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=545
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 545;
                    }
                    break;
                case 3:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=546
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 546;
                    }
                    break;
                case 4:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Dynamic_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 543:
            // Grammar: ID=543; read/write bits=3; START (EVSEPresentActivePower), START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower, RationalNumberType (RationalNumberType)); next=544
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_isUsed = 1u;
                        grammar_id = 544;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=545
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 545;
                    }
                    break;
                case 2:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=546
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 546;
                    }
                    break;
                case 3:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Dynamic_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 544:
            // Grammar: ID=544; read/write bits=3; START (EVSEPresentActivePower_L2), START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L2, RationalNumberType (RationalNumberType)); next=545
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L2_isUsed = 1u;
                        grammar_id = 545;
                    }
                    break;
                case 1:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=546
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 546;
                    }
                    break;
                case 2:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Dynamic_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 545:
            // Grammar: ID=545; read/write bits=2; START (EVSEPresentActivePower_L3), START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEPresentActivePower_L3, RationalNumberType (RationalNumberType)); next=546
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->EVSEPresentActivePower_L3_isUsed = 1u;
                        grammar_id = 546;
                    }
                    break;
                case 1:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Dynamic_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 546:
            // Grammar: ID=546; read/write bits=2; START (DERControl), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (DERControl, DERControlType (DERControlType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DERControlType(stream, &DER_Dynamic_AC_CLResControlModeType->DERControl);
                    if (error == 0)
                    {
                        DER_Dynamic_AC_CLResControlModeType->DERControl_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:AC}AC_ChargeLoopRes; type={urn:iso:std:iso:15118:-20:AC}AC_ChargeLoopResType; base type=ChargeLoopResType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); EVSEStatus, EVSEStatusType (0, 1); MeterInfo, MeterInfoType (0, 1); Receipt, ReceiptType (0, 1); EVSETargetFrequency, RationalNumberType (0, 1); BPT_Dynamic_AC_CLResControlMode, BPT_Dynamic_AC_CLResControlModeType (0, 1); BPT_Scheduled_AC_CLResControlMode, BPT_Scheduled_AC_CLResControlModeType (0, 1); CLResControlMode, CLResControlModeType (0, 1); DER_Dynamic_AC_CLResControlMode, DER_Dynamic_AC_CLResControlModeType (0, 1); DER_Scheduled_AC_CLResControlMode, DER_Scheduled_AC_CLResControlModeType (0, 1); Dynamic_AC_CLResControlMode, Dynamic_AC_CLResControlModeType (0, 1); Scheduled_AC_CLResControlMode, Scheduled_AC_CLResControlModeType (0, 1);
static int decode_iso20_ac_der_AC_ChargeLoopResType(exi_bitstream_t* stream, struct iso20_ac_der_AC_ChargeLoopResType* AC_ChargeLoopResType) {
    int grammar_id = 547;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_AC_ChargeLoopResType(AC_ChargeLoopResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 547:
            // Grammar: ID=547; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=548
                    // decode: element
                    error = decode_iso20_ac_der_MessageHeaderType(stream, &AC_ChargeLoopResType->Header);
                    if (error == 0)
                    {
                        grammar_id = 548;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 548:
            // Grammar: ID=548; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (ResponseCode, responseCodeType (string)); next=549
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                AC_ChargeLoopResType->ResponseCode = (iso20_ac_der_responseCodeType)value;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 549;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 549:
            // Grammar: ID=549; read/write bits=4; START (EVSEStatus), START (MeterInfo), START (Receipt), START (EVSETargetFrequency), START (BPT_Dynamic_AC_CLResControlMode), START (BPT_Scheduled_AC_CLResControlMode), START (CLResControlMode), START (DER_Dynamic_AC_CLResControlMode), START (DER_Scheduled_AC_CLResControlMode), START (Dynamic_AC_CLResControlMode), START (Scheduled_AC_CLResControlMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSEStatus, EVSEStatusType (EVSEStatusType)); next=550
                    // decode: element
                    error = decode_iso20_ac_der_EVSEStatusType(stream, &AC_ChargeLoopResType->EVSEStatus);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->EVSEStatus_isUsed = 1u;
                        grammar_id = 550;
                    }
                    break;
                case 1:
                    // Event: START (MeterInfo, MeterInfoType (MeterInfoType)); next=551
                    // decode: element
                    error = decode_iso20_ac_der_MeterInfoType(stream, &AC_ChargeLoopResType->MeterInfo);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->MeterInfo_isUsed = 1u;
                        grammar_id = 551;
                    }
                    break;
                case 2:
                    // Event: START (Receipt, ReceiptType (ReceiptType)); next=552
                    // decode: element
                    error = decode_iso20_ac_der_ReceiptType(stream, &AC_ChargeLoopResType->Receipt);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->Receipt_isUsed = 1u;
                        grammar_id = 552;
                    }
                    break;
                case 3:
                    // Event: START (EVSETargetFrequency, RationalNumberType (RationalNumberType)); next=553
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_ChargeLoopResType->EVSETargetFrequency);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->EVSETargetFrequency_isUsed = 1u;
                        grammar_id = 553;
                    }
                    break;
                case 4:
                    // Event: START (BPT_Dynamic_AC_CLResControlMode, BPT_Dynamic_AC_CLResControlModeType (Dynamic_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->BPT_Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->BPT_Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: START (BPT_Scheduled_AC_CLResControlMode, BPT_Scheduled_AC_CLResControlModeType (Scheduled_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->BPT_Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->BPT_Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Abstract element or type: CLResControlMode, CLResControlModeType (CLResControlModeType)
                    // decode: element
                    error = decode_iso20_ac_der_CLResControlModeType(stream, &AC_ChargeLoopResType->CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: START (DER_Dynamic_AC_CLResControlMode, DER_Dynamic_AC_CLResControlModeType (Dynamic_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->DER_Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->DER_Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 8:
                    // Event: START (DER_Scheduled_AC_CLResControlMode, DER_Scheduled_AC_CLResControlModeType (Scheduled_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->DER_Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->DER_Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 9:
                    // Event: START (Dynamic_AC_CLResControlMode, Dynamic_AC_CLResControlModeType (Dynamic_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 10:
                    // Event: START (Scheduled_AC_CLResControlMode, Scheduled_AC_CLResControlModeType (Scheduled_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 550:
            // Grammar: ID=550; read/write bits=4; START (MeterInfo), START (Receipt), START (EVSETargetFrequency), START (BPT_Dynamic_AC_CLResControlMode), START (BPT_Scheduled_AC_CLResControlMode), START (CLResControlMode), START (DER_Dynamic_AC_CLResControlMode), START (DER_Scheduled_AC_CLResControlMode), START (Dynamic_AC_CLResControlMode), START (Scheduled_AC_CLResControlMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (MeterInfo, MeterInfoType (MeterInfoType)); next=551
                    // decode: element
                    error = decode_iso20_ac_der_MeterInfoType(stream, &AC_ChargeLoopResType->MeterInfo);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->MeterInfo_isUsed = 1u;
                        grammar_id = 551;
                    }
                    break;
                case 1:
                    // Event: START (Receipt, ReceiptType (ReceiptType)); next=552
                    // decode: element
                    error = decode_iso20_ac_der_ReceiptType(stream, &AC_ChargeLoopResType->Receipt);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->Receipt_isUsed = 1u;
                        grammar_id = 552;
                    }
                    break;
                case 2:
                    // Event: START (EVSETargetFrequency, RationalNumberType (RationalNumberType)); next=553
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_ChargeLoopResType->EVSETargetFrequency);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->EVSETargetFrequency_isUsed = 1u;
                        grammar_id = 553;
                    }
                    break;
                case 3:
                    // Event: START (BPT_Dynamic_AC_CLResControlMode, BPT_Dynamic_AC_CLResControlModeType (Dynamic_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->BPT_Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->BPT_Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: START (BPT_Scheduled_AC_CLResControlMode, BPT_Scheduled_AC_CLResControlModeType (Scheduled_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->BPT_Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->BPT_Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Abstract element or type: CLResControlMode, CLResControlModeType (CLResControlModeType)
                    // decode: element
                    error = decode_iso20_ac_der_CLResControlModeType(stream, &AC_ChargeLoopResType->CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: START (DER_Dynamic_AC_CLResControlMode, DER_Dynamic_AC_CLResControlModeType (Dynamic_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->DER_Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->DER_Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: START (DER_Scheduled_AC_CLResControlMode, DER_Scheduled_AC_CLResControlModeType (Scheduled_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->DER_Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->DER_Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 8:
                    // Event: START (Dynamic_AC_CLResControlMode, Dynamic_AC_CLResControlModeType (Dynamic_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 9:
                    // Event: START (Scheduled_AC_CLResControlMode, Scheduled_AC_CLResControlModeType (Scheduled_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 551:
            // Grammar: ID=551; read/write bits=4; START (Receipt), START (EVSETargetFrequency), START (BPT_Dynamic_AC_CLResControlMode), START (BPT_Scheduled_AC_CLResControlMode), START (CLResControlMode), START (DER_Dynamic_AC_CLResControlMode), START (DER_Scheduled_AC_CLResControlMode), START (Dynamic_AC_CLResControlMode), START (Scheduled_AC_CLResControlMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Receipt, ReceiptType (ReceiptType)); next=552
                    // decode: element
                    error = decode_iso20_ac_der_ReceiptType(stream, &AC_ChargeLoopResType->Receipt);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->Receipt_isUsed = 1u;
                        grammar_id = 552;
                    }
                    break;
                case 1:
                    // Event: START (EVSETargetFrequency, RationalNumberType (RationalNumberType)); next=553
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_ChargeLoopResType->EVSETargetFrequency);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->EVSETargetFrequency_isUsed = 1u;
                        grammar_id = 553;
                    }
                    break;
                case 2:
                    // Event: START (BPT_Dynamic_AC_CLResControlMode, BPT_Dynamic_AC_CLResControlModeType (Dynamic_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->BPT_Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->BPT_Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: START (BPT_Scheduled_AC_CLResControlMode, BPT_Scheduled_AC_CLResControlModeType (Scheduled_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->BPT_Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->BPT_Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Abstract element or type: CLResControlMode, CLResControlModeType (CLResControlModeType)
                    // decode: element
                    error = decode_iso20_ac_der_CLResControlModeType(stream, &AC_ChargeLoopResType->CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: START (DER_Dynamic_AC_CLResControlMode, DER_Dynamic_AC_CLResControlModeType (Dynamic_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->DER_Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->DER_Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: START (DER_Scheduled_AC_CLResControlMode, DER_Scheduled_AC_CLResControlModeType (Scheduled_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->DER_Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->DER_Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: START (Dynamic_AC_CLResControlMode, Dynamic_AC_CLResControlModeType (Dynamic_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 8:
                    // Event: START (Scheduled_AC_CLResControlMode, Scheduled_AC_CLResControlModeType (Scheduled_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 552:
            // Grammar: ID=552; read/write bits=4; START (EVSETargetFrequency), START (BPT_Dynamic_AC_CLResControlMode), START (BPT_Scheduled_AC_CLResControlMode), START (CLResControlMode), START (DER_Dynamic_AC_CLResControlMode), START (DER_Scheduled_AC_CLResControlMode), START (Dynamic_AC_CLResControlMode), START (Scheduled_AC_CLResControlMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (EVSETargetFrequency, RationalNumberType (RationalNumberType)); next=553
                    // decode: element
                    error = decode_iso20_ac_der_RationalNumberType(stream, &AC_ChargeLoopResType->EVSETargetFrequency);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->EVSETargetFrequency_isUsed = 1u;
                        grammar_id = 553;
                    }
                    break;
                case 1:
                    // Event: START (BPT_Dynamic_AC_CLResControlMode, BPT_Dynamic_AC_CLResControlModeType (Dynamic_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->BPT_Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->BPT_Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Event: START (BPT_Scheduled_AC_CLResControlMode, BPT_Scheduled_AC_CLResControlModeType (Scheduled_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->BPT_Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->BPT_Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Abstract element or type: CLResControlMode, CLResControlModeType (CLResControlModeType)
                    // decode: element
                    error = decode_iso20_ac_der_CLResControlModeType(stream, &AC_ChargeLoopResType->CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: START (DER_Dynamic_AC_CLResControlMode, DER_Dynamic_AC_CLResControlModeType (Dynamic_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->DER_Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->DER_Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: START (DER_Scheduled_AC_CLResControlMode, DER_Scheduled_AC_CLResControlModeType (Scheduled_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->DER_Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->DER_Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: START (Dynamic_AC_CLResControlMode, Dynamic_AC_CLResControlModeType (Dynamic_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 7:
                    // Event: START (Scheduled_AC_CLResControlMode, Scheduled_AC_CLResControlModeType (Scheduled_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 553:
            // Grammar: ID=553; read/write bits=3; START (BPT_Dynamic_AC_CLResControlMode), START (BPT_Scheduled_AC_CLResControlMode), START (CLResControlMode), START (DER_Dynamic_AC_CLResControlMode), START (DER_Scheduled_AC_CLResControlMode), START (Dynamic_AC_CLResControlMode), START (Scheduled_AC_CLResControlMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (BPT_Dynamic_AC_CLResControlMode, BPT_Dynamic_AC_CLResControlModeType (Dynamic_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->BPT_Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->BPT_Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 1:
                    // Event: START (BPT_Scheduled_AC_CLResControlMode, BPT_Scheduled_AC_CLResControlModeType (Scheduled_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_BPT_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->BPT_Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->BPT_Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 2:
                    // Abstract element or type: CLResControlMode, CLResControlModeType (CLResControlModeType)
                    // decode: element
                    error = decode_iso20_ac_der_CLResControlModeType(stream, &AC_ChargeLoopResType->CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 3:
                    // Event: START (DER_Dynamic_AC_CLResControlMode, DER_Dynamic_AC_CLResControlModeType (Dynamic_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->DER_Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->DER_Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 4:
                    // Event: START (DER_Scheduled_AC_CLResControlMode, DER_Scheduled_AC_CLResControlModeType (Scheduled_AC_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_DER_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->DER_Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->DER_Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 5:
                    // Event: START (Dynamic_AC_CLResControlMode, Dynamic_AC_CLResControlModeType (Dynamic_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_Dynamic_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->Dynamic_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->Dynamic_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                case 6:
                    // Event: START (Scheduled_AC_CLResControlMode, Scheduled_AC_CLResControlModeType (Scheduled_CLResControlModeType)); next=2
                    // decode: element
                    error = decode_iso20_ac_der_Scheduled_AC_CLResControlModeType(stream, &AC_ChargeLoopResType->Scheduled_AC_CLResControlMode);
                    if (error == 0)
                    {
                        AC_ChargeLoopResType->Scheduled_AC_CLResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Manifest; type={http://www.w3.org/2000/09/xmldsig#}ManifestType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); Reference, ReferenceType (1, 4) (original max unbounded);
static int decode_iso20_ac_der_ManifestType(exi_bitstream_t* stream, struct iso20_ac_der_ManifestType* ManifestType) {
    int grammar_id = 554;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_ManifestType(ManifestType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 554:
            // Grammar: ID=554; read/write bits=2; START (Id), START (Reference)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Id, ID (NCName)); next=556
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ManifestType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (ManifestType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ManifestType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ManifestType->Id.charactersLen, ManifestType->Id.characters, iso20_ac_der_Id_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ManifestType->Id_isUsed = 1u;
                    grammar_id = 556;
                    break;
                case 1:
                    // Event: START (Reference, ReferenceType (ReferenceType)); next=555
                    // decode: element array
                    if (ManifestType->Reference.arrayLen < iso20_ac_der_ReferenceType_4_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_ReferenceType(stream, &ManifestType->Reference.array[ManifestType->Reference.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_ReferenceType_4_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 555;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 555:
            // Grammar: ID=555; read/write bits=2; LOOP (Reference), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: LOOP (Reference, ReferenceType (ReferenceType)); next=555
                    // decode: element array
                    if (ManifestType->Reference.arrayLen < iso20_ac_der_ReferenceType_4_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_ReferenceType(stream, &ManifestType->Reference.array[ManifestType->Reference.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_ReferenceType_4_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 555;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 556:
            // Grammar: ID=556; read/write bits=1; START (Reference)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Reference, ReferenceType (ReferenceType)); next=557
                    // decode: element array
                    if (ManifestType->Reference.arrayLen < iso20_ac_der_ReferenceType_4_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_ReferenceType(stream, &ManifestType->Reference.array[ManifestType->Reference.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_ReferenceType_4_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 557;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 557:
            // Grammar: ID=557; read/write bits=2; LOOP (Reference), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: LOOP (Reference, ReferenceType (ReferenceType)); next=557
                    // decode: element array
                    if (ManifestType->Reference.arrayLen < iso20_ac_der_ReferenceType_4_ARRAY_SIZE)
                    {
                        error = decode_iso20_ac_der_ReferenceType(stream, &ManifestType->Reference.array[ManifestType->Reference.arrayLen++]);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ac_der_ReferenceType_4_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 557;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureProperties; type={http://www.w3.org/2000/09/xmldsig#}SignaturePropertiesType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); SignatureProperty, SignaturePropertyType (1, 1) (original max unbounded);
static int decode_iso20_ac_der_SignaturePropertiesType(exi_bitstream_t* stream, struct iso20_ac_der_SignaturePropertiesType* SignaturePropertiesType) {
    int grammar_id = 558;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ac_der_SignaturePropertiesType(SignaturePropertiesType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 558:
            // Grammar: ID=558; read/write bits=2; START (Id), START (SignatureProperty)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (Id, ID (NCName)); next=560
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignaturePropertiesType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignaturePropertiesType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignaturePropertiesType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignaturePropertiesType->Id.charactersLen, SignaturePropertiesType->Id.characters, iso20_ac_der_Id_CHARACTER_SIZE);
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SignaturePropertiesType->Id_isUsed = 1u;
                    grammar_id = 560;
                    break;
                case 1:
                    // Event: START (SignatureProperty, SignaturePropertyType (SignaturePropertyType)); next=559
                    // decode: element
                    error = decode_iso20_ac_der_SignaturePropertyType(stream, &SignaturePropertiesType->SignatureProperty);
                    if (error == 0)
                    {
                        grammar_id = 559;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 559:
            // Grammar: ID=559; read/write bits=2; START (SignatureProperty), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (SignatureProperty, SignaturePropertyType (SignaturePropertyType)); next=2
                    // decode: element
                    // This element should not occur a further time, its representation was reduced to a single element
                    error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 560:
            // Grammar: ID=560; read/write bits=1; START (SignatureProperty)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (SignatureProperty, SignaturePropertyType (SignaturePropertyType)); next=561
                    // decode: element
                    error = decode_iso20_ac_der_SignaturePropertyType(stream, &SignaturePropertiesType->SignatureProperty);
                    if (error == 0)
                    {
                        grammar_id = 561;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 561:
            // Grammar: ID=561; read/write bits=2; START (SignatureProperty), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: START (SignatureProperty, SignaturePropertyType (SignaturePropertyType)); next=2
                    // decode: element
                    // This element should not occur a further time, its representation was reduced to a single element
                    error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    break;
                case 1:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}


// main function for decoding
int decode_iso20_ac_der_exiDocument(exi_bitstream_t* stream, struct iso20_ac_der_exiDocument* exiDoc) {
    uint32_t eventCode;
    int error = exi_header_read_and_check(stream);

    if (error == 0)
    {
        init_iso20_ac_der_exiDocument(exiDoc);

        error = exi_basetypes_decoder_nbit_uint(stream, 6, &eventCode);
        if (error == 0)
        {
            switch (eventCode)
            {
            case 0:
                error = decode_iso20_ac_der_AC_CPDReqEnergyTransferModeType(stream, &exiDoc->AC_CPDReqEnergyTransferMode);
                exiDoc->AC_CPDReqEnergyTransferMode_isUsed = 1u;
                break;
            case 1:
                error = decode_iso20_ac_der_AC_CPDResEnergyTransferModeType(stream, &exiDoc->AC_CPDResEnergyTransferMode);
                exiDoc->AC_CPDResEnergyTransferMode_isUsed = 1u;
                break;
            case 2:
                error = decode_iso20_ac_der_AC_ChargeLoopReqType(stream, &exiDoc->AC_ChargeLoopReq);
                exiDoc->AC_ChargeLoopReq_isUsed = 1u;
                break;
            case 3:
                error = decode_iso20_ac_der_AC_ChargeLoopResType(stream, &exiDoc->AC_ChargeLoopRes);
                exiDoc->AC_ChargeLoopRes_isUsed = 1u;
                break;
            case 4:
                error = decode_iso20_ac_der_AC_ChargeParameterDiscoveryReqType(stream, &exiDoc->AC_ChargeParameterDiscoveryReq);
                exiDoc->AC_ChargeParameterDiscoveryReq_isUsed = 1u;
                break;
            case 5:
                error = decode_iso20_ac_der_AC_ChargeParameterDiscoveryResType(stream, &exiDoc->AC_ChargeParameterDiscoveryRes);
                exiDoc->AC_ChargeParameterDiscoveryRes_isUsed = 1u;
                break;
            case 6:
                error = decode_iso20_ac_der_BPT_AC_CPDReqEnergyTransferModeType(stream, &exiDoc->BPT_AC_CPDReqEnergyTransferMode);
                exiDoc->BPT_AC_CPDReqEnergyTransferMode_isUsed = 1u;
                break;
            case 7:
                error = decode_iso20_ac_der_BPT_AC_CPDResEnergyTransferModeType(stream, &exiDoc->BPT_AC_CPDResEnergyTransferMode);
                exiDoc->BPT_AC_CPDResEnergyTransferMode_isUsed = 1u;
                break;
            case 8:
                error = decode_iso20_ac_der_BPT_Dynamic_AC_CLReqControlModeType(stream, &exiDoc->BPT_Dynamic_AC_CLReqControlMode);
                exiDoc->BPT_Dynamic_AC_CLReqControlMode_isUsed = 1u;
                break;
            case 9:
                error = decode_iso20_ac_der_BPT_Dynamic_AC_CLResControlModeType(stream, &exiDoc->BPT_Dynamic_AC_CLResControlMode);
                exiDoc->BPT_Dynamic_AC_CLResControlMode_isUsed = 1u;
                break;
            case 10:
                error = decode_iso20_ac_der_BPT_Scheduled_AC_CLReqControlModeType(stream, &exiDoc->BPT_Scheduled_AC_CLReqControlMode);
                exiDoc->BPT_Scheduled_AC_CLReqControlMode_isUsed = 1u;
                break;
            case 11:
                error = decode_iso20_ac_der_BPT_Scheduled_AC_CLResControlModeType(stream, &exiDoc->BPT_Scheduled_AC_CLResControlMode);
                exiDoc->BPT_Scheduled_AC_CLResControlMode_isUsed = 1u;
                break;
            case 12:
                error = decode_iso20_ac_der_CLReqControlModeType(stream, &exiDoc->CLReqControlMode);
                exiDoc->CLReqControlMode_isUsed = 1u;
                break;
            case 13:
                error = decode_iso20_ac_der_CLResControlModeType(stream, &exiDoc->CLResControlMode);
                exiDoc->CLResControlMode_isUsed = 1u;
                break;
            case 14:
                error = decode_iso20_ac_der_CanonicalizationMethodType(stream, &exiDoc->CanonicalizationMethod);
                exiDoc->CanonicalizationMethod_isUsed = 1u;
                break;
            case 15:
                error = decode_iso20_ac_der_DER_AC_CPDReqEnergyTransferModeType(stream, &exiDoc->DER_AC_CPDReqEnergyTransferMode);
                exiDoc->DER_AC_CPDReqEnergyTransferMode_isUsed = 1u;
                break;
            case 16:
                error = decode_iso20_ac_der_DER_AC_CPDResEnergyTransferModeType(stream, &exiDoc->DER_AC_CPDResEnergyTransferMode);
                exiDoc->DER_AC_CPDResEnergyTransferMode_isUsed = 1u;
                break;
            case 17:
                error = decode_iso20_ac_der_DER_Dynamic_AC_CLReqControlModeType(stream, &exiDoc->DER_Dynamic_AC_CLReqControlMode);
                exiDoc->DER_Dynamic_AC_CLReqControlMode_isUsed = 1u;
                break;
            case 18:
                error = decode_iso20_ac_der_DER_Dynamic_AC_CLResControlModeType(stream, &exiDoc->DER_Dynamic_AC_CLResControlMode);
                exiDoc->DER_Dynamic_AC_CLResControlMode_isUsed = 1u;
                break;
            case 19:
                error = decode_iso20_ac_der_DER_Scheduled_AC_CLReqControlModeType(stream, &exiDoc->DER_Scheduled_AC_CLReqControlMode);
                exiDoc->DER_Scheduled_AC_CLReqControlMode_isUsed = 1u;
                break;
            case 20:
                error = decode_iso20_ac_der_DER_Scheduled_AC_CLResControlModeType(stream, &exiDoc->DER_Scheduled_AC_CLResControlMode);
                exiDoc->DER_Scheduled_AC_CLResControlMode_isUsed = 1u;
                break;
            case 21:
                error = decode_iso20_ac_der_DSAKeyValueType(stream, &exiDoc->DSAKeyValue);
                exiDoc->DSAKeyValue_isUsed = 1u;
                break;
            case 22:
                error = decode_iso20_ac_der_DigestMethodType(stream, &exiDoc->DigestMethod);
                exiDoc->DigestMethod_isUsed = 1u;
                break;
            case 23:
                // simple type! decode_iso20_ac_der_DigestValue;
                break;
            case 24:
                error = decode_iso20_ac_der_Dynamic_AC_CLReqControlModeType(stream, &exiDoc->Dynamic_AC_CLReqControlMode);
                exiDoc->Dynamic_AC_CLReqControlMode_isUsed = 1u;
                break;
            case 25:
                error = decode_iso20_ac_der_Dynamic_AC_CLResControlModeType(stream, &exiDoc->Dynamic_AC_CLResControlMode);
                exiDoc->Dynamic_AC_CLResControlMode_isUsed = 1u;
                break;
            case 26:
                error = decode_iso20_ac_der_EU_FrequencyDroopType(stream, &exiDoc->EU_FrequencyDroop);
                exiDoc->EU_FrequencyDroop_isUsed = 1u;
                break;
            case 27:
                error = decode_iso20_ac_der_FrequencyDroopType(stream, &exiDoc->FrequencyDroop);
                exiDoc->FrequencyDroop_isUsed = 1u;
                break;
            case 28:
                error = decode_iso20_ac_der_KeyInfoType(stream, &exiDoc->KeyInfo);
                exiDoc->KeyInfo_isUsed = 1u;
                break;
            case 29:
                // simple type! decode_iso20_ac_der_KeyName;
                break;
            case 30:
                error = decode_iso20_ac_der_KeyValueType(stream, &exiDoc->KeyValue);
                exiDoc->KeyValue_isUsed = 1u;
                break;
            case 31:
                error = decode_iso20_ac_der_ManifestType(stream, &exiDoc->Manifest);
                exiDoc->Manifest_isUsed = 1u;
                break;
            case 32:
                // simple type! decode_iso20_ac_der_MgmtData;
                break;
            case 33:
                error = decode_iso20_ac_der_ObjectType(stream, &exiDoc->Object);
                exiDoc->Object_isUsed = 1u;
                break;
            case 34:
                error = decode_iso20_ac_der_PGPDataType(stream, &exiDoc->PGPData);
                exiDoc->PGPData_isUsed = 1u;
                break;
            case 35:
                error = decode_iso20_ac_der_RSAKeyValueType(stream, &exiDoc->RSAKeyValue);
                exiDoc->RSAKeyValue_isUsed = 1u;
                break;
            case 36:
                error = decode_iso20_ac_der_ReferenceType(stream, &exiDoc->Reference);
                exiDoc->Reference_isUsed = 1u;
                break;
            case 37:
                error = decode_iso20_ac_der_RetrievalMethodType(stream, &exiDoc->RetrievalMethod);
                exiDoc->RetrievalMethod_isUsed = 1u;
                break;
            case 38:
                error = decode_iso20_ac_der_SPKIDataType(stream, &exiDoc->SPKIData);
                exiDoc->SPKIData_isUsed = 1u;
                break;
            case 39:
                error = decode_iso20_ac_der_Scheduled_AC_CLReqControlModeType(stream, &exiDoc->Scheduled_AC_CLReqControlMode);
                exiDoc->Scheduled_AC_CLReqControlMode_isUsed = 1u;
                break;
            case 40:
                error = decode_iso20_ac_der_Scheduled_AC_CLResControlModeType(stream, &exiDoc->Scheduled_AC_CLResControlMode);
                exiDoc->Scheduled_AC_CLResControlMode_isUsed = 1u;
                break;
            case 41:
                error = decode_iso20_ac_der_SignatureMethodType(stream, &exiDoc->SignatureMethod);
                exiDoc->SignatureMethod_isUsed = 1u;
                break;
            case 42:
                error = decode_iso20_ac_der_SignaturePropertiesType(stream, &exiDoc->SignatureProperties);
                exiDoc->SignatureProperties_isUsed = 1u;
                break;
            case 43:
                error = decode_iso20_ac_der_SignaturePropertyType(stream, &exiDoc->SignatureProperty);
                exiDoc->SignatureProperty_isUsed = 1u;
                break;
            case 44:
                error = decode_iso20_ac_der_SignatureType(stream, &exiDoc->Signature);
                exiDoc->Signature_isUsed = 1u;
                break;
            case 45:
                error = decode_iso20_ac_der_SignatureValueType(stream, &exiDoc->SignatureValue);
                exiDoc->SignatureValue_isUsed = 1u;
                break;
            case 46:
                error = decode_iso20_ac_der_SignedInfoType(stream, &exiDoc->SignedInfo);
                exiDoc->SignedInfo_isUsed = 1u;
                break;
            case 47:
                error = decode_iso20_ac_der_TransformType(stream, &exiDoc->Transform);
                exiDoc->Transform_isUsed = 1u;
                break;
            case 48:
                error = decode_iso20_ac_der_TransformsType(stream, &exiDoc->Transforms);
                exiDoc->Transforms_isUsed = 1u;
                break;
            case 49:
                error = decode_iso20_ac_der_US_FrequencyDroopType(stream, &exiDoc->US_FrequencyDroop);
                exiDoc->US_FrequencyDroop_isUsed = 1u;
                break;
            case 50:
                error = decode_iso20_ac_der_X509DataType(stream, &exiDoc->X509Data);
                exiDoc->X509Data_isUsed = 1u;
                break;
            default:
                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                break;
            }
        }
    }

    return error;
}

// main function for decoding fragment
int decode_iso20_ac_der_exiFragment(exi_bitstream_t* stream, struct iso20_ac_der_exiFragment* exiFrag) {
    uint32_t eventCode;
    int error = exi_header_read_and_check(stream);

    if (error == EXI_ERROR__NO_ERROR)
    {
        init_iso20_ac_der_exiFragment(exiFrag);

        error = exi_basetypes_decoder_nbit_uint(stream, 9, &eventCode);
        if (error == EXI_ERROR__NO_ERROR)
        {
            error = EXI_ERROR__NOT_IMPLEMENTED_YET;
            switch (eventCode)
            {
            case 0:
                // AC_CPDReqEnergyTransferMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 1:
                // AC_CPDResEnergyTransferMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 2:
                // AC_ChargeLoopReq (urn:iso:std:iso:15118:-20:AC)
                break;
            case 3:
                // AC_ChargeLoopRes (urn:iso:std:iso:15118:-20:AC)
                break;
            case 4:
                // AC_ChargeParameterDiscoveryReq (urn:iso:std:iso:15118:-20:AC)
                break;
            case 5:
                // AC_ChargeParameterDiscoveryRes (urn:iso:std:iso:15118:-20:AC)
                error = decode_iso20_ac_der_AC_ChargeParameterDiscoveryResType(stream, &exiFrag->AC_ChargeParameterDiscoveryRes);
                exiFrag->AC_ChargeParameterDiscoveryRes_isUsed = 1u;
                break;
            case 6:
                // AckMaxDelay (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 7:
                // ActivePowerSupport (urn:iso:std:iso:15118:-20:AC)
                break;
            case 8:
                // AdditionalServicesCosts (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 9:
                // Amount (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 10:
                // AnyPhase (urn:iso:std:iso:15118:-20:AC)
                break;
            case 11:
                // BPT_AC_CPDReqEnergyTransferMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 12:
                // BPT_AC_CPDResEnergyTransferMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 13:
                // BPT_DischargedEnergyReadingWh (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 14:
                // BPT_Dynamic_AC_CLReqControlMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 15:
                // BPT_Dynamic_AC_CLResControlMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 16:
                // BPT_InductiveEnergyReadingVARh (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 17:
                // BPT_Scheduled_AC_CLReqControlMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 18:
                // BPT_Scheduled_AC_CLResControlMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 19:
                // BatteryEnergyCapacity (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 20:
                // CLReqControlMode (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 21:
                // CLResControlMode (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 22:
                // CanonicalizationMethod (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 23:
                // CapacitiveEnergyReadingVARh (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 24:
                // ChargedEnergyReadingWh (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 25:
                // ChargingComplete (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 26:
                // ConstantPowerFactor (urn:iso:std:iso:15118:-20:AC)
                break;
            case 27:
                // ConstantVar (urn:iso:std:iso:15118:-20:AC)
                break;
            case 28:
                // CostPerUnit (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 29:
                // CurveDataPoint (urn:iso:std:iso:15118:-20:AC)
                break;
            case 30:
                // CurveDataPoints (urn:iso:std:iso:15118:-20:AC)
                break;
            case 31:
                // DERControl (urn:iso:std:iso:15118:-20:AC)
                break;
            case 32:
                // DERFunctionName (urn:iso:std:iso:15118:-20:AC)
                break;
            case 33:
                // DERGridSupportActiveInfo (urn:iso:std:iso:15118:-20:AC)
                break;
            case 34:
                // DER_AC_CPDReqEnergyTransferMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 35:
                // DER_AC_CPDResEnergyTransferMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 36:
                // DER_Dynamic_AC_CLReqControlMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 37:
                // DER_Dynamic_AC_CLResControlMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 38:
                // DER_Scheduled_AC_CLReqControlMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 39:
                // DER_Scheduled_AC_CLResControlMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 40:
                // DSAKeyValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 41:
                // DeactivationTime (urn:iso:std:iso:15118:-20:AC)
                break;
            case 42:
                // DeadBand (urn:iso:std:iso:15118:-20:AC)
                break;
            case 43:
                // DepartureTime (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 44:
                // DigestMethod (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 45:
                // DigestValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 46:
                // DisplayParameters (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 47:
                // Dynamic_AC_CLReqControlMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 48:
                // Dynamic_AC_CLResControlMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 49:
                // EU_FrequencyDroop (urn:iso:std:iso:15118:-20:AC)
                break;
            case 50:
                // EVApparentPower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 51:
                // EVApparentPowerLimits (urn:iso:std:iso:15118:-20:AC)
                break;
            case 52:
                // EVExcitation (urn:iso:std:iso:15118:-20:AC)
                break;
            case 53:
                // EVExcitationLimits (urn:iso:std:iso:15118:-20:AC)
                break;
            case 54:
                // EVInverterDetails (urn:iso:std:iso:15118:-20:AC)
                break;
            case 55:
                // EVInverterHwVersion (urn:iso:std:iso:15118:-20:AC)
                break;
            case 56:
                // EVInverterManufacturer (urn:iso:std:iso:15118:-20:AC)
                break;
            case 57:
                // EVInverterModel (urn:iso:std:iso:15118:-20:AC)
                break;
            case 58:
                // EVInverterSerialNumber (urn:iso:std:iso:15118:-20:AC)
                break;
            case 59:
                // EVInverterSwVersion (urn:iso:std:iso:15118:-20:AC)
                break;
            case 60:
                // EVMaximumApparentPower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 61:
                // EVMaximumChargeApparentPower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 62:
                // EVMaximumChargePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 63:
                // EVMaximumChargePower_L2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 64:
                // EVMaximumChargePower_L3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 65:
                // EVMaximumChargeReactivePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 66:
                // EVMaximumDischargeApparentPower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 67:
                // EVMaximumDischargePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 68:
                // EVMaximumDischargePower_L2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 69:
                // EVMaximumDischargePower_L3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 70:
                // EVMaximumDischargeReactivePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 71:
                // EVMaximumEnergyRequest (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 72:
                // EVMaximumV2XEnergyRequest (urn:iso:std:iso:15118:-20:AC)
                break;
            case 73:
                // EVMinimumChargePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 74:
                // EVMinimumChargePower_L2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 75:
                // EVMinimumChargePower_L3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 76:
                // EVMinimumChargeReactivePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 77:
                // EVMinimumDischargePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 78:
                // EVMinimumDischargePower_L2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 79:
                // EVMinimumDischargePower_L3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 80:
                // EVMinimumDischargeReactivePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 81:
                // EVMinimumEnergyRequest (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 82:
                // EVMinimumV2XEnergyRequest (urn:iso:std:iso:15118:-20:AC)
                break;
            case 83:
                // EVOverExcitedMaximumDischargePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 84:
                // EVOverExcitedMaximumPowerFactor (urn:iso:std:iso:15118:-20:AC)
                break;
            case 85:
                // EVOverExcitedPowerFactor (urn:iso:std:iso:15118:-20:AC)
                break;
            case 86:
                // EVPresentActivePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 87:
                // EVPresentActivePower_L2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 88:
                // EVPresentActivePower_L3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 89:
                // EVPresentFrequency (urn:iso:std:iso:15118:-20:AC)
                break;
            case 90:
                // EVPresentReactivePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 91:
                // EVPresentReactivePower_L2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 92:
                // EVPresentReactivePower_L3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 93:
                // EVPresentVoltage (urn:iso:std:iso:15118:-20:AC)
                break;
            case 94:
                // EVProcessing (urn:iso:std:iso:15118:-20:AC)
                break;
            case 95:
                // EVReactivePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 96:
                // EVReactivePowerLimits (urn:iso:std:iso:15118:-20:AC)
                break;
            case 97:
                // EVReactiveSusceptance (urn:iso:std:iso:15118:-20:AC)
                break;
            case 98:
                // EVSEMaximumChargePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 99:
                // EVSEMaximumChargePower_L2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 100:
                // EVSEMaximumChargePower_L3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 101:
                // EVSEMaximumChargeReactivePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 102:
                // EVSEMaximumDischargePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 103:
                // EVSEMaximumDischargePower_L2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 104:
                // EVSEMaximumDischargePower_L3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 105:
                // EVSEMaximumDischargeReactivePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 106:
                // EVSEMinimumChargePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 107:
                // EVSEMinimumChargePower_L2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 108:
                // EVSEMinimumChargePower_L3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 109:
                // EVSEMinimumDischargePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 110:
                // EVSEMinimumDischargePower_L2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 111:
                // EVSEMinimumDischargePower_L3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 112:
                // EVSENominalFrequency (urn:iso:std:iso:15118:-20:AC)
                break;
            case 113:
                // EVSENominalPower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 114:
                // EVSENotification (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 115:
                // EVSEPowerRampLimitation (urn:iso:std:iso:15118:-20:AC)
                break;
            case 116:
                // EVSEPresentActivePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 117:
                // EVSEPresentActivePower_L2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 118:
                // EVSEPresentActivePower_L3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 119:
                // EVSEStatus (urn:iso:std:iso:15118:-20:AC)
                break;
            case 120:
                // EVSEStatus (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 121:
                // EVSETargetActivePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 122:
                // EVSETargetActivePower_L2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 123:
                // EVSETargetActivePower_L3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 124:
                // EVSETargetFrequency (urn:iso:std:iso:15118:-20:AC)
                break;
            case 125:
                // EVSETargetReactivePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 126:
                // EVSETargetReactivePower_L2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 127:
                // EVSETargetReactivePower_L3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 128:
                // EVSessionTotalDischargeEnergyAvailable (urn:iso:std:iso:15118:-20:AC)
                break;
            case 129:
                // EVSetMaximumNominalVoltage (urn:iso:std:iso:15118:-20:AC)
                break;
            case 130:
                // EVSetMinimumNominalVoltage (urn:iso:std:iso:15118:-20:AC)
                break;
            case 131:
                // EVSetNominalVoltage (urn:iso:std:iso:15118:-20:AC)
                break;
            case 132:
                // EVSetNominalVoltageOffset (urn:iso:std:iso:15118:-20:AC)
                break;
            case 133:
                // EVSetPoints (urn:iso:std:iso:15118:-20:AC)
                break;
            case 134:
                // EVTargetEnergyRequest (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 135:
                // EVUnderExcitedMaximumDischargePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 136:
                // EVUnderExcitedMaximumPowerFactor (urn:iso:std:iso:15118:-20:AC)
                break;
            case 137:
                // EVUnderExcitedPowerFactor (urn:iso:std:iso:15118:-20:AC)
                break;
            case 138:
                // Enable (urn:iso:std:iso:15118:-20:AC)
                break;
            case 139:
                // EnergyCosts (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 140:
                // EnterService (urn:iso:std:iso:15118:-20:AC)
                break;
            case 141:
                // EnterServiceDelay (urn:iso:std:iso:15118:-20:AC)
                break;
            case 142:
                // EnterServiceFrequencyHigh (urn:iso:std:iso:15118:-20:AC)
                break;
            case 143:
                // EnterServiceFrequencyLow (urn:iso:std:iso:15118:-20:AC)
                break;
            case 144:
                // EnterServiceGradient (urn:iso:std:iso:15118:-20:AC)
                break;
            case 145:
                // EnterServiceRampTime (urn:iso:std:iso:15118:-20:AC)
                break;
            case 146:
                // EnterServiceRandomizedDelay (urn:iso:std:iso:15118:-20:AC)
                break;
            case 147:
                // EnterServiceVoltageHigh (urn:iso:std:iso:15118:-20:AC)
                break;
            case 148:
                // EnterServiceVoltageLow (urn:iso:std:iso:15118:-20:AC)
                break;
            case 149:
                // EventCondition (urn:iso:std:iso:15118:-20:AC)
                break;
            case 150:
                // Exponent (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 151:
                // Exponent (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 152:
                // ExtraInfo (urn:iso:std:iso:15118:-20:AC)
                break;
            case 153:
                // FaultRideThrough (urn:iso:std:iso:15118:-20:AC)
                break;
            case 154:
                // FrequencyDroop (urn:iso:std:iso:15118:-20:AC)
                break;
            case 155:
                // FrequencyTrip (urn:iso:std:iso:15118:-20:AC)
                break;
            case 156:
                // FrequencyWatt (urn:iso:std:iso:15118:-20:AC)
                break;
            case 157:
                // Fstart (urn:iso:std:iso:15118:-20:AC)
                break;
            case 158:
                // Fstop (urn:iso:std:iso:15118:-20:AC)
                break;
            case 159:
                // G (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 160:
                // GridEventFault (urn:iso:std:iso:15118:-20:AC)
                break;
            case 161:
                // GridLimits (urn:iso:std:iso:15118:-20:AC)
                break;
            case 162:
                // GridMaxFrequency (urn:iso:std:iso:15118:-20:AC)
                break;
            case 163:
                // GridMaximumVoltage (urn:iso:std:iso:15118:-20:AC)
                break;
            case 164:
                // GridMinFrequency (urn:iso:std:iso:15118:-20:AC)
                break;
            case 165:
                // GridMinimumVoltage (urn:iso:std:iso:15118:-20:AC)
                break;
            case 166:
                // GridNominalFrequency (urn:iso:std:iso:15118:-20:AC)
                break;
            case 167:
                // GridNominalVoltage (urn:iso:std:iso:15118:-20:AC)
                break;
            case 168:
                // GridNominalVoltageOffset (urn:iso:std:iso:15118:-20:AC)
                break;
            case 169:
                // HMACOutputLength (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 170:
                // Header (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 171:
                // High (urn:iso:std:iso:15118:-20:AC)
                break;
            case 172:
                // HysteresisControl (urn:iso:std:iso:15118:-20:AC)
                break;
            case 173:
                // HysteresisDelay (urn:iso:std:iso:15118:-20:AC)
                break;
            case 174:
                // HysteresisGradient (urn:iso:std:iso:15118:-20:AC)
                break;
            case 175:
                // HysteresisHigh (urn:iso:std:iso:15118:-20:AC)
                break;
            case 176:
                // HysteresisLow (urn:iso:std:iso:15118:-20:AC)
                break;
            case 177:
                // InletHot (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 178:
                // IntentionalDelay (urn:iso:std:iso:15118:-20:AC)
                break;
            case 179:
                // IntentionalDelayFstop (urn:iso:std:iso:15118:-20:AC)
                break;
            case 180:
                // IntentionalDelayPowerControl (urn:iso:std:iso:15118:-20:AC)
                break;
            case 181:
                // J (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 182:
                // KeyInfo (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 183:
                // KeyName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 184:
                // KeyValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 185:
                // LimitMaxDischargePower (urn:iso:std:iso:15118:-20:AC)
                break;
            case 186:
                // LockInValue (urn:iso:std:iso:15118:-20:AC)
                break;
            case 187:
                // LockOutValue (urn:iso:std:iso:15118:-20:AC)
                break;
            case 188:
                // Low (urn:iso:std:iso:15118:-20:AC)
                break;
            case 189:
                // Manifest (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 190:
                // MaxReactionTime (urn:iso:std:iso:15118:-20:AC)
                break;
            case 191:
                // MaximumLevel1DCInjection (urn:iso:std:iso:15118:-20:AC)
                break;
            case 192:
                // MaximumLevel2DCInjection (urn:iso:std:iso:15118:-20:AC)
                break;
            case 193:
                // MaximumPowerAsymmetry (urn:iso:std:iso:15118:-20:AC)
                break;
            case 194:
                // MaximumSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 195:
                // MeterID (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 196:
                // MeterInfo (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 197:
                // MeterInfoRequested (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 198:
                // MeterSignature (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 199:
                // MeterStatus (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 200:
                // MeterTimestamp (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 201:
                // MgmtData (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 202:
                // MidHigh (urn:iso:std:iso:15118:-20:AC)
                break;
            case 203:
                // MidLow (urn:iso:std:iso:15118:-20:AC)
                break;
            case 204:
                // MinimumSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 205:
                // Modulus (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 206:
                // NotificationMaxDelay (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 207:
                // Object (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 208:
                // OccupancyCosts (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 209:
                // OpenLoopResponseTime (urn:iso:std:iso:15118:-20:AC)
                break;
            case 210:
                // OverFrequencyDroop (urn:iso:std:iso:15118:-20:AC)
                break;
            case 211:
                // OverFrequencyMayTripCurve (urn:iso:std:iso:15118:-20:AC)
                break;
            case 212:
                // OverFrequencyMustTripCurve (urn:iso:std:iso:15118:-20:AC)
                break;
            case 213:
                // OverVoltage10MinMeanTripDelay (urn:iso:std:iso:15118:-20:AC)
                break;
            case 214:
                // OverVoltageMayTripCurve (urn:iso:std:iso:15118:-20:AC)
                break;
            case 215:
                // OverVoltageMeanValue10min (urn:iso:std:iso:15118:-20:AC)
                break;
            case 216:
                // OverVoltageMomentaryCessationTripCurve (urn:iso:std:iso:15118:-20:AC)
                break;
            case 217:
                // OverVoltageMustTripCurve (urn:iso:std:iso:15118:-20:AC)
                break;
            case 218:
                // OverVoltageRideThroughNegativeCurveKFactor (urn:iso:std:iso:15118:-20:AC)
                break;
            case 219:
                // OverVoltageRideThroughPositiveCurveKFactor (urn:iso:std:iso:15118:-20:AC)
                break;
            case 220:
                // OverstayCosts (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 221:
                // P (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 222:
                // PGPData (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 223:
                // PGPKeyID (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 224:
                // PGPKeyPacket (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 225:
                // PercentageValue (urn:iso:std:iso:15118:-20:AC)
                break;
            case 226:
                // PermitService (urn:iso:std:iso:15118:-20:AC)
                break;
            case 227:
                // PgenCounter (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 228:
                // PhaseL1 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 229:
                // PhaseL2 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 230:
                // PhaseL3 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 231:
                // PowerDuringCessation (urn:iso:std:iso:15118:-20:AC)
                break;
            case 232:
                // PowerFactorExcitation (urn:iso:std:iso:15118:-20:AC)
                break;
            case 233:
                // PowerFactorValue (urn:iso:std:iso:15118:-20:AC)
                break;
            case 234:
                // PowerMonitoringMustTripCurve (urn:iso:std:iso:15118:-20:AC)
                break;
            case 235:
                // PowerReference (urn:iso:std:iso:15118:-20:AC)
                break;
            case 236:
                // PowerUpRamp (urn:iso:std:iso:15118:-20:AC)
                break;
            case 237:
                // PresentSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 238:
                // Priority (urn:iso:std:iso:15118:-20:AC)
                break;
            case 239:
                // Q (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 240:
                // RSAKeyValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 241:
                // ReactivePowerSupport (urn:iso:std:iso:15118:-20:AC)
                break;
            case 242:
                // Receipt (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 243:
                // Reference (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 244:
                // RemainingTimeToMaximumSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 245:
                // RemainingTimeToMinimumSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 246:
                // RemainingTimeToTargetSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 247:
                // ResponseCode (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 248:
                // RetrievalMethod (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 249:
                // RootCertificateID (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 250:
                // SCRatPOC (urn:iso:std:iso:15118:-20:AC)
                break;
            case 251:
                // SPKIData (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 252:
                // SPKISexp (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 253:
                // Scheduled_AC_CLReqControlMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 254:
                // Scheduled_AC_CLResControlMode (urn:iso:std:iso:15118:-20:AC)
                break;
            case 255:
                // Seed (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 256:
                // SessionID (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 257:
                // Setpoint (urn:iso:std:iso:15118:-20:AC)
                break;
            case 258:
                // Signature (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 259:
                // SignatureMethod (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 260:
                // SignatureProperties (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 261:
                // SignatureProperty (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 262:
                // SignatureValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 263:
                // SignedInfo (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_SignedInfoType(stream, &exiFrag->SignedInfo);
                exiFrag->SignedInfo_isUsed = 1u;
                break;
            case 264:
                // TargetSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 265:
                // TaxCosts (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 266:
                // TaxRuleID (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 267:
                // ThreePhase (urn:iso:std:iso:15118:-20:AC)
                break;
            case 268:
                // TimeAnchor (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 269:
                // TimeConstantPT1 (urn:iso:std:iso:15118:-20:AC)
                break;
            case 270:
                // TimeStamp (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 271:
                // Transform (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 272:
                // Transforms (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 273:
                // US_FrequencyDroop (urn:iso:std:iso:15118:-20:AC)
                break;
            case 274:
                // UnderFrequencyDroop (urn:iso:std:iso:15118:-20:AC)
                break;
            case 275:
                // UnderFrequencyMayTripCurve (urn:iso:std:iso:15118:-20:AC)
                break;
            case 276:
                // UnderFrequencyMustTripCurve (urn:iso:std:iso:15118:-20:AC)
                break;
            case 277:
                // UnderVoltageMayTripCurve (urn:iso:std:iso:15118:-20:AC)
                break;
            case 278:
                // UnderVoltageMomentaryCessationTripCurve (urn:iso:std:iso:15118:-20:AC)
                break;
            case 279:
                // UnderVoltageMustTripCurve (urn:iso:std:iso:15118:-20:AC)
                break;
            case 280:
                // UnderVoltageRideThroughNegativeCurveKFactor (urn:iso:std:iso:15118:-20:AC)
                break;
            case 281:
                // UnderVoltageRideThroughPositiveCurveKFactor (urn:iso:std:iso:15118:-20:AC)
                break;
            case 282:
                // Unit (urn:iso:std:iso:15118:-20:AC)
                break;
            case 283:
                // Value (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 284:
                // VoltVar (urn:iso:std:iso:15118:-20:AC)
                break;
            case 285:
                // VoltWatt (urn:iso:std:iso:15118:-20:AC)
                break;
            case 286:
                // VoltageTrip (urn:iso:std:iso:15118:-20:AC)
                break;
            case 287:
                // WattCosPhi (urn:iso:std:iso:15118:-20:AC)
                break;
            case 288:
                // WattVar (urn:iso:std:iso:15118:-20:AC)
                break;
            case 289:
                // X509CRL (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 290:
                // X509Certificate (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 291:
                // X509Data (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 292:
                // X509IssuerName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 293:
                // X509IssuerSerial (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 294:
                // X509SKI (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 295:
                // X509SerialNumber (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 296:
                // X509SubjectName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 297:
                // XPath (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 298:
                // Y (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 299:
                // db (urn:iso:std:iso:15118:-20:AC)
                break;
            case 300:
                // k (urn:iso:std:iso:15118:-20:AC)
                break;
            case 301:
                // s (urn:iso:std:iso:15118:-20:AC)
                break;
            case 302:
                // x (urn:iso:std:iso:15118:-20:AC)
                break;
            case 303:
                // xUnit (urn:iso:std:iso:15118:-20:AC)
                break;
            case 304:
                // y (urn:iso:std:iso:15118:-20:AC)
                break;
            case 305:
                // yUnit (urn:iso:std:iso:15118:-20:AC)
                break;
            default:
                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                break;
            }

            if (error == EXI_ERROR__NO_ERROR)
            {
                // End Fragment
                error = exi_basetypes_decoder_nbit_uint(stream, 9, &eventCode);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    if (eventCode != 307)
                    {
                        error = EXI_ERROR__INCORRECT_END_FRAGMENT_VALUE;
                    }
                }
            }
        }
    }

    return error;
}

// main function for decoding xmldsig fragment
int decode_iso20_ac_der_xmldsigFragment(exi_bitstream_t* stream, struct iso20_ac_der_xmldsigFragment* xmldsigFrag) {
    uint32_t eventCode;
    int error = exi_header_read_and_check(stream);

    if (error == EXI_ERROR__NO_ERROR)
    {
        init_iso20_ac_der_xmldsigFragment(xmldsigFrag);

        error = exi_basetypes_decoder_nbit_uint(stream, 6, &eventCode);
        if (error == EXI_ERROR__NO_ERROR)
        {
            error = EXI_ERROR__NOT_IMPLEMENTED_YET;
            switch (eventCode)
            {
            case 0:
                // CanonicalizationMethod (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_CanonicalizationMethodType(stream, &xmldsigFrag->CanonicalizationMethod);
                xmldsigFrag->CanonicalizationMethod_isUsed = 1u;
                break;
            case 1:
                // DSAKeyValue (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_DSAKeyValueType(stream, &xmldsigFrag->DSAKeyValue);
                xmldsigFrag->DSAKeyValue_isUsed = 1u;
                break;
            case 2:
                // DigestMethod (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_DigestMethodType(stream, &xmldsigFrag->DigestMethod);
                xmldsigFrag->DigestMethod_isUsed = 1u;
                break;
            case 3:
                // DigestValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 4:
                // Exponent (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 5:
                // G (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 6:
                // HMACOutputLength (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 7:
                // J (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 8:
                // KeyInfo (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_KeyInfoType(stream, &xmldsigFrag->KeyInfo);
                xmldsigFrag->KeyInfo_isUsed = 1u;
                break;
            case 9:
                // KeyName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 10:
                // KeyValue (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_KeyValueType(stream, &xmldsigFrag->KeyValue);
                xmldsigFrag->KeyValue_isUsed = 1u;
                break;
            case 11:
                // Manifest (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_ManifestType(stream, &xmldsigFrag->Manifest);
                xmldsigFrag->Manifest_isUsed = 1u;
                break;
            case 12:
                // MgmtData (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 13:
                // Modulus (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 14:
                // Object (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_ObjectType(stream, &xmldsigFrag->Object);
                xmldsigFrag->Object_isUsed = 1u;
                break;
            case 15:
                // P (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 16:
                // PGPData (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_PGPDataType(stream, &xmldsigFrag->PGPData);
                xmldsigFrag->PGPData_isUsed = 1u;
                break;
            case 17:
                // PGPKeyID (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 18:
                // PGPKeyPacket (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 19:
                // PgenCounter (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 20:
                // Q (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 21:
                // RSAKeyValue (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_RSAKeyValueType(stream, &xmldsigFrag->RSAKeyValue);
                xmldsigFrag->RSAKeyValue_isUsed = 1u;
                break;
            case 22:
                // Reference (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_ReferenceType(stream, &xmldsigFrag->Reference);
                xmldsigFrag->Reference_isUsed = 1u;
                break;
            case 23:
                // RetrievalMethod (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_RetrievalMethodType(stream, &xmldsigFrag->RetrievalMethod);
                xmldsigFrag->RetrievalMethod_isUsed = 1u;
                break;
            case 24:
                // SPKIData (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_SPKIDataType(stream, &xmldsigFrag->SPKIData);
                xmldsigFrag->SPKIData_isUsed = 1u;
                break;
            case 25:
                // SPKISexp (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 26:
                // Seed (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 27:
                // Signature (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_SignatureType(stream, &xmldsigFrag->Signature);
                xmldsigFrag->Signature_isUsed = 1u;
                break;
            case 28:
                // SignatureMethod (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_SignatureMethodType(stream, &xmldsigFrag->SignatureMethod);
                xmldsigFrag->SignatureMethod_isUsed = 1u;
                break;
            case 29:
                // SignatureProperties (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_SignaturePropertiesType(stream, &xmldsigFrag->SignatureProperties);
                xmldsigFrag->SignatureProperties_isUsed = 1u;
                break;
            case 30:
                // SignatureProperty (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_SignaturePropertyType(stream, &xmldsigFrag->SignatureProperty);
                xmldsigFrag->SignatureProperty_isUsed = 1u;
                break;
            case 31:
                // SignatureValue (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_SignatureValueType(stream, &xmldsigFrag->SignatureValue);
                xmldsigFrag->SignatureValue_isUsed = 1u;
                break;
            case 32:
                // SignedInfo (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_SignedInfoType(stream, &xmldsigFrag->SignedInfo);
                xmldsigFrag->SignedInfo_isUsed = 1u;
                break;
            case 33:
                // Transform (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_TransformType(stream, &xmldsigFrag->Transform);
                xmldsigFrag->Transform_isUsed = 1u;
                break;
            case 34:
                // Transforms (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_TransformsType(stream, &xmldsigFrag->Transforms);
                xmldsigFrag->Transforms_isUsed = 1u;
                break;
            case 35:
                // X509CRL (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 36:
                // X509Certificate (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 37:
                // X509Data (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_X509DataType(stream, &xmldsigFrag->X509Data);
                xmldsigFrag->X509Data_isUsed = 1u;
                break;
            case 38:
                // X509IssuerName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 39:
                // X509IssuerSerial (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ac_der_X509IssuerSerialType(stream, &xmldsigFrag->X509IssuerSerial);
                xmldsigFrag->X509IssuerSerial_isUsed = 1u;
                break;
            case 40:
                // X509SKI (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 41:
                // X509SerialNumber (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 42:
                // X509SubjectName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 43:
                // XPath (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 44:
                // Y (http://www.w3.org/2000/09/xmldsig#)
                break;
            default:
                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                break;
            }

            if (error == EXI_ERROR__NO_ERROR)
            {
                // End Fragment
                error = exi_basetypes_decoder_nbit_uint(stream, 6, &eventCode);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    if (eventCode != 46)
                    {
                        error = EXI_ERROR__INCORRECT_END_FRAGMENT_VALUE;
                    }
                }
            }
        }
    }

    return error;
}


